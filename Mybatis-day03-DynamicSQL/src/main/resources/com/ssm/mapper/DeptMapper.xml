<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.ssm.mapper.DeptMapper">

	<select id="getDept" resultType="com.ssm.domain.Dept">
		<if test="_databaseId=='mysql'">
			select * from tb_employees
		</if>

		<if test="_databaseId=='oracle'">
			select * from tb_employees
		</if>
	</select>

	如果父项目pom中使用的是：

	<dependencies>

		....

	</dependencies>
	方式，

	则子项目pom会自动使用pom中的jar包。

	如果你需要子类工程直接自动引用父类的jar包，可以使用这种管理方法

	如果父项目pom使用

	<dependencyManagement>

		<dependencies>

			....

		</dependencies>

	</dependencyManagement>
	方式，

	则子项目pom不会自动使用父pom中的jar包，

	如果需要使用，就要给出groupId和artifactId，无需给出version

	dependencyManagement:

	使用
	<dependencyManagement>
		是为了统一管理版本信息

		在子工程中使用时，还是需要引入坐标的，但是不需要给出version

		在我们项目顶层的POM文件中，
		<dependencyManagement>
			元素。

			通过它元素来管理jar包的版本，

			让子项目中引用一个依赖而不用显示的列出版本号。

			Maven会沿着父子层次向上找，

			直到找到一个拥有dependencyManagement元素的项目，

			然后它就会使用在这个dependencyManagement元素中指定的版本号。
		</dependencyManagement>


			官方地址:
			http://mp.baomidou.com
			代码发布地址:
			Github: https://github.com/baomidou/mybatis-plus
			Gitee:
			https://gitee.com/baomidou/mybatis-plus
			文档发布地址:
			http://mp.baomidou.com/#/?id=%E7%AE%80%E4%BB%8B







			EntityWrapper/Condition
			第一种配置方式:
				mybatis-config.xml:
					<plugins>
						<!-- 注册分页插件 -->
						<plugin interceptor="com.baomidou.mybatisplus.plugins.PaginationInterceptor">
						</plugin>
						<!-- 注册执行分析插件 -->
						<plugin interceptor="com.baomidou.mybatisplus.plugins.SqlExplainInterceptor">
							<property name="stopProceed" value="true" />
						</plugin>
						<!-- 注册性能分析插件 -->
						<plugin interceptor="com.baomidou.mybatisplus.plugins.PerformanceInterceptor">
							<property name="format" value="true" />
							<property name="maxTime" value="5"></property>
						</plugin>
						<!-- 注册乐观锁插件 -->
						<plugin
							interceptor="com.baomidou.mybatisplus.plugins.OptimisticLockerInterceptor">
						</plugin>
					</plugins>

			第二种配置方式:
				applicationContext.xml:
					<!-- 配置SqlSessionFactoryBean Mybatis提供的: org.mybatis.spring.SqlSessionFactoryBean 
						MP提供的:com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean -->
					<bean id="sqlSessionFactoryBean"
						class="com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean">
						<!-- 数据源 -->
						<property name="dataSource" ref="dataSource"></property>
						<property name="configLocation" value="classpath:mybatis-config.xml"></property>
						<!-- 别名处理 -->
						<property name="typeAliasesPackage" value="com.atguigu.mp.beans"></property>
		
						<!-- 注入全局MP策略配置 -->
						<property name="globalConfig" ref="globalConfiguration"></property>
		
						<!-- 插件注册 -->
						<property name="plugins">
							<list>
								<!-- 注册分页插件 -->
								<bean class="com.baomidou.mybatisplus.plugins.PaginationInterceptor"></bean>
		
								<!-- 注册执行分析插件 -->
								<bean class="com.baomidou.mybatisplus.plugins.SqlExplainInterceptor">
									<property name="stopProceed" value="true"></property>
								</bean>
		
								<!-- 注册性能分析插件 -->
								<bean class="com.baomidou.mybatisplus.plugins.PerformanceInterceptor">
									<property name="format" value="true"></property>
									<!-- <property name="maxTime" value="5"></property> -->
								</bean>
		
								<!-- 注册乐观锁插件 -->
								<bean
									class="com.baomidou.mybatisplus.plugins.OptimisticLockerInterceptor">
								</bean>
							</list>
						</property>
					</bean>
		
git:
 	工作区	git add  	暂存区	git commit	本地库	git push  远程仓库
 	
git命令:
	git config --global user.name 用户名
	git config --global user.email	密码
	git init						初始化本地库
	git status						查看本地库状态
	git add 文件名					添加到暂存区
	git commit -m "日志信息" 文件名		提交到本地库
	git commit -m "日志信息" 			提交冲突修改后的文件到本地库
	git reflog						查看历史记录
	git reset --hard 版本号			版本穿梭
	git rm --cached 文件名			删除暂存区文件
	git log							查看详细记录
 
 	git branch 分支名					创建分支
 	git branch -v					查看分支
 	git checkout 分支名				切换分支
 	git merge 分支名					把指定分支合并到当前分支上
 	
 	git clone 远程库					将远程库文件克隆到本地
 	git fork						将指定远程库插入远程库
 	git remote -v					查看远程库地址别名
 	git remote add 别名	远程库地址		创建远程库别名
 	git push 远程库	分支				将指定分支文件推送到远程仓库
 	git pull 远程库 	分支				将指定分支文件拉取到本地
 	
 	vim /etc/sysconfig/network-scripts/ifcfg.ens33
 	vim /etc/hostsname
 	
 	
 https://about.gitlab.com
 https://about.gitlab.com/installation	
 	
 	.gitconfig文件中设置忽略文件样式
 		
 		git.ignore配置文件文件
 			# Compiled class file
			*.class
			
			# Log file
			*.log
			
			# BlueJ files
			*.ctxt
			
			# Mobile Tools for Java (J2ME)
			.mtj.tmp/
			
			# Package Files #
			*.jar
			*.war
			*.nar
			*.ear
			*.zip
			*.tar.gz
			*.rar
			
			hs_err_pid*
			
			.classpath
			.project
			.settings
			target
			.idea
			*.iml
 		
 		.gitconfig
 			[user]
				name = interface
				email = 1070146808@qq.com
			[core]
				excludesfile=C:/Users/interface/git.ignore			
 
 
Redis:远程字典服务器


 	
 	
Spring Bean的完整生命周期:				

	创建容器:
	
		1:实例化BeanFactoryPostProcessor实现类
		
		2:执行BeanFactoryPostProcessor的postProcessBeanFactory方法
		
		3:实例化BeanPostProcessor实现类
		
		4:实例化InstantiationAwareBeanPostProcessorAdapter实现类
		
		5:执行InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法
		
		6:执行Bean的构造器
		
		7:执行InstantiationAwareBeanPostProcessor的postProcessPropertyValues方法
		
		8:为Bean注入属性
		
		9:调用BeanNameAware的setBeanName方法
		
		10:调用BeanFactoryAware的setBeanFactory方法
		
		11:执行BeanPostProcessor的postProcessBeforeInitialization方法
		
		12:调用InstantiationBean的afterPropertiesSet方法
		
		13:调用<bean></bean>的init-method属性指定的初始化方法
		
		14:执行BeanPostProcessor的postProcessAfterInitialization方法
		
		15:执行InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法
		
	销毁容器:
		调用DisposibleBean的destory方法
		调用<bean></bean>的destroy-method属性指定的销毁方法
Spring AOP:





	
Spring循环依赖:

	public class CircleTest {
	
	    private final static Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
	
	    public static void main(String[] args) throws Exception {
	        System.out.println(getBean(B.class).getA());
	        System.out.println(getBean(A.class).getB());
	    }
	
	    private static <T> T getBean(Class<T> beanClass) throws Exception {
	        String beanName = beanClass.getSimpleName().toLowerCase();
	        if (singletonObjects.containsKey(beanName)) {
	            return (T) singletonObjects.get(beanName);
	        }
	        // 实例化对象入缓存
	        Object obj = beanClass.newInstance();
	        singletonObjects.put(beanName, obj);
	        // 属性填充补全对象
	        Field[] fields = obj.getClass().getDeclaredFields();
	        for (Field field : fields) {
	            field.setAccessible(true);
	            Class<?> fieldClass = field.getType();
            String fieldBeanName = fieldClass.getSimpleName().toLowerCase();
            field.set(obj, singletonObjects.containsKey(fieldBeanName) ? singletonObjects.get(fieldBeanName) : getBean(fieldClass));
            field.setAccessible(false);
        }
        return (T) obj;
    }

}

class A {
    private B b;
    // ...get/set
}

class B {
    private A a;
		// ...get/set
}

使用全注解开发（基于maven）
	<packaging>war</packaging>
	<dependencies>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>5.2.10.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-jdbc</artifactId>
			<version>5.2.10.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
			<version>5.2.10.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis</artifactId>
			<version>3.5.6</version>
		</dependency>
		<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis-spring</artifactId>
			<version>1.3.0</version>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>8.0.28</version>
		</dependency>
		<dependency>
			<groupId>com.alibaba</groupId>
			<artifactId>druid</artifactId>
			<version>1.1.16</version>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.9.0</version>
		</dependency>
	</dependencies>
	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.tomcat.maven</groupId>
				<artifactId>tomcat7-maven-plugin</artifactId>
				<version>2.1</version>
				<configuration>
					<port>80</port>
					<path>/</path>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.8.1</version>
				<configuration>
					<source>8</source>
					<target>8</target>
				</configuration>
			</plugin>
		</plugins>
	</build>
	
	jdbc.properties:
		jdbc.driver=com.mysql.cj.jdbc.Driver 
		jdbc.url=jdbc:mysql://localhost:3306/ssm_db?useSSL=true&serverTimezone=UTC 
		jdbc.username=root 
		jdbc.password=root

	JdbcConfig类:

		public class JdbcConfig { 
			
			@Value("${jdbc.driver}") 
			private String driver; 
			
			@Value("${jdbc.url}") 
			private String url;
 
			@Value("${jdbc.username}") 
			private String username; 
			
			@Value("${jdbc.password}") 
			private String password; 
			
			@Bean 
			public DataSource dataSource(){ 
				DruidDataSource dataSource = new DruidDataSource(); 
				dataSource.setDriverClassName(driver); 
				dataSource.setUrl(url); 
				dataSource.setUsername(username); 
				dataSource.setPassword(password); 
				return dataSource; 
			} 
			
			@Bean 
			public PlatformTransactionManager transactionManager(DataSource dataSource){ 
				DataSourceTransactionManager ds = new DataSourceTransactionManager(); 
				ds.setDataSource(dataSource); 
				return ds; 
			} 
		}

	MyBatisConfig类

		public class MyBatisConfig { 
	
			@Bean 
			public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ 
				SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); 
				factoryBean.setDataSource(dataSource); 
				factoryBean.setTypeAliasesPackage("com.ali.domain"); 
				return factoryBean; 
			} 
			
			@Bean 
			public MapperScannerConfigurer mapperScannerConfigurer(){ 
				MapperScannerConfigurer msc = new MapperScannerConfigurer(); 
				msc.setBasePackage("com.ali.dao"); 
				return msc; 
			} 
		}
	
	SpringConfig类:

		@Configuration 
		@ComponentScan({"com.ali.service"}) 
		@PropertySource("classpath:jdbc.properties") 
		@Import({JdbcConfig.class,MyBatisConfig.class}) 
		@EnableTransactionManagement 
		public class SpringConfig { 
		
		}

	SpringMvcConfig类:

		@Configuration 
		@ComponentScan("com.ali.controller") 
		@EnableWebMvc 
		public class SpringMvcConfig { 
		
		}

	ServletConfig类
		
		public class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer { 
			
			protected Class<?>[] getRootConfigClasses() { 
				return new Class[]{SpringConfig.class}; 
			} 
			
			protected Class<?>[] getServletConfigClasses() { 
				return new Class[]{SpringMvcConfig.class}; 
			} 
			
			protected String[] getServletMappings() { 
				return new String[]{"/"}; 
			} 
		}

	DAO:

		public interface BookDao { 
			
			// @Insert("insert into tbl_book values(null,#{type},#{name},#{description})") 
			@Insert("insert into tbl_book (type,name,description) values(#{type},#{name},#{description})") 
			public void save(Book book); 
			
			@Update("update tbl_book set type = #{type}, name = #{name}, description = #{description} where id = #{id}") 
			public void update(Book book); 

			@Delete("delete from tbl_book where id = #{id}") 
			public void delete(Integer id); 

			@Select("select * from tbl_book where id = #{id}") 
			public Book getById(Integer id); 
			
			@Select("select * from tbl_book") 
			public List<Book> getAll(); 

		}		

	service接口：

		@Transactional//开启事务
		public interface BookService {

    		/**
     		 * 保存
     		 * @param book
     		 * @return
     		 */
   			 public boolean save(Book book);

    /**
     * 修改
     * @param book
     * @return
     */
    		public boolean update(Book book);

    /**
     * 按id删除
     * @param id
     * @return
     */
    		public boolean delete(Integer id);

    /**
     * 按id查询
     * @param id
     * @return
     */
    		public Book getById(Integer id);

    /**
     * 查询全部
     * @return
     */
    		public List<Book> getAll();
		}

	service实现类

@Service
public class BookServiceImpl implements BookService {
    @Autowired
    private BookDao bookDao;

    public boolean save(Book book) {
        bookDao.save(book);
        return true;
    }

    public boolean update(Book book) {
        bookDao.update(book);
        return true;
    }

    public boolean delete(Integer id) {
        bookDao.delete(id);
        return true;
    }

    public Book getById(Integer id) {
        return bookDao.getById(id);
    }

    public List<Book> getAll() {
        return bookDao.getAll();
    }
}


Java | ssm中通过自定义注解实现RESTful风格接口版本管理

	自定义注解:

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Mapping
public @interface ApiVersion {
    /*
     * api version code
     */
    int value();
}

自定义筛选条件

public class ApiVesrsionCondition implements RequestCondition<ApiVesrsionCondition> {
    
    // 路径中版本的前缀， 这里用 /v[1-9]/的形式
    private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile("v(\\d+)/");

    private int apiVersion;

    public ApiVesrsionCondition(int apiVersion){
        this.apiVersion = apiVersion;
    }

    /*
     * 将不同的筛选条件合并
     * 
     */
    @Override
    public ApiVesrsionCondition combine(ApiVesrsionCondition other) {
        return new ApiVesrsionCondition(other.getApiVersion());
    }
    
    /*
     * 根据request查找匹配到的筛选条件
     * 
     */
    @Override
    public ApiVesrsionCondition getMatchingCondition(HttpServletRequest request) {
        System.out.println(request.getRequestURI());
        Matcher m = VERSION_PREFIX_PATTERN.matcher(request.getRequestURI());
        if(m.find()){
            Integer version = Integer.valueOf(m.group(1));
            if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则返回当前最大版本
                return this;
        }
        return null;

    }

    /*
     * 实现不同条件类的比较，从而实现优先级排序
     * 
     */
    @Override
    public int compareTo(ApiVesrsionCondition other, HttpServletRequest request) {
        return other.getApiVersion() - this.apiVersion;
    }
    
    
    public int getApiVersion() {
        return apiVersion;
    }
}

重写RequestMappingHandlerMapping 的映射

public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {
    
    @Override   
    protected RequestCondition<ApiVesrsionCondition> getCustomTypeCondition(Class<?> handlerType) {
        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class);
        return createCondition(apiVersion);
    }

    @Override  
    protected RequestCondition<ApiVesrsionCondition> getCustomMethodCondition(Method method) {
        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);
        return createCondition(apiVersion);
    }
    //实例化RequestCondition
    private RequestCondition<ApiVesrsionCondition> createCondition(ApiVersion apiVersion) {
        return apiVersion == null ? null : new ApiVesrsionCondition(apiVersion.value());
    }
}

使我们自定义的拦截器生效
@Configuration
public class WebConfig extends WebMvcConfigurationSupport{
    @Override
    @Bean
    public RequestMappingHandlerMapping requestMappingHandlerMapping() {
        RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();
        handlerMapping.setOrder(0);
        handlerMapping.setInterceptors(getInterceptors());
        return handlerMapping;
    }
}

@Controller
@RequestMapping("/{version}/test")
public class TestController{

	@Autowired
	private TestService testService;
	
	@RequestMapping("/selectAll")
	@ApiVersion(value=1)
	@ResponseBody
	public String selectAll(){
		return "v1 select test";
	}
	
	@RequestMapping("/selectAll")
	@ApiVersion(value=2)
	@ResponseBody
	public String select(){
		return "v2 select test";
	}
}

url:
	/v1/test/selectAll
	/v2/test/selectAll


springboot中使用redis实现异步消息通知
 <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>1.5.14.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.2</version>
        </dependency>

        <dependency>
            <groupId>com.cdy</groupId>
            <artifactId>redis</artifactId>
            <version>2.0-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>com.cdy</groupId>
            <artifactId>common</artifactId>
            <version>2.0-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>2.4</version>
            </plugin>
        </plugins>
    </build>




SpringBoot启动类的扫描注解

	@SpringBootApplication(scanBasePackages ={"a","b"})
	@ComponentScan(basePackages = {"a","b","c"})
	@MapperScan({"com.kfit.*.mapper","org.kfit.*.mapper"})
	public class XXApplication extends SpringBootServletInitializer

	}

ComponentScan注解
	这个是 Spring 框架的注解，它用来指定组件扫描路径，如果用这个注解，它的值必须包含整个工程中全部需要扫描的路径。因为它会覆盖 SpringBootApplication 的默认扫描路径，导致其失效。
	失效表现有两种：
		(1):如果 ComponentScan 只包括一个值且就是默认启动类目录，SpringBootApplication 生效， ComponentScan 注解失效，报错：
		(2):如果 ComponentScan 指定多个具体子目录，此时 SpringBootApplication 会失效，Spring 只会扫描 ComponentScan 指定目录下的注解。
		           如果恰好有目录外的 Controller 类，很遗憾，这些控制器将无法访问。

MapperScan 注解
	这里又涉及到 @Mapper注解

	直接在Mapper类上面添加注解@Mapper，这种方式要求每一个mapper类都需要添加此注解，比较麻烦

	通过使用@MapperScan可以指定要扫描的Mapper类的包的路径

	这个是 MyBatis 的注解，会将指定目录下所有 Mapper 类封装成 MyBatis 的 BaseMapper类，生成对应的XxxMapper代理接口实现类然后注入 Spring 容器中，不需要额外的注解，就可以完成注入。





SpringBoot AOP	
	
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.0.3.RELEASE</version>
</parent>


<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-logging</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.aspectj</groupId>
        <artifactId>aspectjweaver</artifactId>
    </dependency>
</dependencies>

	@Aspect
	@Component
	public class LogAspects {
		
		@Pointcut("@annotation(com.ssm.annotation.LogAnnotation)")
		public void pointcut(){
			
		}
		
		@Before("pointcut()")
		public void logStart(JoinPoint jp){
			Object[] args = jp.getArgs();
			System.out.println("Method Name: "+jp.getSignature().getName()+"	@Before	除法运行开始....参数列表是,{"+Arrays.asList(args)+"}");
		}
		
		@After("pointcut()")
		public void logEnd(JoinPoint jp){
			Object[] args = jp.getArgs();
			System.out.println("Method Name: "+jp.getSignature().getName()+"	@After	除法运行结束....参数列表是,{"+Arrays.asList(args)+"}");
		}
		
		@AfterReturning(value="pointcut()",returning="result")
		public void logReturn(JoinPoint jp,Object result){
			System.out.println("Method Name: "+jp.getSignature().getName()+"	@AfterReturning	除法正常返回....运行结果是,{"+result+"}");
		}
		
		@AfterThrowing(value="pointcut()",throwing="ex")
		public void logException(JoinPoint jp,Exception ex){
			System.out.println("Method Name: "+jp.getSignature().getName()+"	@AfterThrowing	除法异常....异常信息是,{"+ex+"}");
		}
		
	}


	//返回通知
	@AfterReturning(returning="ret",pointcut="log()")
	public void doAfterReturning(Object ret) throws Throwable{
		System.out.println("除法正常返回....运行结果是,{}");
	}
	
	//异常通知
	@AfterThrowing(throwing="ex",pointcut="log()")
	public void throwss(JoinPoint jp,Exception ex){
		System.out.println("除法正常返回....运行结果是,{}");
	}


	@Retention(RetentionPolicy.RUNTIME)
	@Target({ElementType.METHOD,ElementType.TYPE})
	public @interface LogAnnotation {
		String value() default "";
	}
	
	package com.example.myblog.test;
	import org.aspectj.lang.JoinPoint; 
	import org.aspectj.lang.ProceedingJoinPoint; 
	import org.aspectj.lang.annotation.*; 
	import org.springframework.stereotype.Component; 
	@Component 
	@Aspect 
	public class AOPAnnotationTest { 
	
		//定义切入点 
		//@Pointcut("execution(public * com.only.mate.springboot.controller.*.*(..))")
		@Pointcut("@annotation(com.example.myblog.test.MyAnnotation)") 
		public void aspectTest(){
		
		} 
		//前置通知，切入点执行之前执行
		@Before("aspectTest()") 
		public void doBefore(JoinPoint joinPoint){ 
			System.out.println("前置通知"); 
		} 
		//后置通知，切入点执行之后执行
		@After("aspectTest()") 
		public void doAfter(JoinPoint joinPoint){ 
			System.out.println("后置通知");
		} 
		//最终通知，，切入点执行之后执行
		@AfterReturning("aspectTest()") 
		public void doAfterReturning(JoinPoint joinPoint){
		 	System.out.println("最终通知");
		} 
		//异常通知，切入点抛出异常执行 
		@AfterThrowing("aspectTest()") 
		public void deAfterThrowing(JoinPoint joinPoint){ 
			System.out.println("异常通知"); 
		} 
		//环绕通知，切入点执行前、后执行 
		@Around("aspectTest()") 
		public Object deAround(ProceedingJoinPoint joinPoint) throws Throwable{ 
			System.out.println("未执行"); 
			Object result = joinPoint.proceed(); 
			System.out.println("已执行"); 
			//返回结果 
			return result;
		} 
	}


SpringBoot集成ES:

	pom.xml:
	
		<dependency>
		    <groupId>org.elasticsearch</groupId>
		    <artifactId>elasticsearch</artifactId>
		    <version>7.1.0</version>
		</dependency>
		<dependency>
		    <groupId>org.elasticsearch.client</groupId>
		    <artifactId>elasticsearch-rest-high-level-client</artifactId>
		    <version>7.1.0</version>
		</dependency>
	
	application.properties:
	
		elasticsearch.host=localhost
		elasticsearch.port=9200
		elasticsearch.connTimeout=3000
		elasticsearch.socketTimeout=5000
		elasticsearch.connectionRequestTimeout=500
		
	配置类:
	
		@Configuration
		public class ElasticsearchConfiguration {
		
		    @Value("${elasticsearch.host}")
		    private String host;
		
		    @Value("${elasticsearch.port}")
		    private int port;
		
		    @Value("${elasticsearch.connTimeout}")
		    private int connTimeout;
		
		    @Value("${elasticsearch.socketTimeout}")
		    private int socketTimeout;
		
		    @Value("${elasticsearch.connectionRequestTimeout}")
		    private int connectionRequestTimeout;
		
		    @Bean(destroyMethod = "close", name = "client")
		    public RestHighLevelClient initRestClient() {
		        RestClientBuilder builder = RestClient.builder(new HttpHost(host, port))
		                .setRequestConfigCallback(requestConfigBuilder -> requestConfigBuilder
		                        .setConnectTimeout(connTimeout)
		                        .setSocketTimeout(socketTimeout)
		                        .setConnectionRequestTimeout(connectionRequestTimeout));
		        return new RestHighLevelClient(builder);
		    }
		}	
		
Vue的大文件上传:
	
		
高中数学集合：
	集合要素:
			确定性
			无序性
			互异性

	元素与集合关系:
			∈ ：属于
			不包含

		自然数集：
			N

		正整数集：
			N*


			create table course_1(
				cid BIGINT(20)
				PRIMARY KEY,
				cname VARCHAR(50) NOT NULL,
				user_id BIGINT(20) NOT NULL,
				cstatus VARCHAR(10) NOT NULL
			)

			第一种方式:


			SSM整合:
				pom.xml 依赖文件

				https://www.symphonyofscience.com/vids


			@ImportResource
				导入xml 配置文件


			protected final <T> List<T> removeDuplicates(List<T> list) {
				return new ArrayList<>(new LinkedHashSet<>(list));
			}


			SpringBoot的启动器命名规则:
				spring-boot-starter-*





			maven控制台运行程序
				<plugin>
					<groupId>org.codehaus.mojo</groupId>
					<artifactId>exec-maven-plugin</artifactId>
					<version>1.1-beta-1</version>
					<executions>
						<execution>
							<goals>
								<goal>java</goal>
							</goals>
						</execution>
					</executions>
					<configuration>
						<mainClass>com.package.MainClass</mainClass>
						<arguments>
							<argument>arg1</argument>
							<argument>arg2</argument>
						</arguments>
					</configuration>
				</plugin>


			配置开发者信息
				<developers>
					<developer>
						<id>eric</id>
						<name>Eric</name>
						<email>[email protected]</email>
						<url>http://eric.propellors.net</url>
						<organization>Codehaus</organization>
						<organizationUrl>http://mojo.codehaus.org</organizationUrl>
						<roles>
							<role>architect</role>
							<role>developer</role>
						</roles>
						<timezone>-6</timezone>
						<properties>
							<picUrl>http://tinyurl.com/prv4t</picUrl>
						</properties>
					</developer>
				</developers>

			Contributors
				<contributors>
					<contributor>
						<name>Noelle</name>
						<email>[email protected]</email>
						<url>http://energy1010.com</url>
						<organization>Energy1010</organization>
						<organizationUrl>http://energy1010.com</organizationUrl>
						<roles>
							<role>tester</role>
						</roles>
						<timezone>-5</timezone>
						<properties>
							<gtalk>[email protected]</gtalk>
						</properties>
					</contributor>
				</contributors>



			Mailing Lists
				<mailingLists>
					<mailingList>
						<name>User List</name>
						<subscribe>[email protected]</subscribe>
						<unsubscribe>[email protected]</unsubscribe>
						<post>[email protected]</post>
						<archive>http://127.0.0.1/user/</archive>
						<otherArchives>
							<otherArchive>http://base.google.com/base/1/127.0.0.1</otherArchive>
						</otherArchives>
					</mailingList>
				</mailingLists>



			Distribution Management
			用于配置分发管理，配置相应的产品发布信息,主要用于发布，在执行mvn
			deploy后表示要发布的位置
			1 配置到文件系统
				<distributionManagement>
					<repository>
						<id>proficio-repository</id>
						<name>Proficio Repository</name>
						<url>file://${basedir}/target/deploy</url>
					</repository>
				</distributionManagement>
			2 使用ssh2配置
				<distributionManagement>
					<repository>
						<id>proficio-repository</id>
						<name>Proficio Repository</name>
						<url>scp://sshserver.yourcompany.com/deploy</url>
					</repository>
				</distributionManagement>
			3 使用sftp配置
				<distributionManagement>
					<repository>
						<id>proficio-repository</id>
						<name>Proficio Repository</name>
						<url>sftp://ftpserver.yourcompany.com/deploy</url>
					</repository>
				</distributionManagement>
			4 使用外在的ssh配置
			编译扩展用于指定使用energy1010外在ssh提供，用于提供你的文件到相应的远程服务器。
				<distributionManagement>
					<repository>
						<id>proficio-repository</id>
						<name>Proficio Repository</name>
						<url>scpexe://sshserver.yourcompany.com/deploy</url>
					</repository>
				</distributionManagement>
				<build>
					<extensions>
						<extension>
							<groupId>org.apache.maven.energy1010</groupId>
							<artifactId>energy1010-ssh-external</artifactId>
							<version>1.0-alpha-6</version>
						</extension>
					</extensions>
				</build>

			5 使用ftp配置
				<distributionManagement>
					<repository>
						<id>proficio-repository</id>
						<name>Proficio Repository</name>
						<url>ftp://ftpserver.yourcompany.com/deploy</url>
					</repository>
				</distributionManagement>
				<build>
					<extensions>
						<extension>
							<groupId>org.apache.maven.energy1010</groupId>
							<artifactId>energy1010-ftp</artifactId>
							<version>1.0-alpha-6</version>
						</extension>
					</extensions>
				</build>

			repository 对应于你的开发库，用户信息通过settings.xml中的server取得



			Profiles
			类似于settings.xml中的profiles，增加了几个元素，如下的样式：
				<profiles>
					<profile>
						<id>test</id>
						<activation>...</activation>
						<build>...</build>
						<modules>...</modules>
						<repositories>...</repositories>
						<pluginRepositories>...</pluginRepositories>
						<dependencies>...</dependencies>
						<reporting>...</reporting>
						<dependencyManagement>...</dependencyManagement>
						<distributionManagement>...</distributionManagement>
					</profile>
				</profiles>

			Maven把自己的包部署到远程仓库

			1，配置项目的POM文件

				<dependencyManagement>
					<dependencies>
						</dependency>
			
							......
			
						</dependency>
					</dependencies>
				</dependencyManagement>
				<repository>
					<id>nexus-snapshots</id>
					<url>http://192.168.1.232:8080/content/repositories/releases</url>
				</repository>
				<snapshotRepository>
					<id>nexus-releases</id>
					<url>http://192.168.1.232:8080/content/repositories/snapshots</url>
				</snapshotRepository>
			</distributionManagement>
			
			2，运行maven命令

				mvn clean deploy


SpringBoot大文件上传 JAVA配置:-

	import javax.servlet.MultipartConfigElement;
	
	import org.springframework.boot.web.servlet.MultipartConfigFactory;
	import org.springframework.context.annotation.Bean;
	import org.springframework.context.annotation.Configuration;
	import org.springframework.util.unit.DataSize;
	
	@Configuration
	public class SpringUpFileConfig {
	
		@Bean
		public MultipartConfigElement multipartConfigElement() {
			MultipartConfigFactory factory = new MultipartConfigFactory();
			// 单个文件大小20mb
			factory.setMaxFileSize(DataSize.ofMegabytes(20L));
			// 设置总上传数据大小1GB
			factory.setMaxRequestSize(DataSize.ofGigabytes(1L));
	
			return factory.createMultipartConfig();
		}
	}



		
RequestMappingHandlerMapping
请求参数注解:

	@PathVariable(路径变量)
	@RequestHeader(获取请求头)
	@RequestParam(获取请求参数)
	@CookieValue(获取cookie值)
	@RequestAttribute(获取request域属性)
	@RequestBody(获取请求体,只有Post请求才有)
	@MatrixVariable(矩阵变量)

获取重定向数据:

  方法一:
		@RequestMapping("/zh")
	    public String reZh(){

	        return "redirect:/date?time={time}";
	  	}
	
	
	  	@GetMapping("/date")
	   	public String toDate(@RequestParam(value = "time",required = false)String time,HttpServletRequest request){
	        
	        return s;
	    }
	    
    方法二:
    
		@RequestMapping("flash1")
		public String flash(RedirectAttributes redirectAttributes) {
			redirectAttributes.addFlashAttribute("username", "Biao");
			return "redirect:flash2";
		}
		
		@RequestMapping("flash2")
		public String flash2(@ModelAttribute("username") String username) {
			System.out.println("拿到的username="+username);
			return "username: " + username;
		}
		
   方法三:
		@RequestMapping("/zh")
	    public String reZh(RedirectAttributes attr){
	        attr.addAttribute("time","ssssss");
	        attr.addFlashAttribute("hi","hello");
	        return "redirect:/date";
	  	}
	
	
	  	@GetMapping("/date")
	   	public String toDate(@RequestParam(value = "time",required = false)String time,HttpServletRequest request){
	        Object hi = RequestContextUtils.getInputFlashMap(request).get("hi");
	        return s;
	    }
	    
	    
页面开发,cookie禁用了,session里面的内容怎么使用:
url重写:
	/abc;jessionid=xxx


	@GetMapping("/goto")
	public String goToPage(HttpServletRequest request){
		request.setAttribute("msg","成功了");
		request.setAttribute("code",200);
		return "forward:/success.html"; //转发到/success请求
	}

	@ResponseBody
	@GetMapping("/success.html")
	public Map success(@RequestAttribute("msg")String msg,@RequestAttribute("code")Integer code,HttpServletRequest request){
		Object msg1 = request.getAttribute("msg");
		Map <String , Object> map = new HashMap<>();
		map.put("reqMethod_msg",msg1);
		map.put("annotation_msg",msg);
		map.put("annotation_code",code);
		return map;
	}

 

	@RestController
	public class ParameterTestController {
	
		// url: car/2/owner/zhangsan?ages=12&inters=baskball&inters=game
		@GetMapping("/car/{id}/owner/{username}")
		public Map<String , Object>getCar(@PathVariable("id") Integer id,@PathVariable("username")String name,@PathVariable Map<String , String>pv,@RequestHeader("User-Agent") String userAgent,@RequestHeader Map<String , String>header,@RequestParam("ages") Integer age,@RequestParam("inters") List<String>inters,@RequestParam Map<String , String>params,@CookieValue("_ga") String _ga,@CookieValue("_ga")Cookie cookie){
		
			Map<String , Object>map = new HashMap<>(); //Map存放在request请求域中
			//
			map.put("id",id);
			// map.put("name",name);
			//
			map.put("pv",pv);
			// map.put("userAgent",userAgent);
			//
			map.put("headers",header);
			map.put("age",age);
			map.put("inters",inters);
			map.put("params",params);
			map.put("_ga",_ga);
			System.out.println(cookie.getName()+"===>"+cookie.getValue());
			return map;
		}
	
		// url: 表单提交：save?age=12&inters=baskball&inters=game @PostMapping("/save")
		public Map postMethod(@RequestBody String content) {
			Map<String, Object> map = new HashMap<>();
			map.put("content", content);
			return map;
		}
	
		// 1、语法：请求路径：/cars/sell;low=34;brand=byd,audi,yd;brand=age
		//2、SpringBoot默认是禁用了矩阵变量的功能
		//手动开启：原理。对于路径的处理。UrlPathHelper进行解析。
		//removeSemicolonContent（移除分号内容）支持矩阵变量的
		// 3、矩阵变量必须有url路径变量才能被解析
		@GetMapping("/cars/{path}")
	
		public Map carsSell(@MatrixVariable("low") Integer low,@MatrixVariable("brand") List<String>brand,@PathVariable("path") String path){
			Map<String , Object>map = new HashMap<>();
			map.put("low",low);
			map.put("brand",brand);
			map.put("path",path);
			return map;
		}
	
		//语法：请求路径：/boss/1;age=20/2;age=10
	
		@GetMapping("/boss/{bossId}/{empId}")
		public Map boss(@MatrixVariable(value = "age",pathVar ="bossId")Integer bossAge,@MatrixVariable(value = "age",pathVar ="empId") Integer empAge){
		
		}
	}


RequestMappingHandlerMapping解析映射简单介绍：

	@RequestMapping通过RequestMappingHandlerMapping进行解析！
	
	HandlerMapping是一个根据URL映射到Handler的方法。
	
	RequestMappingHandlerMapping是HandlerMapping的一个子类！
	
	RequestMappingHandlerMapping他的父类有InitializingBean，所有在spring启动实例化的时候会调用afterPropertiesSet()方法。解析逻辑就在这里。
	
	RequestMappingHandlerMapping有俩个过程：解析、映射

@RequestMapping解析源码流程：

	容器加载，调用RequestMappingHandlerMapping的afterPropertiesSet()。
	
	调用父类的afterPropertiesSet()方法。
	
	调用initHandlerMethods()方法。
	
	循环每一个Bean，看方法上有@RequestMapping或者@Controller的Bean。
	
	解析HandlerMethods，进行封装RequestMappingInfo。
	
	将封装好的RequestMappingInfo存起来：key为路径，值为mapping（RequestMappingInfo）

@RequestMapping映射源码流程：
		请求进来，调用getHandler方法。
		获取当前请求对应的HandlerMethod。
		通过UrlPathHelper对象，用于来解析从们的request中解析出请求映射路径。
		更具路径去pathLookup中找。
		上面没找到，从所有的里面找有通配符的。
		找到多个进行排序，优先级：? > * > {} >** 。
		不为空拿到第一个返回。
		如果为空获取默认的。默认还是空的，直接返回null。
		封装拦截器，返回。

SessionFixationProtectionEvent/HttpSessionIdListener:
	用于监听Session管理
	
DispatcherServlet:

	Handler：代表@RequestMapping注解的Controller类,@RequestMapping注解的Method方法
	HandlerMapping:获取 @RequestMapping 注解的Controller类和Method方法信息

视图解析:ViewResolver：

	DispatcherServlet.processDispatchResult()/DispatcherServlet.render()
	RedirectView:重定向封装的View	return "redirect:main.html";
	InternalResourceView:转发封装的View return "forward:main.html";
	其他的:ThymeleafViewResolver:  return "index";
	
		重定向:
			@PostMapping("/loginProcess")
			public String loginProcess(User user){
				System.out.println(user.toString());
				return "redirect:main.html?userName="+user.getUserName();
			}
			
			@GetMapping("/main.html")
			public String mainPage(@RequestParam("userName") String userName,ModelMap modelMap){
				modelMap.put("userName", userName);
				return "index";
			}

请求映射处理:

	RequestMappingHandlerMapping:自定义实现: implements RequestCondition, implements RequestMappingHandlerMapping
		确定@RequestMapping()对应的Handler类和方法

请求参数处理:

	HandlerAdapter:(RequestMappingHandlerAdapter)
		适配器执行目标方法并确定方法参数的每一个值
		
	请求参数解析器:
		HandlerMethodArgumentResolver:
		 	确定将要执行的目标方法的每一个参数的值是什么;
			
				处理Map类型参数:
					MapMethodProcessor:
				
				处理Model类型参数:
					ModelMethodProcessor:
				
				处理Servlet API参数:
					ServletRequestMethodArgumentResolver:
				
				处理自定义参数类型:
					ServletModelAttributeMethodProcessor:
	
				WebDataBinder:
					web数据绑定器，将请求参数的值绑定到指定的JavaBean里面利用它里面的 Converters将请求数据转成指定的数据类型。再次封装到JavaBean中
			
				Request请求Input数据自定义类型转换:
					implements Converter:
			
					 //1、WebMvcConfigurer定制化SpringMVC的功能
						@Bean
						public WebMvcConfigurer webMvcConfigurer(){
							return new WebMvcConfigurer() {
								@Override
								public void configurePathMatch(PathMatchConfigurer configurer) {
									UrlPathHelper urlPathHelper = new UrlPathHelper();
									//不移除；后面的内容。矩阵变量功能就可以生效
									urlPathHelper.setRemoveSemicolonContent(false);
									configurer.setUrlPathHelper(urlPathHelper);
								}
							};
						}
						/**
						*输入的参数url?pet=angle,12 自定义类型转换
						*
						*
						*/
						@Override
						public void addFormatters(FormatterRegistry registry) {
							registry.addConverter(new Converter<String , Pet>() {
							
								@Override
								public Pet convert(String source) {
									//啊猫,3
									if(!StringUtils.isEmpty(source)){
										Pet pet = new Pet();
										String[] split = source.split(",");
										pet.setName(split[0]);
										pet.setAge(Integer.parseInt(split[1]));
										return pet;
									}
									return null;
								}
							});
						}											


				
返回参数处理:

	HandlerMethodReturnValueHandler:handleReturnValue()
		确定返回值格式

		Response响应OutPut数据相应格式:

		/**
		 *
		 * 自定义的Converter
		 */
		public class GuiguMessageConverter implements HttpMessageConverter<Person> {
		
			@Override
			public boolean canRead(Class<?> clazz, MediaType mediaType) {
				return false;
			}

			@Override
			public boolean canWrite(Class<?> clazz, MediaType mediaType) {
				return clazz.isAssignableFrom(Person.class);
			}
		
			/**
			 *
			 * 服务器要统计所有MessageConverter都能写出哪些内容类型
			 *
			 *
			 * application/x-guigu
			 * 
			 * @return
			 */
			@Override
			public List<MediaType> getSupportedMediaTypes() {
				return MediaType.parseMediaTypes("application/x-guigu");
			}
		
			@Override
			public Person read(Class<? extends Person> clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException {
				return null;
			}

			@Override
			public void write(Person person, MediaType contentType, HttpOutputMessage outputMessage)throws IOException, HttpMessageNotWritableException {
				// 自定义协议数据的写出
				String data = person.getUserName() + ";" + person.getAge() + ";" + person.getBirth();
				// 写出去
				OutputStream body = outputMessage.getBody();
				body.write(data.getBytes());
			}
		}


		@Configuration(proxyBeanMethods = false)
		public class WebConfig /*implements WebMvcConfigurer*/ {
	
	   	 	//1、WebMvcConfigurer定制化SpringMVC的功能
	    	@Bean
	    	public WebMvcConfigurer webMvcConfigurer(){
	        	return new WebMvcConfigurer() {
	        		/**
	        	 	 *	自定义数据返回格式
	        	 	 *
	        	 	 *
	        	 	 *
	        	 	 */
	            	@Override
	            	public void extendMessageConverters(List<HttpMessageConverter<?> converters) {
						converters.add(new GuiguMessageConverter());
					}
				};
			}
  		}


拦截器: implements HandlerInterceptor

	拦截器运行流程:
	
		DispatcherServlet.doDispatch()
		HandlerExecutionChain.applyPreHandle()
		HandlerExecutionChain.applyPostHandle()
		
	运行原理:
	
		1、根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有 拦截器】
		2、先来顺序执行 所有拦截器的 preHandle方法
			● 1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle
			● 2、如果当前拦截器返回为false。直接    倒序执行所有已经执行了的拦截器的  afterCompletion；
		3、如果任何一个拦截器返回false。直接跳出不执行目标方法
		4、所有拦截器都返回True。执行目标方法
		5、倒序执行所有拦截器的postHandle方法。
		6、前面的步骤有任何异常都会直接倒序触发 afterCompletion
		7、页面成功渲染完成以后，也会倒序触发 afterCompletion

	pom.xml
		<dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

	import lombok.extern.slf4j.Slf4j;
	import org.springframework.web.servlet.HandlerInterceptor;
	import org.springframework.web.servlet.ModelAndView;
	
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;
	import javax.servlet.http.HttpSession;
	
	/**
	 * 登录检查
	 * 1、配置好拦截器要拦截哪些请求
	 * 2、把这些配置放在容器中
	 */
	@Slf4j
	public class LoginInterceptor implements HandlerInterceptor {
	
	    /**
	     * 目标方法执行之前
	     * @param request
	     * @param response
	     * @param handler
	     * @return
	     * @throws Exception
	     */
	    @Override
	    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
	
	        String requestURI = request.getRequestURI();
	        log.info("preHandle拦截的请求路径是{}",requestURI);
	
	        //登录检查逻辑
	        HttpSession session = request.getSession();
	
	        Object loginUser = session.getAttribute("loginUser");
	
	        if(loginUser != null){
	            //放行
	            return true;
	        }
	
	        //拦截住。未登录。跳转到登录页
	        request.setAttribute("msg","请先登录");
			//re.sendRedirect("/");
	        request.getRequestDispatcher("/").forward(request,response);
	        return false;
	    }
	
	    /**
	     * 目标方法执行完成以后
	     * @param request
	     * @param response
	     * @param handler
	     * @param modelAndView
	     * @throws Exception
	     */
	    @Override
	    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
	        log.info("postHandle执行{}",modelAndView);
	    }
	
	    /**
	     * 页面渲染以后
	     * @param request
	     * @param response
	     * @param handler
	     * @param ex
	     * @throws Exception
	     */
	    @Override
	    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
	        log.info("afterCompletion执行异常{}",ex);
	    }
	}
	
	/**
	 * 1、编写一个拦截器实现HandlerInterceptor接口
	 * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）
	 * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】
	 *
	 * 
	 *     
	 */
	@Configuration
	public class AdminWebConfig implements WebMvcConfigurer{
	
	
	    @Override
	    public void addInterceptors(InterceptorRegistry registry) {
	        registry.addInterceptor(new LoginInterceptor())
	                .addPathPatterns("/**")  //所有请求都被拦截包括静态资源
	                .excludePathPatterns("/","/login","/css/**","/fonts/**","/images/**",
	                        "/js/**","/aa/**"); //放行的请求
	    }
	}
	

文件上传:
		
	● 原理步骤
		  ○ 1、请求进来使用文件上传解析器判断（isMultipart）并封装（resolveMultipart，返回MultipartHttpServletRequest）文件上传请求
		  ○ 2、参数解析器来解析请求中的文件内容封装成MultipartFile
		  ○ 3、将request中文件信息封装为一个Map；MultiValueMap<String, MultipartFile>
		FileCopyUtils。实现文件流的拷贝
		
	自动配置文件上传处理规则:MultipartAutoConfiguration.class/MultipartProperties.class
	
		文件上传处理流程:
			DispatcherServlet.doDispatch()
			HandlerAdapter.handle()
			AbstractHandlerMethodAdapter.handle()
			AbstractHandlerMethodAdapter.handleInternal()
			RequestMappingHandlerAdapter.handleInternal()
			RequestMappingHandlerAdapter.invokeHandlerMethod()
			ServletInvocableHandlerMethod.invokeAndHandle()
			ServletInvocableHandlerMethod.invokeForRequest()
			InvocableHandlerMethod.invokeForRequest()
			InvocableHandlerMethod.getMethodArgumentValues()
			HandlerMethodArgumentResolverComposite.resolveArgument()
		
	  
	前端页面:
	
		 <form action="${website}file/file/${id}" method="post" enctype="multipart/form-data">
	        <input type="file" name="headImg" class="file" id="headImg" size="28" /> //单文件上传
	        <input type="file" name="photos" class="file" id="photos" multiple /> //多文件上传
	        <input type="submit"  name="submit" class="btn" value="上传" />
	    </form>
	    
	    后端代码:
	    
	    /**
	     * MultipartFile 自动封装上传过来的文件
	     * @param email
	     * @param username
	     * @param headerImg
	     * @param photos
	     * @return
	     */
	    @PostMapping("/upload")
	    public String upload(@RequestParam("email") String email,
	                         @RequestParam("username") String username,
	                         @RequestPart("headerImg") MultipartFile headerImg,
	                         @RequestPart("photos") MultipartFile[] photos) throws IOException {
	
	        log.info("上传的信息：email={}，username={}，headerImg={}，photos={}",
	                email,username,headerImg.getSize(),photos.length);
	
	        if(!headerImg.isEmpty()){
	            //保存到文件服务器，OSS服务器
	            String originalFilename = headerImg.getOriginalFilename();
	            headerImg.transferTo(new File("H:\\cache\\"+originalFilename));
	        }
	
	        if(photos.length > 0){
	            for (MultipartFile photo : photos) {
	                if(!photo.isEmpty()){
	                    String originalFilename = photo.getOriginalFilename();
	                    photo.transferTo(new File("H:\\cache\\"+originalFilename));
	                }
	            }
	        }
	        return "main";
	    }
	    
		@RequestMapping("/fileUploadController")
		@ResponseBody
		public Map<String, String> FileUpload(@RequestParam("filename")MultipartFile fileName){
			System.out.println(fileName.getOriginalFilename());
			Map<String,String> resultMap = new HashMap<String, String>();
			resultMap.put("msg", "success");
			return  resultMap;
		}
	    
	    application.properties:
	    	spring.servlet.multipart.max-file-size=10MB
			spring.servlet.multipart.max-request-size=100MB
			
		

	
		

错误处理机制:

	自定义错误页面:templates/error/404.html,templates/error/500.html
	
	自动配置异常处理规则:ErrorMvcAutoConfiguration.class
		  ○ 容器中的组件：类型：DefaultErrorAttributes -> id：errorAttributes
			    ■ public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver
			    ■ DefaultErrorAttributes：定义错误页面中可以包含哪些数据。
			    
		  ○ 容器中的组件：类型：BasicErrorController --> id：basicErrorController（json+白页 适配响应）
		    	■ 处理默认 /error 路径的请求；页面响应 new ModelAndView("error", model)；
		    	■ 容器中有组件 View->id是error；（响应默认错误页）
		    	■ 容器中放组件 BeanNameViewResolver（视图解析器）；按照返回的视图名作为组件的id去容器中找View对象。
		  ○ 容器中的组件：类型：DefaultErrorViewResolver -> id：conventionErrorViewResolver
		    	■ 如果发生错误，会以HTTP的状态码 作为视图页地址（viewName），找到真正的页面
		    	■ error/404、5xx.html	    
			    
		异常处理流程:
			DispatcherServlet.doDispatch()
			DispatcherServlet.processDispatchResult()
			DispatcherServlet.processHandlerException()
			HandlerExceptionResolver.resolveException()
				HandlerExceptionResolverComposite.resolveException()
	
	
	自定义异常处理机制:
	
		第一种方案:	@ControllerAdvice+@ExceptionHandler
		
			import lombok.extern.slf4j.Slf4j;
			import org.springframework.web.bind.annotation.ControllerAdvice;
			import org.springframework.web.bind.annotation.ExceptionHandler;
			
			/**
			 * 处理整个web controller的异常
			 */
			@Slf4j
			@ControllerAdvice
			public class GlobalExceptionHandler {
			
			    @ExceptionHandler({ArithmeticException.class,NullPointerException.class})  //处理异常
			    public String handleArithException(Exception e){
			
			        log.error("异常是：{}",e);
			        return "login"; //视图地址
			    }
			}
			

			public class ExceptionHandlerController {
			
			    @ExceptionHandler
			    @ResponseBody
			    public Object expHandler(Exception e) {
			        return new Result(e.getMessage(), 500);
			    }
			    
			}
			
			class Result<D> implements Serializable {
			
			    private int status;
			    private D data;
			    private String message;
			    public Result() {
			    }
			    public Result(String message, Integer code) {
			        this.status = code;
			        this.message = message;
			    }
			    @Override
			    public String toString() {
			        return new Gson().toJson(this);
			    }
			    
			}
		第二种方案:	@ResponseStatus(value= HttpStatus.FORBIDDEN,reason = "用户数量太多")
		
			@ResponseStatus(value= HttpStatus.FORBIDDEN,reason = "用户数量太多")
			public class UserTooManyException extends RuntimeException {
			
			    public  UserTooManyException(){
			
			    }
			    public  UserTooManyException(String message){
			        super(message);
			    }
			}
			
		第三种方案:	implements HandlerExceptionResolver
		
			@Order(value= Ordered.HIGHEST_PRECEDENCE)  //优先级，数字越小优先级越高
			@Component
			public class CustomerHandlerExceptionResolver implements HandlerExceptionResolver {
			    @Override
			    public ModelAndView resolveException(HttpServletRequest request,
			                                         HttpServletResponse response,
			                                         Object handler, Exception ex) {
			
			        try {
			            response.sendError(511,"我喜欢的错误");
			        } catch (IOException e) {
			            e.printStackTrace();
			        }
			        return new ModelAndView();
			    }
			}
			
2、内容协商
	根据客户端接收能力不同，返回不同媒体类型的数据	
			
		内容协商策略:
			ContentNegotiationStrategy.class
			ContentNegotiationConfigurer.class	
		
	开启浏览器参数方式内容协商功能:
	
		application.properties:
			spring.mvc.contentnegotiation.favor-parameter=true
			
		请求url：
		 
			http://localhost:8080/test/person?format=json
			http://localhost:8080/test/person?format=xml
		/**
		* 1、浏览器发请求直接返回 xml
				[application/xml]
				jacksonXmlConverter
		* 2、如果是ajax请求 返回
				json [application/json]
				jacksonJsonConverter
		*
		3、如果硅谷app发请求，返回自定义协议数据 [appliaction/x-guigu]
				xxxxConverter
			* 属性值1;属性值2;
			*
			* 步骤：
			*
				1、添加自定义的MessageConverter进系统底层
			*
				2、系统底层就会统计出所有MessageConverter能操作哪些类型
				
			* 	3、客户端内容协商
				[guigu--->guigu]
			*
			* 作业：如何以参数的方式进行内容协商
			* @return
			*/
			@ResponseBody //利用返回值处理器里面的消息转换器进行处理
			@GetMapping(value = "/test/person")
			public Person getPerson(){
				Person person = new Person();
				person.setAge(28);
				person.setBirth(new Date());
				person.setUserName("zhangsan");
				return person;
			}
	
	
		/**
		 *
		 * 自定义的Converter
		 */
		public class GuiguMessageConverter implements HttpMessageConverter<Person> {
		
			@Override
			public boolean canRead(Class<?> clazz, MediaType mediaType) {
				return false;
			}

			@Override
			public boolean canWrite(Class<?> clazz, MediaType mediaType) {
				return clazz.isAssignableFrom(Person.class);
			}
		
			/**
			 *
			 * 服务器要统计所有MessageConverter都能写出哪些内容类型
			 *
			 *
			 * application/x-guigu
			 * 
			 * @return
			 */
			@Override
			public List<MediaType> getSupportedMediaTypes() {
				return MediaType.parseMediaTypes("application/x-guigu");
			}
		
			@Override
			public Person read(Class<? extends Person> clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException {
				return null;
			}

			@Override
			public void write(Person person, MediaType contentType, HttpOutputMessage outputMessage)throws IOException, HttpMessageNotWritableException {
				// 自定义协议数据的写出
				String data = person.getUserName() + ";" + person.getAge() + ";" + person.getBirth();
				// 写出去
				OutputStream body = outputMessage.getBody();
				body.write(data.getBytes());
			}
		}
	
	@Bean
    public WebMvcConfigurer webMvcConfigurer(){
        return new WebMvcConfigurer() {
            /**
             * 自定义内容协商策略
             * @param configurer
             */
            @Override
            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
                // 自定义策略
                // ContentNegotiationConfigurer mediaTypes(@Nullable Map<String, MediaType> mediaTypes)
                Map<String, MediaType> map = new HashMap<>();
                map.put("json", MediaType.APPLICATION_JSON);
                map.put("xml", MediaType.APPLICATION_ATOM_XML);
                map.put("gg",MediaType.parseMediaType("applicaion/x-z"));
                // 指定基于参数的解析类型
                ParameterContentNegotiationStrategy negotiationStrategy = new ParameterContentNegotiationStrategy(map);
                // 指定基于请求头的解析
                HeaderContentNegotiationStrategy headerContentNegotiationStrategy = new HeaderContentNegotiationStrategy();
                configurer.strategies(Arrays.asList(negotiationStrategy));
            }

			/**
	         *	自定义数据返回格式
	         *
	         *
	         *
	         */
	        @Override
	        public void extendMessageConverters(List<HttpMessageConverter<?> converters) {
				converters.add(new GuiguMessageConverter());
			}
        };
    }


Map,Model(map,model里面的数据会被放在request的请求域
	request.setAttribute())
	RedirectAttributes(重定向携带数据)
	ServletResponse(response)

		@GetMapping("/params")
		public String testParam(Map<String , Object>map,Model model,HttpServletRequest request,HttpServletResponse response){
			map.put("hello","world");
			model.addAttribute("world","hello");
			request.setAttribute("message","HelloWorld");
			Cookie cookie = new Cookie("c1","v1");
			cookie.setDomain("localhost");
			response.addCookie(cookie);
			return"forward:/success"; //转发到 /success请求
		}



	数据响应:
	1、响应JSON
	1.1、jackson.jar+@ResponseBody 自动返回JSON数据
	
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-web</artifactId>
			</dependency>

返回参数处理器:

	HandlerMethodReturnValueHandler：
		●
			1、返回值处理器判断是否支持这种类型返回值 supportsReturnType
		●
			2、返回值处理器调用 handleReturnValue 进行处理
		●
			3、RequestResponseBodyMethodProcessor
				可以处理返回值标了@ResponseBody 注解的。
				○ 1. 利用MessageConverters 进行处理 将数据写为json
					■
						1、内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型）
					■
						2、服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据，
					■
						3、SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter，看谁能处理？
						●
							1、得到MappingJackson2HttpMessageConverter可以将对象写为json
						●
							2、利用MappingJackson2HttpMessageConverter将对象转为json再写出去。


	1.2 响应xml格式数据:
	
		<dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
		</dependency>

原生组件注入:Servlet,Filter,Listener

	方案一:
		@WebServlet(urlPatterns = "/my")
		public class MyServlet extends HttpServlet {
		
		    @Override
		    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		        resp.getWriter().write("66666");
		    }
		}

		@Slf4j
		@WebFilter(urlPatterns={"/css/*","/images/*"}) //my
		public class MyFilter implements Filter {
		    @Override
		    public void init(FilterConfig filterConfig) throws ServletException {
		        log.info("MyFilter初始化完成");
		    }
		
		    @Override
		    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		        log.info("MyFilter工作");
		        chain.doFilter(request,response);
		    }
		
		    @Override
		    public void destroy() {
		        log.info("MyFilter销毁");
		    }
		}

		@Slf4j
		@WebListener
		public class MySwervletContextListener implements ServletContextListener {
		
		
		    @Override
		    public void contextInitialized(ServletContextEvent sce) {
		        log.info("MySwervletContextListener监听到项目初始化完成");
		    }
		
		    @Override
		    public void contextDestroyed(ServletContextEvent sce) {
		        log.info("MySwervletContextListener监听到项目销毁");
		    }
		}


		@MapperScan("com.atguigu.admin.mapper")
		@ServletComponentScan(basePackages = "com.atguigu.admin")//指定原生组件的位置
		@SpringBootApplication
		public class Boot05WebAdminApplication {
		
		    public static void main(String[] args) {
		        SpringApplication.run(Boot05WebAdminApplication.class, args);
		    }
		}

	方案二:
		public class MyServlet extends HttpServlet {
		
		    @Override
		    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		        resp.getWriter().write("66666");
		    }
		}

		@Slf4j
		public class MyFilter implements Filter {
		    @Override
		    public void init(FilterConfig filterConfig) throws ServletException {
		        log.info("MyFilter初始化完成");
		    }
		
		    @Override
		    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		        log.info("MyFilter工作");
		        chain.doFilter(request,response);
		    }
		
		    @Override
		    public void destroy() {
		        log.info("MyFilter销毁");
		    }
		}

		@Slf4j
		public class MySwervletContextListener implements ServletContextListener {
		
		
		    @Override
		    public void contextInitialized(ServletContextEvent sce) {
		        log.info("MySwervletContextListener监听到项目初始化完成");
		    }
		
		    @Override
		    public void contextDestroyed(ServletContextEvent sce) {
		        log.info("MySwervletContextListener监听到项目销毁");
		    }
		}
		
		/**
		 * 1、MyServlet --> /my
		 * 2、DispatcherServlet --> /
		 */
		// (proxyBeanMethods = true ：保证依赖的组件始终是单实例的)
		@Configuration(proxyBeanMethods = true)
		public class MyRegistConfig {
		
		    @Bean
		    public ServletRegistrationBean myServlet(){
		        MyServlet myServlet = new MyServlet();
		
		        return new ServletRegistrationBean(myServlet,"/my","/my02");
		    }
		
		
		    @Bean
		    public FilterRegistrationBean myFilter(){
		
		        MyFilter myFilter = new MyFilter();
		        //return new FilterRegistrationBean(myFilter,myServlet());//拦截Servlet拦截的路径
		        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(myFilter);
		        filterRegistrationBean.setUrlPatterns(Arrays.asList("/my","/css/*"));
		        return filterRegistrationBean;
		    }
		
		    @Bean
		    public ServletListenerRegistrationBean myListener(){
		        MySwervletContextListener mySwervletContextListener = new MySwervletContextListener();
		        return new ServletListenerRegistrationBean(mySwervletContextListener);
		    }
		}
		
		DispatchServlet 如何注册进来?  DispatcherServletAutoConfiguration.class
			 容器中自动配置了  DispatcherServlet  属性绑定到 WebMvcProperties;对应的配置文件配置项是 spring.mvc。
			通过 ServletRegistrationBean<DispatcherServlet> 把 DispatcherServlet  配置进来。
			默认映射的是 / 路径。
				
		Tomcat-Servlet：多个Servlet都能处理到同一层路径，精确url优选原则
		
		
Servlet容器:

	为什么SpringBoot启动就能够使用? 
		ServletWebServerFactoryAutoConfiguration.class
		ServletWebServerFactoryConfiguration.class
		
			SpringBoot应用启动发现当前是Web应用,web场景包--导入tomcat
			Web应用会创建一个Web版的IOC容器 ServletWebServerApplicationContext.
			ServletWebServerApplicationContext启动时寻找ServletWebServerFactory,利用ServletWebServerFactory
			产生Servlet容器。

	用户定制Servlet容器:
		implements  WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> 
  			把配置文件的值和ServletWebServerFactory 进行绑定
  				@Component
				public class CustomizationBean implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {
				
				    @Override
				    public void customize(ConfigurableServletWebServerFactory server) {
				        server.setPort(9000);
				    }
				}
		修改配置文件 server.xxx
		
		直接自定义 ConfigurableServletWebServerFactory 
		

定制化原理:

	原理流程:
		场景starter - xxxxAutoConfiguration   -  导入 xxx组件       -  绑定 xxxProperties 	- 	绑定配置文件项

	自定义替换:
		@Configuration + @Bean


数据库访问:	

	sql监控url：
		localhost:8080/druid/sql.html

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jdbc</artifactId>
        </dependency>
        
			        默认版本：<mysql.version>8.0.22</mysql.version>
			
			        <dependency>
			            <groupId>mysql</groupId>
			            <artifactId>mysql-connector-java</artifactId>
				<!--            <version>5.1.49</version>-->
			        </dependency>
			        
			想要修改版本
			1、直接依赖引入具体版本（maven的就近依赖原则）
			2、重新声明版本（maven的属性的就近优先原则）
			    <properties>
			        <java.version>1.8</java.version>
			        <mysql.version>5.1.49</mysql.version>
			    </properties>
			    
		● DataSourceAutoConfiguration ： 数据源的自动配置
			  ○ 修改数据源相关的配置：spring.datasource
			  ○ 数据库连接池的配置，是自己容器中没有DataSource才自动配置的
			  ○ 底层配置好的连接池是：HikariDataSource
        
        application.properties:
        
			spring:
			  datasource:
			    url: jdbc:mysql://localhost:3306/db_account
			    username: root
			    password: 123456
			    driver-class-name: com.mysql.jdbc.Driver
			    
			@Autowired
		    JdbcTemplate jdbcTemplate;
		
		
		    @Test
		    void contextLoads() {
		
		//        jdbcTemplate.queryForObject("select * from account_tbl")
		//        jdbcTemplate.queryForList("select * from account_tbl",)
		        Long aLong = jdbcTemplate.queryForObject("select count(*) from account_tbl", Long.class);
		        log.info("记录总数：{}",aLong);
		    }	
		    
		
	自定义整合Druid数据源:
		
		pom.xml:
		
			<dependency>
	            <groupId>com.alibaba</groupId>
	            <artifactId>druid</artifactId>
	            <version>1.1.17</version>
	        </dependency>
	        
	     
			application.properties:
			
				spring.datasource.url=jdbc:mysql://localhost:3306/ssm?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC&zeroDateTimeBehavior=convertToNull
				spring.datasource.username=root
				spring.datasource.driver-class-name=com.mysql.jdbc.Driver
				spring.datasource.password=123456
				spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
		
			@Configuration
			public class MyDataSourceConfig {
			
			    // 默认的自动配置是判断容器中没有才会配@ConditionalOnMissingBean(DataSource.class)
			    @ConfigurationProperties("spring.datasource")
			    @Bean
			    public DataSource dataSource() throws SQLException {
			        DruidDataSource druidDataSource = new DruidDataSource();
			        druidDataSource.setUrl();
			        druidDataSource.setUsername();
			        druidDataSource.setPassword();
			        //加入监控功能
			        druidDataSource.setFilters("stat,wall");
			        druidDataSource.setMaxActive(10);
			        return druidDataSource;
			    }
			
			    /**
			     * 配置 druid的监控页功能
			     * @return
			     */
			    @Bean
			    public ServletRegistrationBean statViewServlet(){
			        StatViewServlet statViewServlet = new StatViewServlet();
			        ServletRegistrationBean<StatViewServlet> registrationBean = new ServletRegistrationBean<>(statViewServlet, "/druid/*");
			        registrationBean.addInitParameter("loginUsername","admin");
			        registrationBean.addInitParameter("loginPassword","123456");
			        return registrationBean;
			    }
			
			    /**
			     * WebStatFilter 用于采集web-jdbc关联监控的数据。
			     */
			    @Bean
			    public FilterRegistrationBean webStatFilter(){
			        WebStatFilter webStatFilter = new WebStatFilter();
			        FilterRegistrationBean<WebStatFilter> filterRegistrationBean = new FilterRegistrationBean<>(webStatFilter);
			        filterRegistrationBean.setUrlPatterns(Arrays.asList("/*"));
			        filterRegistrationBean.addInitParameter("exclusions","*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*");
			        return filterRegistrationBean;
			    }
			}

	Druid数据源starter整合方式:
		
		pom.xml:
		
			<dependency>
	            <groupId>com.alibaba</groupId>
	            <artifactId>druid-spring-boot-starter</artifactId>
	            <version>1.1.17</version>
	        </dependency>
	        
	   原理:
	   
	   	DruidDataSourceAutoConfigure.class
	    DruidSpringAopConfiguration.class,   监控SpringBean的；配置项：spring.datasource.druid.aop-patterns
		DruidStatViewServletConfiguration.class, 监控页的配置：spring.datasource.druid.stat-view-servlet；默认开启
		DruidWebStatFilterConfiguration.class, web监控配置；spring.datasource.druid.web-stat-filter；默认开启
		DruidFilterConfiguration.class 所有Druid自己filter的配置

		application.properties:
		
				spring.datasource.url=jdbc:mysql://localhost:3306/ssm?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC&zeroDateTimeBehavior=convertToNull
				spring.datasource.username=root
				spring.datasource.driver-class-name=com.mysql.jdbc.Driver
				spring.datasource.password=123456
				spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
				# 初始化时建立物理连接的个数
			    spring.datasource.druid.initial-size=1
			    # 最小连接池数量
			    spring.datasource.druid.min-idle=1
			    # 最大连接池数量
			    spring.datasource.druid.max-active=8
			    # 获取连接时最大等待时间，单位毫秒
			    spring.datasource.druid.max-wait=3000
			    # 间隔多久检测需要关闭的空闲连接
			    spring.datasource.druid.time-between-eviction-runs-millis=10000
			    # 连接保持空闲而不被驱逐的最小时间
			    spring.datasource.druid.min-evictable-idle-time-millis=5000
			    # 用来检测连接是否有效的sql
			    spring.datasource.druid.validation-query=select 1
			    # 检测连接是否有效的超时时间
			    spring.datasource.druid.validation-query-timeout=3000
			    spring.datasource.druid.test-while-idle=true
			    spring.datasource.druid.test-on-borrow=false
			    spring.datasource.druid.test-on-return=false
			    
			  #3. 旧版本的Druid监控配置
			  
				    # 监控配置 启用相应的内置Filter，多个以逗号分隔
					spring.datasource.druid.filters=stat, wall
					
					# 配置StatFilter
					spring.datasource.druid.filter.stat.db-type=mysql
					spring.datasource.druid.filter.stat.log-slow-sql=true
					spring.datasource.druid.filter.stat.slow-sql-millis=1000
					
					# 配置WallFilter
					spring.datasource.druid.filter.wall.enabled=true
					
		application.yml
			
			spring:
			  datasource:
			    url: jdbc:mysql://localhost:3306/db_account
			    username: root
			    password: 123456
			    driver-class-name: com.mysql.jdbc.Driver
			
			
			    druid:
			      aop-patterns: com.atguigu.admin.*  #springbean监控
			      filters: stat,wall,slf4j  #所有开启的功能
			
			      stat-view-servlet:  #监控页配置
			        enabled: true
			        login-username: admin
			        login-password: admin
			        resetEnable: false
			
			      web-stat-filter:  #web监控
			        enabled: true
			        urlPattern: /*
			        exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*'
			
			
			      filter:
			        stat: #sql监控
			          slow-sql-millis: 1000
			          logSlowSql: true
			          enabled: true
			        wall: #防火墙
			          enabled: true
			          config:
			            drop-table-allow: false
            
        
        整合Mybatis启动器starter:  
          
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.1.4</version>
        </dependency>
        
       整合Mybatis-plus的启动器starter:
       
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.1.0</version>
        </dependency>
        
        Mapper接口:
        
        	public interface UserMapper extends BaseMapper<User> {

			}
			
			
		自动配置原理:
			MybatisPlusAutoConfiguration.class
			MybatisPlusProperties.class


Filter,Interceptor
	Filter:是Servlet定义的原生组件
	Interceptor:Spring定义的接口

    整合Redis的启动器starter:
    
	    	application.yml:
	    	
	    		spring:
				  redis:
				      host: r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com
				      port: 6379
				      password: lfy:Lfy123456
				      client-type: jedis
				      jedis:
				        pool:
				          max-active: 10
			          
			<dependency>
	            <groupId>org.springframework.boot</groupId>
	            <artifactId>spring-boot-starter-data-redis</artifactId>
	        </dependency>
		
		
			自动配置原理:
				RedisAutoConfiguration.class
				RedisProperties.class
		
			自定义Redis配置:
			
				application.properties:
				
					spring.redis.pool.max-idle=10
					spring.redis.pool.min-idle=5
					spring.redis.pool.max-total=20
					spring.redis.hostName=192.168.70.128
					spring.redis.port=6379
			
				/**
				 * 完成对Redis的整合的一些配置
				 *
				 *
				 */
				@Configuration
				public class RedisConfig {
				
					/**
					 * 1.创建JedisPoolConfig对象。在该对象中完成一些链接池配置
					 * @ConfigurationProperties:会将前缀相同的内容创建一个实体。
					 */
					@Bean
					@ConfigurationProperties(prefix="spring.redis.pool")
					public JedisPoolConfig jedisPoolConfig(){
						JedisPoolConfig config = new JedisPoolConfig();
						return config;
					}
					
					/**
					 * 2.创建JedisConnectionFactory：配置redis链接信息
					 */
					@Bean
					@ConfigurationProperties(prefix="spring.redis")
					public JedisConnectionFactory jedisConnectionFactory(JedisPoolConfig config){
						JedisConnectionFactory factory = new JedisConnectionFactory();
						//关联链接池的配置对象
						factory.setPoolConfig(config);
						return factory;
					}
					
					/**
					 * 3.创建RedisTemplate:用于执行Redis操作的方法
					 */
					@Bean
					public RedisTemplate<String,Object> redisTemplate(JedisConnectionFactory factory){
						
						RedisTemplate<String, Object> template = new RedisTemplate<>();
						
						//关联
						template.setConnectionFactory(factory);
						
						//为key设置序列化器
						template.setKeySerializer(new StringRedisSerializer());
						
						//为value设置序列化器
						template.setValueSerializer(new StringRedisSerializer());
						
						return template;
					}
				}
				
			存取JAVA对象:
			
				/**
				 * 添加Users对象
				 */
				@Test
				public void testSetUesrs(){
					Users users = new Users();
					users.setAge(20);
					users.setName("张三丰");
					users.setId(1);
					//重新设置序列化器
					this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer());
					this.redisTemplate.opsForValue().set("users", users);
				}
				
				/**
				 * 取Users对象
				 */
				@Test
				public void testGetUsers(){
					//重新设置序列化器
					this.redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer());
					Users users = (Users)this.redisTemplate.opsForValue().get("users");
					System.out.println(users);
				}
				
			基于JSON格式存取JAVA对象:
			
					/**
					 * 基于JSON格式存Users对象
					 */
					@Test
					public void testSetUsersUseJSON(){
						Users users = new Users();
						users.setAge(20);
						users.setName("李四丰");
						users.setId(1);
						this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer<>(Users.class));
						this.redisTemplate.opsForValue().set("users_json", users);
					}
					
					/**
					 * 基于JSON格式取Users对象
					 */
					@Test
					public void testGetUseJSON(){
						this.redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer<>(Users.class));
						Users users = (Users)this.redisTemplate.opsForValue().get("users_json");
						System.out.println(users);
					}
					
				
 	整合Redis的启动器starter和Redis:
		
		<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>

		<!-- 导入jedis-->
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
        </dependency
        
			@Component
			public class RedisUrlCountInterceptor implements HandlerInterceptor {
			
			    @Autowired
			    StringRedisTemplate redisTemplate;
			
			
			    @Override
			    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
			        String uri = request.getRequestURI();
			
			        //默认每次访问当前uri就会计数+1
			        redisTemplate.opsForValue().increment(uri);
			
			        return true;
			    }
			}
       
SpringBoot指标监控: jconsole查看监控端口
	SpringBoot Actuator
	
		<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

		访问 http://localhost:8080/actuator/**
		
		# management 是所有actuator的配置
		# management.endpoint.端点名.xxxx  对某个端点的具体配置
		
		management:
		  endpoints:
		    enabled-by-default: false  #默认开启所有监控端点  true
		    web:
		      exposure:
		        include: '*' # 以web方式暴露所有端点
		
		  endpoint:   #对某个端点的具体配置
		    health:
		      show-details: always
		      enabled: true
		
		    info:
		      enabled: true
		
		    beans:
		      enabled: true
		
		    metrics:
		      enabled: true
		      
		   
	指标监控   定制Endpoint
	
		定制Health信息:
		
			@Component
			public class MyComHealthIndicator extends AbstractHealthIndicator {
			
			    /**
			     * 真实的检查方法
			     * @param builder
			     * @throws Exception
			     */
			    @Override
			    protected void doHealthCheck(Health.Builder builder) throws Exception {
			        //mongodb。  获取连接进行测试
			        Map<String,Object> map = new HashMap<>();
			        // 检查完成
			        if(1 == 1){
			//            builder.up(); //健康
			            builder.status(Status.UP);
			            map.put("count",1);
			            map.put("ms",100);
			        }else {
			//            builder.down();
			            builder.status(Status.OUT_OF_SERVICE);
			            map.put("err","连接超时");
			            map.put("ms",3000);
			        }
			
			
			        builder.withDetail("code",100)
			                .withDetails(map);
			
			    }
			}
		      
	  2、定制info信息
	  
		      方式一:
		      application.yml
		      
		      	info:
				  appName: boot-admin
				  version: 2.0.1
				  mavenProjectName: @project.artifactId@  #使用@@可以获取maven的pom文件值
				  mavenProjectVersion: @project.version@
				  
		  方式二:
		  
			@Component
			public class ExampleInfoContributor implements InfoContributor {
			
			    @Override
			    public void contribute(Info.Builder builder) {
			        builder.withDetail("example",
			                Collections.singletonMap("key", "value"));
			    }
			}
			
		定制Metrics信息:
		
			import io.micrometer.core.instrument.Counter;
			import io.micrometer.core.instrument.MeterRegistry
			
			@Service
			public class CityServiceImpl implements CityService {
			
			    @Autowired
			    CityMapper cityMapper;
			
			    Counter counter;
			
			    public CityServiceImpl(MeterRegistry meterRegistry){
			        counter = meterRegistry.counter("cityService.saveCity.count");
			    }
			
			
			    public City getById(Long id){
			        return cityMapper.getById(id);
			    }
			
			    public void saveCity(City city) {
			        counter.increment();
			        cityMapper.insert(city);
			
			    }
			}
		
		定制EndPoint：
		
			@Component
			@Endpoint(id = "myservice")
			public class MyServiceEndPoint {
			
			
			    @ReadOperation
			    public Map getDockerInfo(){
			        //端点的读操作  http://localhost:8080/actuator/myservice
			        return Collections.singletonMap("dockerInfo","docker started.....");
			    }
			
			    @WriteOperation
			    public void stopDocker(){
			        System.out.println("docker stopped.....");
			    }
			}
			
		SpringBoot AdminServer应用:
		
			Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。 应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册（通过HTTP）或使用SpringCloud注册中心（例如Eureka，Consul）发现。 UI是的Vue.js应用程序，展示Spring Boot Admin Client的Actuator端点上的一些监控。
			服务端采用Spring WebFlux + Netty的方式。Spring Boot Admin为注册的应用程序提供以下功能：
				显示健康状况
				显示详细信息，例如
				JVM和内存指标
				http://micrometer.io指标
				数据源指标
				缓存指标
				显示构建信息编号
				关注并下载日志文件
				查看jvm system-和environment-properties
				查看Spring Boot配置属性
				支持Spring Cloud的postable / env-和/ refresh-endpoint
				轻松的日志级管理
				与JMX-beans交互
				查看线程转储
				查看http-traces
				查看auditevents
				查看http-endpoints
				查看计划任务
				查看和删除活动会话（使用spring-session）
				查看Flyway / Liquibase数据库迁移
				下载heapdump
				状态变更通知（通过电子邮件，Slack，Hipchat，......）
				状态更改的事件日志（非持久性）
				
			pom.xml:
			
				<properties>
			        <java.version>1.8</java.version>
			    </properties>
			
			    <dependencies>
			        <dependency>
			            <groupId>org.springframework.boot</groupId>
			            <artifactId>spring-boot-starter-web</artifactId>
			        </dependency>
			
			        <dependency>
			            <groupId>org.springframework.boot</groupId>
			            <artifactId>spring-boot-starter-test</artifactId>
			            <scope>test</scope>
			        </dependency>
			
			        <dependency>
			            <groupId>de.codecentric</groupId>
			            <artifactId>spring-boot-admin-starter-server</artifactId>
			            <version>2.3.1</version>
			        </dependency>
			    </dependencies>
			
			    <build>
			        <plugins>
			            <plugin>
			                <groupId>org.springframework.boot</groupId>
			                <artifactId>spring-boot-maven-plugin</artifactId>
			            </plugin>
			        </plugins>
			    </build>
		
				@EnableAdminServer
				@SpringBootApplication
				public class Boot05AdminserverApplication {
				
				    public static void main(String[] args) {
				        SpringApplication.run(Boot05AdminserverApplication.class, args);
				    }
				}
				
				application.properties：
					server.port=8888
			
			其他应用:
				
				application.yml：
				
					  boot:
					    admin:
					      client:
					        url: http://localhost:8888
					        instance:
					          prefer-ip: true  #使用ip注册进来
					  application:
					    name: boot-05-web-admin
					  # management 是所有actuator的配置
					  # management.endpoint.端点名.xxxx  对某个端点的具体配置
						management:
						  endpoints:
						    enabled-by-default: true  #默认开启所有监控端点  true
						    web:
						      exposure:
						        include: '*' # 以web方式暴露所有端点
					    
				pom.xml:
					   
					   <dependency>
				            <groupId>de.codecentric</groupId>
				            <artifactId>spring-boot-admin-starter-client</artifactId>
				            <version>2.3.1</version>
				        </dependency>
				        <!--        引入监控功能-->
				        <dependency>
				            <groupId>org.springframework.boot</groupId>
				            <artifactId>spring-boot-starter-actuator</artifactId>
				        </dependency>
		
	Profile功能:
			application.properties
				spring.profiles.active=prod #指定激活的环境
				
		
			application-dev.properties
			application-prod.properties
			application-test.properties
			
			命令行激活配置文件:
				  命令行激活：java -jar xxx.jar --spring.profiles.active=prod  --person.name=haha
	
		
			@Profile("test")
			
			@Value("${os.name}")
			private String osName;
			
			
			配置文件查找位置:
				(1):classpath根路径
				(2):classpath根路径下config目录
				(3):jar包当前目录
				(4):jar包当前目录的config目录
				(5):/config子目录的直接子目录
				
				
			3、配置文件加载顺序：
				1. 　当前jar包内部的application.properties和application.yml
				2. 　当前jar包内部的application-{profile}.properties 和 application-{profile}.yml
				3. 　引用的外部jar包的application.properties和application.yml
				4. 　引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml
				
		自定义starter:
		
			(1)自定义starter项目依赖 AutoConfiguration项目
			
			(2)AutoConfiguration项目依赖:
				(1)pom.xml依赖:
					  <dependency>
				        <groupId>org.springframework.boot</groupId>
				        <artifactId>spring-boot-starter</artifactId>
				        <version>2.5.13</version>
				      </dependency>
				(2)自定义AutoConfiguration组件
				(3)在resources下创建META-INF/spring.factories配置AutoConfiguration组件
		
		
		SpringBoot启动过程
		
			● 创建 SpringApplication
			
			  ○ 保存一些信息。
			  
			  ○ 判定当前应用的类型。ClassUtils。Servlet
			  
			  ○ bootstrappers：初始启动引导器（List<Bootstrapper>）：去spring.factories文件中找 org.springframework.boot.Bootstrapper
			  
			  ○ 找 ApplicationContextInitializer；去spring.factories找 ApplicationContextInitializer
			    	■ List<ApplicationContextInitializer<?>> initializers
			    	
			  ○ 找 ApplicationListener  ；应用监听器。去spring.factories找 ApplicationListener
			    	■ List<ApplicationListener<?>> listeners
			    
			● 运行 SpringApplication
			
			  ○ StopWatch
			  
			  ○ 记录应用的启动时间
			  
			  ○ 创建引导上下文（Context环境）createBootstrapContext()
			    	■ 获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置
			    	
			  ○ 让当前应用进入headless模式。java.awt.headless
			  
			  ○ 获取所有 RunListener（运行监听器）【为了方便所有Listener进行事件感知】
			    	■ getSpringFactoriesInstances 去spring.factories找 SpringApplicationRunListener. 
			    
			  ○ 遍历 SpringApplicationRunListener 调用 starting 方法；
			    	■ 相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。
			    	
			  ○ 保存命令行参数；ApplicationArguments
			  
			  ○ 准备环境 prepareEnvironment（）;
			    	■ 返回或者创建基础环境信息对象。StandardServletEnvironment
			    	■ 配置环境信息对象。
			      		● 读取所有的配置源的配置属性值。
			    	■ 绑定环境信息
			    	■ 监听器调用 listener.environmentPrepared()；通知所有的监听器当前环境准备完成
			    	
			  ○ 创建IOC容器（createApplicationContext（））
			    	■ 根据项目类型（Servlet）创建容器，
			    	■ 当前会创建 AnnotationConfigServletWebServerApplicationContext
			    	
			  ○ 准备ApplicationContext IOC容器的基本信息   prepareContext()
			    	■ 保存环境信息
			    	■ IOC容器的后置处理流程。
			    	■ 应用初始化器；applyInitializers；
			      		● 遍历所有的 ApplicationContextInitializer 。调用 initialize.。来对ioc容器进行初始化扩展功能
			      		● 遍历所有的 listener 调用 contextPrepared。EventPublishRunListenr；通知所有的监听器contextPrepared
			    	■ 所有的监听器 调用 contextLoaded。通知所有的监听器 contextLoaded；
			    	
			  ○ 刷新IOC容器。refreshContext
			    	■ 创建容器中的所有组件（Spring注解）
			    	
			  ○ 容器刷新完成后工作？afterRefresh
			  
			  ○ 所有监听 器 调用 listeners.started(context); 通知所有的监听器 started
			  
			  ○ 调用所有runners；callRunners()
			    	■ 获取容器中的 ApplicationRunner 
			    	■ 获取容器中的  CommandLineRunner
			    	■ 合并所有runner并且按照@Order进行排序
			    	■ 遍历所有的runner。调用 run 方法
			    	
			  ○ 如果以上有异常，
			    	■ 调用Listener 的 failed
			    	
			  ○ 调用所有监听器的 running 方法  listeners.running(context); 通知所有的监听器 running
			   
			  ○ running如果有问题。继续通知 failed 。调用所有 Listener 的 failed；通知所有的监听器 failed
			  
		
	Application Events and Listeners:
		
		自定义：
		
			ApplicationContextInitializer:
			
				public class MyApplicationContextInitializer implements ApplicationContextInitializer {
				    @Override
				    public void initialize(ConfigurableApplicationContext applicationContext) {
				        System.out.println("MyApplicationContextInitializer ....initialize.... ");
				    }
				}
				
			ApplicationListener:
			
				public class MyApplicationListener implements ApplicationListener {
				    @Override
				    public void onApplicationEvent(ApplicationEvent event) {
				        System.out.println("MyApplicationListener.....onApplicationEvent...");
				    }
				}
				
			SpringApplicationRunListener:
			
				public class MySpringApplicationRunListener implements SpringApplicationRunListener {
	
				    private SpringApplication application;
				    public MySpringApplicationRunListener(SpringApplication application, String[] args){
				        this.application = application;
				    }
				
				    @Override
				    public void starting(ConfigurableBootstrapContext bootstrapContext) {
				        System.out.println("MySpringApplicationRunListener....starting....");
				
				    }
				
				
				    @Override
				    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) {
				        System.out.println("MySpringApplicationRunListener....environmentPrepared....");
				    }
				
				
				    @Override
				    public void contextPrepared(ConfigurableApplicationContext context) {
				        System.out.println("MySpringApplicationRunListener....contextPrepared....");
				
				    }
				
				    @Override
				    public void contextLoaded(ConfigurableApplicationContext context) {
				        System.out.println("MySpringApplicationRunListener....contextLoaded....");
				    }
				
				    @Override
				    public void started(ConfigurableApplicationContext context) {
				        System.out.println("MySpringApplicationRunListener....started....");
				    }
				
				    @Override
				    public void running(ConfigurableApplicationContext context) {
				        System.out.println("MySpringApplicationRunListener....running....");
				    }
				
				    @Override
				    public void failed(ConfigurableApplicationContext context, Throwable exception) {
				        System.out.println("MySpringApplicationRunListener....failed....");
				    }
				}
				
			ApplicationRunner:
			
				@Order(1)
				@Component
				public class MyApplicationRunner implements ApplicationRunner {
				    @Override
				    public void run(ApplicationArguments args) throws Exception {
				        System.out.println("MyApplicationRunner...run...");
				    }
				}
				
			CommandLineRunner:	
			  
				/**
				 * 应用启动做一个一次性事情
				 */
				@Order(2)
				@Component
				public class MyCommandLineRunner implements CommandLineRunner {
				    @Override
				    public void run(String... args) throws Exception {
				        System.out.println("MyCommandLineRunner....run....");
				    }
				}
				
		在resources下创建META-INF/spring.factories配置:
		
				org.springframework.context.ApplicationContextInitializer=\
			  		com.atguigu.boot.listener.MyApplicationContextInitializer
			
				org.springframework.context.ApplicationListener=\
				  com.atguigu.boot.listener.MyApplicationListener
				
				org.springframework.boot.SpringApplicationRunListener=\
				  com.atguigu.boot.listener.MySpringApplicationRunListener
		
	SpringBoot后端校验:
	
		pom.xml:
		
			<dependency>
				<groupId>org.hibernate</groupId>
				<artifactId>hibernate-validator</artifactId>
				<version>5.4.2.Final</version>
			</dependency>	
			
		实体类:
			
			import org.hibernate.validator.constraints.NotBlank;
			import lombok.AllArgsConstructor;
			import lombok.Data;
			import lombok.NoArgsConstructor;
			import lombok.ToString;
			
			@Data
			@AllArgsConstructor
			@NoArgsConstructor
			@ToString
			public class User {
				@NotBlank(message="不能为空")
				private Integer userId;
				@NotBlank(message="不能为空")
				private Integer userage;
				@NotBlank
				private String username;
			}
						
			import javax.validation.Valid;
			import org.springframework.stereotype.Controller;
			import org.springframework.validation.BindingResult;
			import org.springframework.web.bind.annotation.ModelAttribute;
			import org.springframework.web.bind.annotation.RequestMapping;
			import com.bjsxt.pojo.Users;
			
			/**
			 * SpringBoot 表单数据校验
			 *
			 *
			 */
			@Controller
			public class UsersController {
				/**
				 * 
				 * 如果想为传递的对象更改名称，可以使用@ModelAttribute("aa")这表示当前传递的对象的key为aa。
				 * 那么我们在页面中获取该对象的key也需要修改为aa
				 * @param users
				 * @return
				 */
				@RequestMapping("/addUser")
				public String showPage(@ModelAttribute("aa") Users users){
					return "add";
				}
				
				/**
				 * 完成用户添加
				 *@Valid 开启对Users对象的数据校验
				 *BindingResult:封装了校验的结果
				 */
				@RequestMapping("/save")
				public String saveUser(@ModelAttribute("aa") @Valid Users users,BindingResult result){
					if(result.hasErrors()){
						return "add";
					}
					System.out.println(users);
					return "ok";
				}
			}
			
			回显验证信息:
			
				用户姓名：<input type="text" name="name"/><font color="red" th:errors="${aa.name}"></font><br/>
			
	SpringBoot热部署:
			<!-- DevTools的坐标 -->
		    <dependency>
		        <groupId>org.springframework.boot</groupId>
		        <artifactId>spring-boot-devtools</artifactId>
		        <optional>true</optional><!-- 依赖不能够继承 -->
		    </dependency>
	SpringBoot AOP:
		pom.xml:
			<dependency>
			    <groupId>org.springframework.boot</groupId>
			    <artifactId>spring-boot-starter-aop</artifactId>
			</dependency>
			
			@Target(ElementType.METHOD) #定义注解的使用范围为方法
			@Retention(RetentionPolicy.RUNTIME)
			public @interface SaveHotKey{
			
			}
			
			@Component
			@Aspect
			public class OperateLogAspect {
			    private final Logger logger = LoggerFactory.getLogger(this.getClass());
			
			    @Pointcut("@annotation(com.xxx.aop.SaveHotKey)&&execution(* com.cff.springbootwork.aspectj.service.BusinessService.*(..)) && !execution(* com.cff.springbootwork.aspectj.service.BusinessService.getTest*(..)) ")
			    private void log() {
			    }
			
			    @Before("log()")
			    public void beforeMethod(JoinPoint joinPoint) {
			        String methodName = joinPoint.getSignature().getName();
			        joinPoint.getArgs();
			        logger.info("方法为:" + methodName + ", 这是一个前置测试 ");
			    }
			
			    @After("execution(* com.cff.springbootwork.aspectj.service.BusinessService.*(..))")
			    public void afterMethod(JoinPoint joinPoint) {
			        String methodName = joinPoint.getSignature().getName();
			        logger.info("方法为:" + methodName + ", 这是一个后置测试 ");
			    }
			
			    @Around("execution(* com.cff.springbootwork.aspectj.service.BusinessService.getTestInfo(..))")
			    public void test(JoinPoint joinPoint) {
			        String methodName = joinPoint.getSignature().getName();
			        logger.info("方法为:" + methodName + ", 测水水水水水水水水水水 ");
			    }
			
			    @AfterReturning(value = "log()", returning = "result")
			    public void afterReturning(JoinPoint point, Object result) {
			        String methodName = point.getSignature().getName();
			        logger.info("方法为：" + methodName + "，目标方法执行结果为：" + result);
			    }
			
			    @Around("log()")
			    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
			        logger.info("请求参数：{}", joinPoint.getArgs());
			        Object[] arr = joinPoint.getArgs();
			        Integer type = (Integer) arr[1];
			        logger.info("请求类型：{}", type);
			        long startTime = System.currentTimeMillis();
			        Object obj = joinPoint.proceed();
			        long timeTaken = System.currentTimeMillis() - startTime;
			        logger.info("执行时间：{}", timeTaken);
			        return obj;
			    }
			}
			
	SpringBoot Transactional
			
			pom.xml
				<dependency>
				   <groupId>org.springframework.boot</groupId>
				   <artifactId>spring-boot-starter-jdbc</artifactId>
				   <scope>test</scope>
				</dependency>
			
			@SpringBootApplication
			//启用事务管理（可省略）
			@EnableTransactionManagement
			@MapperScan("mapper路径")
			public class KxlApplication {
			    public static void main(String[] args) {
			        SpringApplication.run(KxlApplication.class, args);
			    }
			}
			
			@Service
			public class PersonService {
			    @Resource
			    private PersonMapper personMapper;
			
			    @Resource
			    private CompanyMapper companyMapper;
			
			    @Transactional(rollbackFor = {RuntimeException.class, Error.class})
			    public void saveOne(Person person) {
			        Company company = new Company();
			        company.setName("tenmao:" + person.getName());
			        companyMapper.insertOne(company);
			        personMapper.insertOne(person);
			    }
			}
			
	SpringBoot Cache:
		
		运行原理:
		
			CacheAutoConfiguration.class
			CacheAspectSupport.class
		
		Cache:
		
			java cache：JSR107
			
				Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。
					
					* CachingProvider：定义了创建、配置、获取、管理和控制多个CacheManager。
						一个应用可以在运行期访问多个CachingProvider。
					
					* CacheManager：定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。
						一个CacheManager仅被一个CachingProvider所拥有。
					
					* Cache：是一个类似Map的数据结构并临时存储以Key为索引的值。
						一个Cache仅被一个CacheManager所拥有。
					
					* Entry：是一个存储在Cache中的key-value对。
					
					* Expiry：每一个存储在Cache中的条目有一个定义的有效期，即Expiry Duration。
						一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。
			
			Cache  SpEL:
				@Cacheable(cacheNames = {"emp"}, key = "#id", condition = "#a0>1")
				@CachePut(cacheNames = {"emp"}, key = "#result.id")
				@CacheEvict(value = "emp", key = "#id")
				@CacheEvict(value="users",allEntries=true) //删除缓存 users中所有数据
				
					#root.methodName		当前被调用的方法名
				
					#root.method.name		当前被调用的方法
					
					#root.target			当前被调用的目标对象
					
					#root.targetClass		当前被调用的目标对象类
					
					#root.args[0]			当前被调用的方法的参数列表
					
					#root.caches[0].name	当前方法调用使用的缓存列表
					
					#result					方法执行后的返回值
				
			@Cacheable:
				主要针对方法配置,能够根据方法的请求参数对其结果进行缓存
				
			@CacheEvict:
				清空缓存
				
			@CachePut
				保证方法被调用,又希望结果被缓存
				
			@Cacheable和@CachePut的key:
				@Cacheable中key：先放入缓存中再进行查询
				@CachePut中的key:先修改再进行缓存	
				
				    /**
				     * 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法；
				     * CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字；
				     *
				     * @param id
				     * @return
				     */
				    //key = "#id+#root.methodName+#root.caches[0].name",
				    //@Cacheable(cacheNames = {"emp"}, keyGenerator = "myKeyGenerator", condition = "#a0>1")
				    @Cacheable(cacheNames = {"emp"}, key = "#id", condition = "#a0>1")
				    public Employee getEmp(Integer id) {
				        System.out.println("查询" + id + "号员工");
				        Employee emp = employeeMapper.getEmpById(id);
				        return emp;
				    }
				 
				    //更新的key和缓存中的key要相同
				    @CachePut(cacheNames = {"emp"}, key = "#result.id")
				    public Employee updateEmp(Employee employee) {
				        System.out.println("updateEmp:" + employee);
				        employeeMapper.updateEmp(employee);
				        return employee;
				    }
				 
				    @CacheEvict(value = "emp", key = "#id"/*beforeInvocation = true*/)
				    public void deleteEmp(Integer id) {
				        System.out.println("deleteEmp:" + id);
				        employeeMapper.deleteEmpById(id);
				        //int i = 10/0;
				    }
				 
				    // @Caching 定义复杂的缓存规则
				    @Caching(
				            // 定义了三个缓存规则，进行缓存了三次：分别根据lastName、返回结果id、返回结果email为key进行缓存
				            cacheable = {
				                    @Cacheable(value = "emp", key = "#lastName")
				            },
				            put = {
				                    @CachePut(value = "emp", key = "#result.id"),
				                    @CachePut(value = "emp", key = "#result.email")
				            }
				    )
				    public Employee getEmpByLastName(String lastName) {
				        return employeeMapper.getEmpByLastName(lastName);
				    }
				    
				    
				
			@EnableCaching
				开启基于注解的缓存
				
				@MapperScan("cn.kt.springboot_cache.mapper")
				@EnableCaching
				@SpringBootApplication
				public class SpringbootCacheApplication {
				 
				    public static void main(String[] args) {
				        SpringApplication.run(SpringbootCacheApplication.class, args);
				    }
				}
				
				
			KeyGenerator:
				缓存数据时key生成策略
				
				 @Bean("myKeyGenerator")
			    public KeyGenerator keyGenerator() {
			        return new KeyGenerator() {
			 
			            @Override
			            public Object generate(Object target, Method method, Object... params) {
			                return method.getName() + "[" + Arrays.asList(params).toString() + "]";
			            }
			        };
			    }
				
				使用KeyGenerator:
					@Cacheable(cacheNames = {"emp"}, keyGenerator = "myKeyGenerator", condition = "#a0>1")
					@CacheConfig(cacheNames="emp",keyGenerator = "myKeyGenerator",cacheManager="" ) 缓存的公共注解
			serialize:
				缓存数据时value序列化策略
				
				
		整合redis注解缓存并设置时间:
		
			方案一:
		
					通过全部配置RedisCacheManager，再查询时进行过滤判断，
					在缓存存入Redis时进行过期时间的配置。
					这种形式使用是将 cacheName后加#可以区分时间
						
						import java.time.Duration;
						import java.util.Map;
						
						import org.apache.commons.lang3.StringUtils;
						import org.springframework.data.redis.cache.CacheKeyPrefix;
						import org.springframework.data.redis.cache.RedisCache;
						import org.springframework.data.redis.cache.RedisCacheConfiguration;
						import org.springframework.data.redis.cache.RedisCacheManager;
						import org.springframework.data.redis.cache.RedisCacheWriter;
						import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
						import org.springframework.data.redis.serializer.RedisSerializationContext;
						
						public class RedisConfigCacheManager extends RedisCacheManager {
						
							public RedisConfigCacheManager(RedisCacheWriter cacheWriter, RedisCacheConfiguration defaultCacheConfiguration) {
								super(cacheWriter, defaultCacheConfiguration);
								// TODO Auto-generated constructor stub
							}
						
							
						    public RedisConfigCacheManager(RedisCacheWriter cacheWriter, RedisCacheConfiguration defaultCacheConfiguration, String... initialCacheNames) {
						        super(cacheWriter, defaultCacheConfiguration, initialCacheNames);
						    }
						 
						    public RedisConfigCacheManager(RedisCacheWriter cacheWriter, RedisCacheConfiguration defaultCacheConfiguration, boolean allowInFlightCacheCreation, String... initialCacheNames) {
						        super(cacheWriter, defaultCacheConfiguration, allowInFlightCacheCreation, initialCacheNames);
						    }
						 
						    public RedisConfigCacheManager(RedisCacheWriter cacheWriter, RedisCacheConfiguration defaultCacheConfiguration, Map<String, RedisCacheConfiguration> initialCacheConfigurations) {
						        super(cacheWriter, defaultCacheConfiguration, initialCacheConfigurations);
						    }
						 
						    public RedisConfigCacheManager(RedisCacheWriter cacheWriter, RedisCacheConfiguration defaultCacheConfiguration, Map<String, RedisCacheConfiguration> initialCacheConfigurations, boolean allowInFlightCacheCreation) {
						        super(cacheWriter, defaultCacheConfiguration, initialCacheConfigurations, allowInFlightCacheCreation);
						    }
						    
						    private static final RedisSerializationContext.SerializationPair<Object> DEFAULT_PAIR = RedisSerializationContext.SerializationPair
						            .fromSerializer(new GenericJackson2JsonRedisSerializer());
						 
						    private static final CacheKeyPrefix DEFAULT_CACHE_KEY_PREFIX = cacheName -> cacheName + ":";
						    
						    /**
						     * 自定义缓存时间设置
						     * 使用：
						     * 	@Cacheable(cacheNames = {"emp#500"}, key = "#id", condition = "#a0>1")
						     */
						    @Override
						    protected RedisCache createRedisCache(String name, RedisCacheConfiguration cacheConfig) {
						    	
						    	final int lastIndexOf = StringUtils.lastIndexOf(name, '#');
						        
						    	System.out.println("lastIndexOf——" + lastIndexOf);
						    	
						        if (lastIndexOf > -1) {
						        
						            final String ttl = StringUtils.substring(name, lastIndexOf + 1);
						            
						            final Duration duration = Duration.ofSeconds(Long.parseLong(ttl));
						            
						            cacheConfig = cacheConfig.entryTtl(duration);
						            
						            //修改缓存key和value值的序列化方式
						            cacheConfig = cacheConfig.computePrefixWith(DEFAULT_CACHE_KEY_PREFIX)
						                    .serializeValuesWith(DEFAULT_PAIR);
						                    
						            final String cacheName = StringUtils.substring(name, 0, lastIndexOf);
						            
						            return super.createRedisCache(cacheName, cacheConfig);
						        } else {
						        
						            final Duration duration = Duration.ofSeconds(-1);
						            
						            cacheConfig = cacheConfig.entryTtl(duration);
						            
						            //修改缓存key和value值的序列化方式
						            cacheConfig = cacheConfig.computePrefixWith(DEFAULT_CACHE_KEY_PREFIX)
						                    .serializeValuesWith(DEFAULT_PAIR);
						                    
						            final String cacheName = StringUtils.substring(name, 0);
						            
						            return super.createRedisCache(cacheName, cacheConfig);
						            
						        }
						    }
						}
						
						
						@Configuration
						public class MyCacheConfig {
							
							/*redis配置类*/
						    @Bean
						    @Primary
						    public RedisCacheManager redisCacheManager(RedisConnectionFactory factory) {
						    
							        ObjectMapper om = new ObjectMapper();
							        
							        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
							        
							        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(
							                Object.class);
							                
							        // 解决查询缓存转换异常的问题
							        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
							        
							        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
							        
							        jackson2JsonRedisSerializer.setObjectMapper(om);
							        
							        // 配置序列化（解决乱码的问题）
							        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
							                .entryTtl(Duration.ofMillis(-1))
							                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))
							                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))
							                .disableCachingNullValues();
							                
							        RedisCacheWriter cacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(factory);
							 
							        /*return RedisConfigCacheManager.builder(factory)
							//                .withInitialCacheConfigurations()
							                .transactionAware()
							                .build();*/
							        
							        return new RedisConfigCacheManager(cacheWriter, config);
							}
						}
		
						使用：
						
							在cacheNames 缓存名后面加上 ”#过期时间“
							@Cacheable(cacheNames = {"emp#500"}, key = "#id", condition = "#a0>1",unless="#result==null")
				
			方案二:
			
				import com.fasterxml.jackson.annotation.JsonAutoDetect;
				import com.fasterxml.jackson.annotation.PropertyAccessor;
				import com.fasterxml.jackson.databind.ObjectMapper;
				import org.springframework.boot.autoconfigure.AutoConfigureAfter;
				import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
				import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;
				import org.springframework.context.annotation.Bean;
				import org.springframework.context.annotation.Configuration;
				import org.springframework.data.redis.cache.RedisCacheConfiguration;
				import org.springframework.data.redis.cache.RedisCacheManager;
				import org.springframework.data.redis.connection.RedisConnectionFactory;
				import org.springframework.data.redis.core.RedisTemplate;
				import org.springframework.data.redis.core.StringRedisTemplate;
				import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
				
				import java.time.Duration;
				
				@Configuration
				@AutoConfigureAfter(RedisAutoConfiguration.class)
				public class RedisConfig {
				
				    // https://www.ibm.com/developerworks/cn/java/know-redis-and-use-it-in-springboot-projects/index.html
				    @Bean
				    public RedisCacheConfiguration cacheConfiguration() {
				        return RedisCacheConfiguration.defaultCacheConfig()
				                .entryTtl(Duration.ofSeconds(600))  // redis缓存过期时间
				                .disableCachingNullValues();
				    }
				
				    /**
				     * spring cache管理者
				     *
				     * @param factory
				     * @return
				     */
				    @Bean
				    public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
				        return RedisCacheManager.builder(factory)
				                .cacheDefaults(cacheConfiguration())
				                .transactionAware()
				                .build();
				    }
				
				    @Bean
				    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
				        // Jackson 序列方式
				        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);
				        ObjectMapper om = new ObjectMapper();
				        // Jackson 默认自动识别 Public 修饰的成员变量、getter、setter
				        // private、protected、public 修饰的成员变量都可以自动识别，无需都指定 getter、setter 或者 public。
				        // 参考 https://blog.csdn.net/sdyy321/article/details/40298081
				        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
				        // 对于 8 种基本数据类型及其封装类和 String ，其他的类型在序列化的时候带上该类型和值
				        // 参考 https://www.jianshu.com/p/c5fcd2a1ab49
				        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
				        jackson2JsonRedisSerializer.setObjectMapper(om);
				
				        RedisTemplate<String, Object> template = new RedisTemplate<>();
				        // Redis 链接
				        template.setConnectionFactory(redisConnectionFactory);
				        // Redis Key - Value 序列化使用 Jackson
				        template.setKeySerializer(jackson2JsonRedisSerializer);
				        template.setValueSerializer(jackson2JsonRedisSerializer);
				        // Redis HashKey - HashValue 序列化使用 Jackson
				        template.setHashKeySerializer(jackson2JsonRedisSerializer);
				        template.setHashValueSerializer(jackson2JsonRedisSerializer);
				
				        template.afterPropertiesSet();
				        return template;
				    }
				
				    @Bean
				    @ConditionalOnMissingBean(StringRedisTemplate.class)
				    public StringRedisTemplate stringRedisTemplate(
				            RedisConnectionFactory redisConnectionFactory) {
				        StringRedisTemplate template = new StringRedisTemplate();
				        template.setConnectionFactory(redisConnectionFactory);
				        return template;
				    }
				}
				
		Cache+Redis:
		
				方案一:
			
					pom.xml:
					
						<dependency>
				            <groupId>org.springframework.boot</groupId>
				            <artifactId>spring-boot-starter-cache</artifactId>
				        </dependency>
				        <dependency>
				            <groupId>org.springframework.boot</groupId>
				            <artifactId>spring-boot-starter-data-redis</artifactId>
				        </dependency>
				        <dependency>
				            <groupId>org.apache.commons</groupId>
				            <artifactId>commons-lang3</artifactId>
				            <version>3.8.1</version>
				        </dependency>
				
					application.properties:
					
						# 数据库驱动：
						spring.datasource.driver-class-name=com.mysql.jdbc.Driver
						# 数据库连接地址
						spring.datasource.url=jdbc:mysql://localhost:3306/springboot_cache?useUnicode=true&characterEncoding=utf8
						# 数据库用户名&密码：
						spring.datasource.username=root
						spring.datasource.password=123456
						# mybatis需要开启驼峰命名匹配规则
						mybatis.configuration.map-underscore-to-camel-case=true
						logging.level.cn.kt.springboot_cache.mapper=debug
						 
						 
						# Redis数据库索引（默认为0）
						spring.redis.database=0
						# Redis服务器地址
						spring.redis.host=127.0.0.1
						# Redis服务器连接端口
						spring.redis.port=6379
						# Redis服务器连接密码（默认为空）
						spring.redis.password=
						# 连接超时时间（毫秒）
						spring.redis.timeout=5000ms
				
			方案二:
					
					pom.xml:
					        <!-- fastjson -->
					        <dependency>
					            <groupId>com.alibaba</groupId>
					            <artifactId>fastjson</artifactId>
					            <version>1.2.31</version>
					        </dependency>
					        <!-- spring cache -->
					        <dependency>
					            <groupId>org.springframework.boot</groupId>
					            <artifactId>spring-boot-starter-cache</artifactId>
					        </dependency>
					
					        <!-- redis -->
					        <dependency>
					            <groupId>org.springframework.boot</groupId>
					            <artifactId>spring-boot-starter-data-redis</artifactId>
					        </dependency>
				
				
				import java.io.Serializable;
				import java.nio.charset.Charset;
				import java.time.Duration;
				import org.apache.commons.lang3.StringUtils;
				import org.springframework.beans.factory.annotation.Value;
				import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
				import org.springframework.cache.CacheManager;
				import org.springframework.cache.annotation.CachingConfigurerSupport;
				import org.springframework.cache.interceptor.KeyGenerator;
				import org.springframework.context.annotation.Bean;
				import org.springframework.context.annotation.Configuration;
				import org.springframework.data.redis.cache.RedisCacheManager;
				import org.springframework.data.redis.connection.RedisConnectionFactory;
				import org.springframework.data.redis.connection.RedisPassword;
				import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
				import org.springframework.data.redis.connection.jedis.JedisClientConfiguration;
				import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;
				import org.springframework.data.redis.core.RedisTemplate;
				import org.springframework.data.redis.core.StringRedisTemplate;
				import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
				import org.springframework.data.redis.serializer.RedisSerializer;
				import org.springframework.data.redis.serializer.SerializationException;
				import org.springframework.data.redis.serializer.StringRedisSerializer;
				import com.alibaba.fastjson.JSON;
				import com.alibaba.fastjson.serializer.SerializerFeature;
				import redis.clients.jedis.JedisPool;
				import redis.clients.jedis.JedisPoolConfig;
				
				@Configuration
				public class RedisConfig extends CachingConfigurerSupport {
				
				    @Value("${spring.redis.host}")
				    private String host;
				
				    @Value("${spring.redis.port}")
				    private int port;
				
				    @Value("${spring.redis.password}")
				    private String password;
				
				    @Value("${spring.redis.timeout}")
				    private int timeout;
				
				    @Value("${spring.redis.jedis.pool.max-idle}")
				    private int maxIdle;
				
				    @Value("${spring.redis.jedis.pool.max-wait}")
				    private long maxWaitMillis;
				
				    @Bean
				    public JedisPool redisPoolFactory() {
				        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
				        jedisPoolConfig.setMaxIdle(maxIdle);
				        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);
				        if (StringUtils.isNotBlank(password)) {
				            return new JedisPool(jedisPoolConfig, host, port, timeout, password);
				        } else {
				            return new JedisPool(jedisPoolConfig, host, port, timeout);
				        }
				    }
				
				    @Bean
				    JedisConnectionFactory jedisConnectionFactory() {
				        RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();
				        redisStandaloneConfiguration.setHostName(host);
				        redisStandaloneConfiguration.setPort(port);
				        redisStandaloneConfiguration.setPassword(RedisPassword.of(password));
				
				        JedisClientConfiguration.JedisClientConfigurationBuilder jedisClientConfiguration = JedisClientConfiguration.builder();
				        jedisClientConfiguration.connectTimeout(Duration.ofMillis(timeout));
				        jedisClientConfiguration.usePooling();
				        return new JedisConnectionFactory(redisStandaloneConfiguration, jedisClientConfiguration.build());
				    }
				
				    @Bean(name = "redisTemplate")
				    @SuppressWarnings({"unchecked", "rawtypes"})
				    @ConditionalOnMissingBean(name = "redisTemplate")
				    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
				        RedisTemplate<Object, Object> template = new RedisTemplate<>();
				
				        //使用 fastjson 序列化
				        FastJsonRedisSerializer fastJsonRedisSerializer = new FastJsonRedisSerializer(Object.class);
				        // value 值的序列化采用 fastJsonRedisSerializer
				        template.setValueSerializer(fastJsonRedisSerializer);
				        template.setHashValueSerializer(fastJsonRedisSerializer);
				        // key 的序列化采用 StringRedisSerializer
				        template.setKeySerializer(new StringRedisSerializer());
				        template.setHashKeySerializer(new StringRedisSerializer());
				
				        template.setConnectionFactory(redisConnectionFactory);
				        return template;
				    }
				
				    //缓存管理器
				    @Bean
				    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
				        RedisCacheManager.RedisCacheManagerBuilder builder = RedisCacheManager
				                .RedisCacheManagerBuilder
				                .fromConnectionFactory(redisConnectionFactory);
				        return builder.build();
				    }
				
				    @Bean
				    @ConditionalOnMissingBean(StringRedisTemplate.class)
				    public StringRedisTemplate stringRedisTemplate(
				            RedisConnectionFactory redisConnectionFactory) {
				        StringRedisTemplate template = new StringRedisTemplate();
				        template.setConnectionFactory(redisConnectionFactory);
				        return template;
				    }
				
				    @Bean
				    public KeyGenerator wiselyKeyGenerator() {
				        return (target, method, params) -> {
				            StringBuilder sb = new StringBuilder();
				            sb.append(target.getClass().getName());
				            sb.append(method.getName());
				            for (Object obj : params) {
				                sb.append(obj.toString());
				            }
				            return sb.toString();
				        };
				    }
				
				    @Bean
				    public RedisTemplate<String, Serializable> limitRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
				        RedisTemplate<String, Serializable> template = new RedisTemplate<>();
				        template.setKeySerializer(new StringRedisSerializer());
				        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
				        template.setConnectionFactory(redisConnectionFactory);
				        return template;
				    }
				}
				
				class FastJsonRedisSerializer<T> implements RedisSerializer<T> {
				    private static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");
				    private Class<T> clazz;
				
				    FastJsonRedisSerializer(Class<T> clazz) {
				        super();
				        this.clazz = clazz;
				    }
				
				    @Override
				    public byte[] serialize(T t) throws SerializationException {
				        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);
				    }
				
				    @Override
				    public T deserialize(byte[] bytes) throws SerializationException {
				        if (bytes.length <= 0) {
				            return null;
				        }
				        String str = new String(bytes, DEFAULT_CHARSET);
				        return JSON.parseObject(str, clazz);
				    }
				}
		
		Spring Boot + Redis + 注解 + 拦截器来实现接口幂等性校验
			
			幂等性, 通俗的说就是一个接口, 多次发起同一个请求, 必须保证操作只能执行一次

			解决方案:
			
				唯一索引 -- 防止新增脏数据
				token机制 -- 防止页面重复提交
					1、token 机制实现
						具体流程步骤：

							客户端会先发送一个请求去获取 token，服务端会生成一个全局唯一的 ID 作为 token 保存在 redis 中，同时把这个 ID 返回给客户端
							
							客户端第二次调用业务请求的时候必须携带这个 token
							
							服务端会校验这个 token，如果校验成功，则执行业务，并删除 redis 中的 token
							
							如果校验失败，说明 redis 中已经没有对应的 token，则表示重复操作，直接返回指定的结果给客户端
							
							注意：
							
							对 redis 中是否存在 token 以及删除的代码逻辑建议用 Lua 脚本实现，保证原子性
							
							全局唯一 ID 可以用百度的 uid-generator、美团的 Leaf 去生成

				悲观锁 -- 获取数据的时候加锁(锁表或锁行)
					select + insert or update or delete
						该方案就是操作之前先查询一下,符合要求再插入,该方案在没有并发的系统中可以解决幂等问题，在单JVM有并发的时候可以用JVM加锁来保证幂等性,在分布式环境它是无法保证幂等性,可以使用分布式来保证。
				乐观锁 -- 基于版本号version实现, 在更新数据那一刻校验数据
					update table set version = version + 1 where id = #{id} and version = #{version} 
					
					2、基于 mysql 实现
						具体流程步骤：

							建立一张去重表，其中某个字段需要建立唯一索引
							
							客户端去请求服务端，服务端会将这次请求的一些信息插入这张去重表中
							
							因为表中某个字段带有唯一索引，如果插入成功，证明表中没有这次请求的信息，则执行后续的业务逻辑
							
							如果插入失败，则代表已经执行过当前请求，直接返回
							
							
				分布式锁 -- redis(jedis、redisson)或zookeeper实现
					3、基于 redis 实现
						这种实现方式是基于 SETNX 命令实现的

						SETNX key value：将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。
						
						该命令在设置成功时返回 1，设置失败时返回 0。
						
						具体流程步骤：

							客户端先请求服务端，会拿到一个能代表这次请求业务的唯一字段
							
							将该字段以 SETNX 的方式存入 redis 中，并根据业务设置相应的超时时间
							
							如果设置成功，证明这是第一次请求，则执行后续的业务逻辑
							
							如果设置失败，则代表已经执行过当前请求，直接返回
							
							
				状态机 -- 状态变更, 更新数据时判断状态
				使用Post/Redirect/Get模式
					在提交后执行页面重定向,这就是所谓的Post-Redirect—Get(PRG)模式,简单来说就是当用户提交连表单后,跳转到一个重定向的信息页面
				在session存放特殊标志
					在服务端,生成一个唯一的标识符,将它存入session,同时前端获取这个标识符的值将它写入表单的隐藏中,
					用于用户输入信息后点击一起提交,在服务器端,获取表单中隐藏字段的值,与session中的唯一标识符比较,
					相等说明是首次提交,就处理本次请求,然后将session中的唯一标识符移除,不相等则表示是重复提交,不再做处理
				使用唯一索引防止新增脏数据
					利用数据库唯一索引机制,当数据重复时,插入数据库会抛出异常,保证不会出现脏数据

			pom.xml:
			
				<!-- Redis-Jedis -->
				<dependency>
				     <groupId>redis.clients</groupId>
				     <artifactId>jedis</artifactId>
				     <version>2.9.0</version>
				</dependency>
				
				<!--lombok 本文用到@Slf4j注解, 也可不引用, 自定义log即可-->
				<dependency>
				   <groupId>org.projectlombok</groupId>
				   <artifactId>lombok</artifactId>
				   <version>1.16.10</version>
				</dependency>	
				
		 JedisUtil:
		 
			@Component
			@Slf4j
			public class JedisUtil {
			
			    @Autowired
			    private JedisPool jedisPool;
			
			    private Jedis getJedis() {
			        return jedisPool.getResource();
			    }
			
			    /**
			     * 设值
			     *
			     * @param key
			     * @param value
			     * @return
			     */
			    public String set(String key, String value) {
			        Jedis jedis = null;
			        try {
			            jedis = getJedis();
			            return jedis.set(key, value);
			        } catch (Exception e) {
			            log.error("set key:{} value:{} error", key, value, e);
			            return null;
			        } finally {
			            close(jedis);
			        }
			    }
			
			    /**
			     * 设值
			     *
			     * @param key
			     * @param value
			     * @param expireTime 过期时间, 单位: s
			     * @return
			     */
			    public String set(String key, String value, int expireTime) {
			        Jedis jedis = null;
			        try {
			            jedis = getJedis();
			            return jedis.setex(key, expireTime, value);
			        } catch (Exception e) {
			            log.error("set key:{} value:{} expireTime:{} error", key, value, expireTime, e);
			            return null;
			        } finally {
			            close(jedis);
			        }
			    }
			
			    /**
			     * 取值
			     *
			     * @param key
			     * @return
			     */
			    public String get(String key) {
			        Jedis jedis = null;
			        try {
			            jedis = getJedis();
			            return jedis.get(key);
			        } catch (Exception e) {
			            log.error("get key:{} error", key, e);
			            return null;
			        } finally {
			            close(jedis);
			        }
			    }
			
			    /**
			     * 删除key
			     *
			     * @param key
			     * @return
			     */
			    public Long del(String key) {
			        Jedis jedis = null;
			        try {
			            jedis = getJedis();
			            return jedis.del(key.getBytes());
			        } catch (Exception e) {
			            log.error("del key:{} error", key, e);
			            return null;
			        } finally {
			            close(jedis);
			        }
			    }
			
			    /**
			     * 判断key是否存在
			     *
			     * @param key
			     * @return
			     */
			    public Boolean exists(String key) {
			        Jedis jedis = null;
			        try {
			            jedis = getJedis();
			            return jedis.exists(key.getBytes());
			        } catch (Exception e) {
			            log.error("exists key:{} error", key, e);
			            return null;
			        } finally {
			            close(jedis);
			        }
			    }
			
			    /**
			     * 设值key过期时间
			     *
			     * @param key
			     * @param expireTime 过期时间, 单位: s
			     * @return
			     */
			    public Long expire(String key, int expireTime) {
			        Jedis jedis = null;
			        try {
			            jedis = getJedis();
			            return jedis.expire(key.getBytes(), expireTime);
			        } catch (Exception e) {
			            log.error("expire key:{} error", key, e);
			            return null;
			        } finally {
			            close(jedis);
			        }
			    }
			
			    /**
			     * 获取剩余时间
			     *
			     * @param key
			     * @return
			     */
			    public Long ttl(String key) {
			        Jedis jedis = null;
			        try {
			            jedis = getJedis();
			            return jedis.ttl(key);
			        } catch (Exception e) {
			            log.error("ttl key:{} error", key, e);
			            return null;
			        } finally {
			            close(jedis);
			        }
			    }
			
			    private void close(Jedis jedis) {
			        if (null != jedis) {
			            jedis.close();
			        }
			    }
			}
		
		自定义注解@ApiIdempotent
			
			/**
			 * 在需要保证 接口幂等性 的Controller的方法上使用此注解
			 */
			@Target({ElementType.METHOD})
			@Retention(RetentionPolicy.RUNTIME)
			public @interface ApiIdempotent {
			
			}	
			
	 	ApiIdempotentInterceptor拦截器
		
			/**
			 * 接口幂等性拦截器
			 */
			public class ApiIdempotentInterceptor implements HandlerInterceptor {
			
			    @Autowired
			    private TokenService tokenService;
			
			    @Override
			    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
			        if (!(handler instanceof HandlerMethod)) {
			            return true;
			        }
			
			        HandlerMethod handlerMethod = (HandlerMethod) handler;
			        Method method = handlerMethod.getMethod();
			
			        ApiIdempotent methodAnnotation = method.getAnnotation(ApiIdempotent.class);
			        if (methodAnnotation != null) {
			            check(request);// 幂等性校验, 校验通过则放行, 校验失败则抛出异常, 并通过统一异常处理返回友好提示
			        }
			
			        return true;
			    }
			
			    private void check(HttpServletRequest request) {
			        tokenService.checkToken(request);
			    }
			
			    @Override
			    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
			    }
			
			    @Override
			    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {
			    }
			}
	 		
	 	TokenServiceImpl

		 	@Service
			public class TokenServiceImpl implements TokenService {
			
			    private static final String TOKEN_NAME = "token";
			
			    @Autowired
			    private JedisUtil jedisUtil;
			
			    @Override
			    public ServerResponse createToken() {
			        String str = RandomUtil.UUID32();
			        StrBuilder token = new StrBuilder();
			        token.append(Constant.Redis.TOKEN_PREFIX).append(str);
			
			        jedisUtil.set(token.toString(), token.toString(), Constant.Redis.EXPIRE_TIME_MINUTE);
			
			        return ServerResponse.success(token.toString());
			    }
			
			    @Override
			    public void checkToken(HttpServletRequest request) {
			        String token = request.getHeader(TOKEN_NAME);
			        if (StringUtils.isBlank(token)) {// header中不存在token
			            token = request.getParameter(TOKEN_NAME);
			            if (StringUtils.isBlank(token)) {// parameter中也不存在token
			                throw new ServiceException(ResponseCode.ILLEGAL_ARGUMENT.getMsg());
			            }
			        }
			
			        if (!jedisUtil.exists(token)) {
			            throw new ServiceException(ResponseCode.REPETITIVE_OPERATION.getMsg());
			        }
			
			        Long del = jedisUtil.del(token);
			        if (del <= 0) {
			            throw new ServiceException(ResponseCode.REPETITIVE_OPERATION.getMsg());
			        }
			    }
			}
			
		TestApplication:
		
				@SpringBootApplication
				@MapperScan("com.wangzaiplus.test.mapper")
				public class TestApplication  extends WebMvcConfigurerAdapter {
				
				    public static void main(String[] args) {
				        SpringApplication.run(TestApplication.class, args);
				    }
				
				    /**
				     * 跨域
				     * @return
				     */
				    @Bean
				    public CorsFilter corsFilter() {
				        final UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();
				        final CorsConfiguration corsConfiguration = new CorsConfiguration();
				        corsConfiguration.setAllowCredentials(true);
				        corsConfiguration.addAllowedOrigin("*");
				        corsConfiguration.addAllowedHeader("*");
				        corsConfiguration.addAllowedMethod("*");
				        urlBasedCorsConfigurationSource.registerCorsConfiguration("/**", corsConfiguration);
				        return new CorsFilter(urlBasedCorsConfigurationSource);
				    }
				
				    @Override
				    public void addInterceptors(InterceptorRegistry registry) {
				        // 接口幂等性拦截器
				        registry.addInterceptor(apiIdempotentInterceptor());
				        super.addInterceptors(registry);
				    }
				
				    @Bean
				    public ApiIdempotentInterceptor apiIdempotentInterceptor() {
				        return new ApiIdempotentInterceptor();
				    }
				}
				
			1、获取token的控制器TokenController

				@RestController
				@RequestMapping("/token")
				public class TokenController {
				
				    @Autowired
				    private TokenService tokenService;
				
				    @GetMapping
				    public ServerResponse token() {
				        return tokenService.createToken();
				    }
				}
				
		  2、TestController, 注意@ApiIdempotent注解, 在需要幂等性校验的方法上声明此注解即可, 不需要校验的无影响
			
				@RestController
				@RequestMapping("/test")
				@Slf4j
				public class TestController {
				
				    @Autowired
				    private TestService testService;
				
				    @ApiIdempotent
				    @PostMapping("testIdempotence")
				    public ServerResponse testIdempotence() {
				        return testService.testIdempotence();
				    }
				}
				
				
		Cache + Ehcache:
			pom.xml:
			
				<!-- Spring Boot缓存支持启动器 -->
				<dependency>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-cache</artifactId>
				</dependency>
		
				<!-- Ehcache坐标 -->
				<dependency>
					<groupId>net.sf.ehcache</groupId>
					<artifactId>ehcache</artifactId>
				</dependency>
		 		
		 	ehcache.xml:
		 		<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../config/ehcache.xsd">

			    <diskStore path="java.io.tmpdir"/>
			
			  <!--defaultCache:echcache的默认缓存策略  -->
			    <defaultCache
			            maxElementsInMemory="10000"
			            eternal="false"
			            timeToIdleSeconds="120"
			            timeToLiveSeconds="120"
			            maxElementsOnDisk="10000000"
			            diskExpiryThreadIntervalSeconds="120"
			            memoryStoreEvictionPolicy="LRU">
			        <persistence strategy="localTempSwap"/>
			    </defaultCache>
			    <!-- 自定义缓存策略 -->
			    <cache name="users"
			            maxElementsInMemory="10000"
			            eternal="false"
			            timeToIdleSeconds="120"
			            timeToLiveSeconds="120"
			            maxElementsOnDisk="10000000"
			            diskExpiryThreadIntervalSeconds="120"
			            memoryStoreEvictionPolicy="LRU">
			        <persistence strategy="localTempSwap"/>
			    </cache>
			</ehcache>
			
		application.properties:
		
			spring.cache.ehcache.cofnig=ehcache.xml
			
			@SpringBootApplication
			@EnableCaching //开启缓存
			public class App {
			
				public static void main(String[] args) {
					SpringApplication.run(App.class, args);
				}
			}
			
			@Override
			//@Cacheable:对当前查询的对象做缓存处理
			@Cacheable(value="users") //使用自定义的缓存策略 users
			public Users findUserById(Integer id) {
				return this.usersRepository.findOne(id);
			}
			
			@Override
			@Cacheable(value="users",key="#pageable.pageSize") //指定缓存的key
			public Page<Users> findUserByPage(Pageable pageable) {
				pageable = new PageRequest(0, 2);
				return this.usersRepository.findAll(pageable);
			}
			
			@Override
			//@CacheEvict(value="users",allEntries=true) 清除缓存中以users缓存策略缓存的对象
			@CacheEvict(value="users",allEntries=true)
			public void saveUsers(Users users) {
				this.usersRepository.save(users);
			}
			
	RabbitMQ:
	
		POM.xml:
		
			<dependency>
		        <groupId>org.springframework.boot</groupId>
		        <artifactId>spring-boot-starter-amqp</artifactId>
		    </dependency>
		    
		application.properties:
		
		    # RabbitMQ 配置
		    # RabbitMQ 服务器地址
		    spring.rabbitmq.host=127.0.0.1
		    # RabbitMQ 服务器端口
		    spring.rabbitmq.port=5672
		    # RabbitMQ 用户名
		    spring.rabbitmq.username=zgh
		    # RabbitMQ 密码
		    spring.rabbitmq.password=zgh123456
		
		
		Topic Exchange和Direct Exchange区别:
			Topic Exchange: 	BindingKey为匹配符
			Direct Exchange:	BindingKey不为匹配符
			
		RabbitMQ比较重要的几个概念：

			虚拟主机：RabbitMQ支持权限控制，但是最小控制粒度为虚拟主机。一个虚拟主机可以包含多个交换机、队列、绑定。
			
			交换机：RabbitMQ分发器，根据不同的策略将消息分发到相关的队列。
			
			队列：缓存消息的容器。
			
			绑定：设置交换机与队列的关系。
			
		发送消息:
		
			//1. 发送消息到队列
	        amqpTemplate.convertAndSend("queue1",msg);
	
	        //2. 发送消息到交换机(订阅交换机)
	        amqpTemplate.convertAndSend("ex1","",msg);
	
	        //3. 发送消息到交换机(路由交换机)
	        amqpTemplate.convertAndSend("ex2","a",msg);
			
		事务机制:
		
			channel.txSelect();  //开启事务
			try{
			    channel.basicPublish("ex4", "k1", null, msg.getBytes());
			    System.out.println("发送：" + msg);
			    channel.txCommit(); //提交事务
			}catch (Exception e){
			    channel.txRollback(); //事务回滚
			}
		
		Headers	Exchange:
			
			HeadersExchange交换机是根据请求消息中设置的header attribute参数类型来匹配的（和routingKey没有关
				
			添加一个配置类（消费者）:
				配置一个routingKey为credit.bank的消息队列并绑定在creditBankExchange交换机上
				配置一个routingKey为credit.finance的消息队列并绑定在creditFinanceExchange交换机上

				@Configuration
				public class HeadersConfig {
				    @Bean
				    public Queue creditBankQueue() {
				        return new Queue("credit.bank");
				    }
				     
				    @Bean
				    public Queue creditFinanceQueue() {
				        return new Queue("credit.finance");
				    }
				     
				    @Bean
				    public HeadersExchange creditBankExchange() {
				         return new HeadersExchange("creditBankExchange");
				    }
				     
				    @Bean
				    public HeadersExchange creditFinanceExchange() {
				         return new HeadersExchange("creditFinanceExchange");
				    }
				     
				    @Bean
				    public Binding bindingCreditAExchange(Queue creditBankQueue, HeadersExchange creditBankExchange) {
				        Map<String,Object> headerValues = new HashMap<>();
				        headerValues.put("type", "cash");
				        headerValues.put("aging", "fast");
				        return BindingBuilder.bind(creditBankQueue).to(creditBankExchange).whereAll(headerValues).match();
				    }
				     
				    @Bean
				    public Binding bindingCreditBExchange(Queue creditFinanceQueue, HeadersExchange creditFinanceExchange) {
				        Map<String,Object> headerValues = new HashMap<>();
				        headerValues.put("type", "cash");
				        headerValues.put("aging", "fast");
				        return BindingBuilder.bind(creditFinanceQueue).to(creditFinanceExchange).whereAny(headerValues).match();
				    }
				}
				
			添加一个消息监听类（消费者）:
				添加creditBank()方法，监听routingKey为credit.bank的队列消息
				添加creditFinance()方法，监听routingKey为credit.finance的队列消息
				
				@Component
				public class ApiCreditReceive {
				    @RabbitHandler
				    @RabbitListener(queues = "credit.bank")
				    public void creditBank(String msg) {
				        LogUtil.info("credit.bank receive message: "+msg);
				    }
				     
				    @RabbitHandler
				    @RabbitListener(queues = "credit.finance")
				    public void creditFinance(String msg) {
				        LogUtil.info("credit.finance receive message: "+msg);
				    }
				}
				
			添加一个消息发送类（生产者）:
				添加一个creditBank()方法，发送消息至creditBankExchange交换机且routingKey为credit.bank
				添加一个creditFinance()方法，发送消息至creditFinanceExchange交换机且routingKey为credit.finance
				
				@Component
				public class ApiCreditSender {
				    @Autowired
				    private AmqpTemplate rabbitTemplate;
				     
				    public void creditBank(Map<String, Object> head, String msg){
				        LogUtil.info("credit.bank send message: "+msg);
				        rabbitTemplate.convertAndSend("creditBankExchange", "credit.bank", getMessage(head, msg));
				    }
				     
				    public void creditFinance(Map<String, Object> head, String msg){
				        LogUtil.info("credit.finance send message: "+msg);
				        rabbitTemplate.convertAndSend("creditFinanceExchange", "credit.finance", getMessage(head, msg));
				    }
				}

		Topic Exchange:
		
			在RabbitMQ Config类中声明主题交换机、消息队列,并通过BindingKey实现主题交换机和消息队列的绑定
		    
			    @Configuration
			    public class TopicExchangeRabbitMQConfig {
			
			        public static final String topicExchangeName = "topicExchange1";
			
			        private static final String queue1BindingKey1 = "black.big.*";
			        
			        private static final String queue1BindingKey2 = "black.*.cat";
			        
			        private static final String queue2BindingKey = "*.small.*";
			        
			        private static final String queue3BindingKey = "#";
			
			        // 声明主题交换机
			        @Bean
			        public TopicExchange topicExchange() {
			            return new TopicExchange(topicExchangeName);
			        }
			
			        // 声明消息队列
			        @Bean
			        public Queue messageQueue1() {
			            return new Queue("queue1");
			        }
			
			        @Bean
			        public Queue messageQueue2() {
			            return new Queue("queue2");
			        }
			
			        @Bean
			        public Queue messageQueue3() {
			            return new Queue("queue3");
			        }
			
			        // 向主题交换机上绑定队列
			        @Bean
			        Binding bindingQueue1Exchange1(Queue messageQueue1, TopicExchange topicExchange) {
			            return BindingBuilder.bind( messageQueue1 )
			                .to( topicExchange )
			                .with( queue1BindingKey1 );
			        }
			
			        @Bean
			        Binding bindingQueue1Exchange2(Queue messageQueue1, TopicExchange topicExchange) {
			            return BindingBuilder.bind( messageQueue1 )
			                .to( topicExchange )
			                .with( queue1BindingKey2 );
			        }
			
			        @Bean
			        Binding bindingQueue2Exchange(Queue messageQueue2, TopicExchange topicExchange) {
			            return BindingBuilder.bind( messageQueue2 )
			                    .to( topicExchange )
			                    .with( queue2BindingKey );
			        }
			
			        @Bean
			        Binding bindingQueue3Exchange(Queue messageQueue3, TopicExchange topicExchange) {
			            return BindingBuilder.bind( messageQueue3 )
			                    .to( topicExchange )
			                    .with( queue3BindingKey );
			        }
			    }
			    
			         生产者:
			         
			    	@Component
				    public class TopicExchangeProducer {
				        @Autowired
				        private AmqpTemplate rabbitMQTemplate;
				
				        public void send(String msg, String routingKey) {                                    
				            rabbitMQTemplate.convertAndSend(TopicExchangeRabbitMQConfig.topicExchangeName, routingKey, msg);
				        }
				    }
				    
			          消费者类:
			          
			   		@RabbitListener注解用于监听指定名称的消息队列,
			   		而标注在方法上的@RabbitHandler则用于指示从指定消息队列收到消息后，使用该方法进行处理
			   		
			   		@Component
				    public class TopicExchangeConsumer {
				
				        @RabbitListener(queues = "queue1")
				        @RabbitHandler
				        public void getQueue1Message(String  msg) {
				            Animal animal = JSONUtil.toBean( msg, Animal.class );
				            System.out.println("Queue 1 Receive [black.big.*, black.*.cat] , Msg: " + animal);
				        }
				
				        @RabbitListener(queues = "queue2")
				        @RabbitHandler
				        public void getQueue2Message(String msg) {
				            Animal animal = JSONUtil.toBean( msg, Animal.class );
				            System.out.println("Queue 2 Receive [*.small.*] , Msg: " + animal);
				        }
				
				        @RabbitListener(queues = "queue3")
				        @RabbitHandler
				        public void getQueue3Message(String msg) {
				            Animal animal = JSONUtil.toBean( msg, Animal.class );
				            System.out.println("Queue 3 Receive [#] , Msg: " + animal);
				        }
				    }
		
		Direct Exchange:
				
			在RabbitMQ Config类中声明直连交换机、消息队列，并通过BindingKey实现直连交换机和消息队列的绑定
			
				@Configuration
			    public class DirectExchangeRabbitMQConfig {
			
			        public static final String directExchangeName = "directExchange1";
			
			        private static final String queue4BindingKey1 = "big";
			        private static final String queue4BindingKey2 = "small";
			        private static final String queue5BindingKey =  "cat";
			
			        // 声明直连交换机
			        @Bean
			        public DirectExchange directExchange() {
			            return new DirectExchange(directExchangeName);
			        }
			
			        // 声明消息队列
			        @Bean
			        public Queue messageQueue4() {
			            return new Queue("queue4");
			        }
			
			        @Bean
			        public Queue messageQueue5() {
			            return new Queue("queue5");
			        }
			
			        // 向直连交换机上绑定队列
			        @Bean
			        Binding bindingQueue4Exchange1(Queue messageQueue4, DirectExchange directExchange) {
			            return BindingBuilder.bind( messageQueue4 )
			                .to( directExchange )
			                .with( queue4BindingKey1 );
			        }
			
			        @Bean
			        Binding bindingQueue4Exchange2(Queue messageQueue4, DirectExchange directExchange) {
			            return BindingBuilder.bind( messageQueue4 )
			                .to( directExchange )
			                .with( queue4BindingKey2 );
			        }
			
			        @Bean
			        Binding bindingQueue5Exchange(Queue messageQueue5, DirectExchange directExchange) {
			            return BindingBuilder.bind( messageQueue5 )
			                    .to( directExchange )
			                    .with( queue5BindingKey );
			        }
			    }
		   
		   	生产者:
		   	
		   	    @Component
			    public class DirectExchangeProducer {
			
			        @Autowired
			        private AmqpTemplate rabbitMQTemplate;
			
			        public void send(String msg, String routingKey) {
			            rabbitMQTemplate.convertAndSend(DirectExchangeRabbitMQConfig.directExchangeName, routingKey, msg);
			        }
			    }
			    
			消费者:
			
				@Component
			    public class DirectExchangeConsumer {
			
			        @RabbitListener(queues = "queue4")
			        @RabbitHandler
			        public void getQueue1Message(String  msg) {
			            Animal animal = JSONUtil.toBean( msg, Animal.class );
			            System.out.println("Queue 4 Receive [big, small] , Msg: " + animal);
			        }
			
			        @RabbitListener(queues = "queue5")
			        @RabbitHandler
			        public void getQueue2Message(String msg) {
			            Animal animal = JSONUtil.toBean( msg, Animal.class );
			            System.out.println("Queue 5 Receive [cat] , Msg: " + animal);
			        }
			    }
		
		Fanout Exchange:
		
			在RabbitMQ Config类中声明扇形交换机、消息队列，并将扇形交换机和消息队列的绑定  
			
			@Configuration
		    public class FanoutExchangeRabbitMQConfig {
		
		        public static final String fanoutExchangeName = "fanoutExchange1";
		
		        // 声明扇形交换机
		        @Bean
		        public FanoutExchange fanoutExchange() {
		            return new FanoutExchange(fanoutExchangeName);
		        }
		
		        // 声明消息队列
		        @Bean
		        public Queue messageQueue6() {
		            return new Queue("queue6");
		        }
		
		        @Bean
		        public Queue messageQueue7() {
		            return new Queue("queue7");
		        }
		
		        // 向扇形交换机上绑定队列
		        @Bean
		        Binding bindingQueue6Exchange1(Queue messageQueue6, FanoutExchange fanoutExchange) {
		            return BindingBuilder.bind( messageQueue6 )
		                .to( fanoutExchange );
		        }
		
		        @Bean
		        Binding bindingQueue7Exchange(Queue messageQueue7, FanoutExchange fanoutExchange) {
		            return BindingBuilder.bind( messageQueue7 )
		                    .to( fanoutExchange );
		        }
		    } 
		    
		    @Configuration
			public class TopicConfig {
			    @Bean
			    public Queue coreQueue() {
			        return new Queue("api.core");
			    }
			     
			    @Bean
			    public Queue paymentQueue() {
			        return new Queue("api.payment");
			    }
			     
			    @Bean
			    public TopicExchange coreExchange() {
			        return new TopicExchange("coreExchange");
			    }
			     
			    @Bean
			    public TopicExchange paymentExchange() {
			        return new TopicExchange("paymentExchange");
			    }
			     
			    @Bean
			    public Binding bindingCoreExchange(Queue coreQueue, TopicExchange coreExchange) {
			        return BindingBuilder.bind(coreQueue).to(coreExchange).with("api.core.*");
			    }
			     
			    @Bean
			    public Binding bindingPaymentExchange(Queue paymentQueue, TopicExchange paymentExchange) {
			        return BindingBuilder.bind(paymentQueue).to(paymentExchange).with("api.payment.#");
			    }
			}
			
		    生产者:
		    
		    @Component
		    public class FanoutExchangeProducer {
		
		        @Autowired
		        private AmqpTemplate rabbitMQTemplate;
		
		        public void send(String msg, String routingKey) {
		            rabbitMQTemplate.convertAndSend(FanoutExchangeRabbitMQConfig.fanoutExchangeName, routingKey, msg);
		        }
		    }
		    
		    @Component
			public class ApiCoreSender {
			    @Autowired
			    private AmqpTemplate rabbitTemplate;
			     
			    public void user(String msg){
			        LogUtil.info("api.core.user send message: "+msg);
			        rabbitTemplate.convertAndSend("coreExchange", "api.core.user", msg);
			    }
			     
			    public void userQuery(String msg){
			        LogUtil.info("api.core.user.query send message: "+msg);
			        rabbitTemplate.convertAndSend("coreExchange", "api.core.user.query", msg);
			    }
			}
			
		 消费者:
		 
		 	@Component
		    public class FanoutExchangeConsumer {
		
		        @RabbitListener(queues = "queue6")
		        @RabbitHandler
		        public void getQueue1Message(String  msg) {
		            Animal animal = JSONUtil.toBean( msg, Animal.class );
		            System.out.println("Queue 6 Receive , Msg: " + animal);
		        }
		
		        @RabbitListener(queues = "queue7")
		        @RabbitHandler
		        public void getQueue2Message(String msg) {
		            Animal animal = JSONUtil.toBean( msg, Animal.class );
		            System.out.println("Queue 7 Receive , Msg: " + animal);
		        }
		    }
		    
		    @Component
			public class ApiCoreReceive {
			    @RabbitHandler
			    @RabbitListener(queues = "api.core")
			    public void user(String msg) {
			        LogUtil.info("api.core receive message: "+msg);
			    }
			}
		    
		Springboot配置多数据源Rabbitmq:
			
			application.yml:
			
				spring:
				  rabbitmq:
				    rabbitmq:
				    cart-order:
				      virtual-host: /
				      host: localhost
				      port: 5672
				      username: guest
				      password: guest
				    order-adaptor:
				      virtual-host: /
				      host: localhost
				      port: 5672
				      username: test
				      password: 123456  
				    listener:
				      simple:
				        concurrency: 10
				        max-concurrency: 20
				        prefetch: 5
				
				mq:
				  env: test
				
				cart:
				  place:
				    order:
				      queue: ${mq.env}.cart.place.order.queue
				      exchange: ${mq.env}.cart.place.order.exchange
				      routing:
				        key: ${mq.env}.cart.place.order.routing.key  
				
				ticketing:
				  place:
				    order:
				      queue: ${mq.env}.ticketing.place.order.queue
				      exchange: ${mq.env}.ticketing.place.order.exchange
				      routing:
				        key: ${mq.env}.ticketing.place.order.routing.key
				        
		RabbitmqConfig的修改:
			        
			@Configuration
			public class RabbitmqConfig {
			    private static final Logger logger = LogManager.getLogger(RabbitmqConfig.class);
			
			    @Autowired
			    private Environment environment;
			
			    @Autowired
			    private SimpleRabbitListenerContainerFactoryConfigurer factoryConfigurer;
			
			    @Autowired
			    private ObjectMapper objectMapper;
			
			    @Bean(name = "cartOrderCachingConnectionFactory")
			    @Primary
			    public CachingConnectionFactory cartOrderCachingConnectionFactory() {
			        CachingConnectionFactory cachingConnectionFactory = new CachingConnectionFactory();
			        cachingConnectionFactory.setHost(environment.getProperty("spring.rabbitmq.cart-order.host"));
			        cachingConnectionFactory.setPort(environment.getProperty("spring.rabbitmq.cart-order.port", int.class));
			        cachingConnectionFactory.setUsername(environment.getProperty("spring.rabbitmq.cart-order.username"));
			        cachingConnectionFactory.setPassword(environment.getProperty("spring.rabbitmq.cart-order.password"));
			        cachingConnectionFactory.setVirtualHost(environment.getProperty("spring.rabbitmq.cart-order.virtual-host"));
			        cachingConnectionFactory.setPublisherReturns(true);
			        cachingConnectionFactory.setPublisherConfirms(true);
			        return cachingConnectionFactory;
			    }
			
			    @Bean(name = "orderAdaptorCachingConnectionFactory")
			    public CachingConnectionFactory orderAdaptorCachingConnectionFactory() {
			        CachingConnectionFactory cachingConnectionFactory = new CachingConnectionFactory();
			        cachingConnectionFactory.setHost(environment.getProperty("spring.rabbitmq.order-adaptor.host"));
			        cachingConnectionFactory.setPort(environment.getProperty("spring.rabbitmq.order-adaptor.port", int.class));
			        cachingConnectionFactory.setUsername(environment.getProperty("spring.rabbitmq.order-adaptor.username"));
			        cachingConnectionFactory.setPassword(environment.getProperty("spring.rabbitmq.order-adaptor.password"));
			        cachingConnectionFactory.setVirtualHost(environment.getProperty("spring.rabbitmq.order-adaptor.virtual-host"));
			        cachingConnectionFactory.setPublisherReturns(true);
			        cachingConnectionFactory.setPublisherConfirms(true);
			        return cachingConnectionFactory;
			    }
			
			    /**
			     * singleton can't set multi times callback
			     * @return
			     */
			    @Bean(name = "cartOrderRabbitTemplate")
			    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
			    @Primary
			    public RabbitTemplate cartOrderRabbitTemplate(@Qualifier("cartOrderCachingConnectionFactory")CachingConnectionFactory cachingConnectionFactory) {
			
			       RabbitTemplate rabbitTemplate = new RabbitTemplate(cachingConnectionFactory);
			       rabbitTemplate.setMandatory(true);
			       rabbitTemplate.setMessageConverter(new Jackson2JsonMessageConverter());
			
			       rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
			           if (ack) {
			               logger.info("cartOrder message send succeed:correlationData({}),ack({}),cause({})",correlationData, ack, cause);
			           } else {
			               logger.info("cartOrder message send failed:correlationData({}),ack({}),cause({})",correlationData, ack, cause);
			           }
			       });
			
			
			       rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -> {
			           logger.info("cartOrder message lose:exchange({}),route({}),replyCode({}),replyText({}),message:{}", exchange, routingKey, replyCode, replyText, message);
			       });
			
			       return rabbitTemplate;
			
			    }
			
			    /**
			     * singleton can't set multi times callback
			     * @return
			     */
			    @Bean(name = "orderAdaptorRabbitTemplate")
			    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
			    public RabbitTemplate orderAdaptorRabbitTemplate(@Qualifier("orderAdaptorCachingConnectionFactory")CachingConnectionFactory cachingConnectionFactory) {
			
			        RabbitTemplate rabbitTemplate = new RabbitTemplate(cachingConnectionFactory);
			        rabbitTemplate.setMandatory(true);
			        rabbitTemplate.setMessageConverter(new Jackson2JsonMessageConverter());
			        rabbitTemplate.setRoutingKey("");
			        rabbitTemplate.setDefaultReceiveQueue("");
			
			        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
			            if (ack) {
			                logger.info("orderAdaptor message send succeed:correlationData({}),ack({}),cause({})",correlationData, ack, cause);
			            } else {
			                logger.info("orderAdaptor message send failed:correlationData({}),ack({}),cause({})",correlationData, ack, cause);
			            }
			        });
			
			
			        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -> {
			            logger.info("orderAdaptor message lose:exchange({}),route({}),replyCode({}),replyText({}),message:{}", exchange, routingKey, replyCode, replyText, message);
			        });
			
			        return rabbitTemplate;
			
			    }
			
			    @Bean(name = "cartOrderSingleListenerContainer")
			    @Primary
			    public SimpleRabbitListenerContainerFactory cartOrderSingleListenerContainer(SimpleRabbitListenerContainerFactoryConfigurer factoryConfigurer,
			                                                                                 @Qualifier("cartOrderCachingConnectionFactory")CachingConnectionFactory cachingConnectionFactory) {
			        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
			        factory.setConnectionFactory(cachingConnectionFactory);
			        factory.setMessageConverter(new Jackson2JsonMessageConverter());
			        factory.setConcurrentConsumers(1);
			        factory.setMaxConcurrentConsumers(1);
			        factory.setPrefetchCount(1);
			        factory.setTxSize(1);
			        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);
			
			        return factory;
			    }
			
			    @Bean(name = "cartOrderMultiListenerContainer")
			    @Primary
			    public SimpleRabbitListenerContainerFactory cartOrderMultiListenerContainer(SimpleRabbitListenerContainerFactoryConfigurer factoryConfigurer,
			                                                                                @Qualifier("cartOrderCachingConnectionFactory")CachingConnectionFactory cachingConnectionFactory) {
			        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
			        factoryConfigurer.configure(factory, cachingConnectionFactory);
			        factory.setMessageConverter(new Jackson2JsonMessageConverter());
			        factory.setConcurrentConsumers(environment.getProperty("spring.rabbitmq.listener.simple.concurrency", int.class));
			        factory.setMaxConcurrentConsumers(environment.getProperty("spring.rabbitmq.listener.simple.max-concurrency", int.class));
			        factory.setPrefetchCount(environment.getProperty("spring.rabbitmq.listener.simple.prefetch", int.class));
			
			        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);
			
			        return factory;
			    }
			
			    @Bean(name = "orderAdaptorSingleListenerContainer")
			    public SimpleRabbitListenerContainerFactory orderAdaptorSingleListenerContainer(@Qualifier("orderAdaptorCachingConnectionFactory")CachingConnectionFactory cachingConnectionFactory) {
			        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
			        factory.setConnectionFactory(cachingConnectionFactory);
			        factory.setMessageConverter(new Jackson2JsonMessageConverter());
			        factory.setConcurrentConsumers(1);
			        factory.setMaxConcurrentConsumers(1);
			        factory.setPrefetchCount(1);
			        factory.setTxSize(1);
			        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);
			
			        return factory;
			    }
			
			    @Bean(name = "orderAdaptorMultiListenerContainer")
			    public SimpleRabbitListenerContainerFactory orderAdaptorMultiListenerContainer(@Qualifier("orderAdaptorCachingConnectionFactory")CachingConnectionFactory cachingConnectionFactory) {
			        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
			        factoryConfigurer.configure(factory, cachingConnectionFactory);
			        factory.setMessageConverter(new Jackson2JsonMessageConverter());
			        factory.setConcurrentConsumers(environment.getProperty("spring.rabbitmq.listener.simple.concurrency", int.class));
			        factory.setMaxConcurrentConsumers(environment.getProperty("spring.rabbitmq.listener.simple.max-concurrency", int.class));
			        factory.setPrefetchCount(environment.getProperty("spring.rabbitmq.listener.simple.prefetch", int.class));
			
			        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);
			
			        return factory;
			    }
			
			    /**
			     * Message persistent: Set the deliveryMode of the message to 2 and the consumer can continue to consume
			     * the messages after persistence after restarting;
			     * Use convertAndSend to send a message. The message is persistent by default. The following is the source code:
			     * new MessageProperties() --> DEFAULT_DELIVERY_MODE = MessageDeliveryMode.PERSISTENT --> deliveryMode = 2;
			     *
			     * @param exchangeName
			     * @param routingKeyName
			     * @param content
			     * @param flag
			     * @param messageId
			     * @param <T>
			     */
			    public <T> void sendMessage(RabbitTemplate rabbitTemplate, String exchangeName, String routingKeyName, T content, boolean flag, String messageId) {
			        logger.info("message send :messageId({}), exchangeName({}), routingKeyName({}), content({}), flag({})",
			                messageId, exchangeName, routingKeyName, content);
			
			        CorrelationData correlationData = new CorrelationData();
			        MessageProperties properties = new MessageProperties();
			        properties.setContentType("application/json");
			
			        try {
			            if (flag) {
			                properties.setCorrelationId(messageId);
			                correlationData.setId(messageId);
			
			                rabbitTemplate.convertAndSend(exchangeName,
			                        routingKeyName,
			                        MessageBuilder.withBody(objectMapper.writeValueAsBytes(content)).andProperties(properties).build(),
			                        correlationData);
			            } else {
			                rabbitTemplate.convertAndSend(exchangeName,
			                        routingKeyName,
			                        MessageBuilder.withBody(objectMapper.writeValueAsBytes(content)).andProperties(properties).build(),
			                        correlationData);
			            }
			        } catch (Exception e) {
			            logger.error("error message :e.getMessage({})", e.getMessage());
			        }
			
			    }
			}		
		
				@Primary表示我们默认的连接。因为在单个数据源的情况下，我们可以使用默认的加载方式读取到mq的配置，
				但是多数据源的情况下我们就必须明确的指出每个bean对应的配置详情了。但是到这一步我们仍然会出现问题，
				那就是我们的queue和exchange的绑定仍然是默认的。单数据源的时候我们是默认绑定到单独的mq上，
				现在我们需要动态的分配它们的绑定信息，所以QueueConfig方式就不能满足我们的需求了，
				于是我采用了RabbitAdmin这个类动态的帮助我绑定queue和exchange到指定的mq上。
		
			@Configuration
			public class CartOrderRabbitAdminConfig {
			
			    private static final Logger logger = LogManager.getLogger(CartOrderRabbitAdminConfig.class);
			
			    @Autowired
			    private Environment environment;
			
			    @Bean
			    public RabbitAdmin cartOrderRabbitAdmin(@Qualifier("cartOrderCachingConnectionFactory")CachingConnectionFactory cachingConnectionFactory) {
			
			        RabbitAdmin rabbitAdmin = new RabbitAdmin(cachingConnectionFactory);
			        rabbitAdmin.setAutoStartup(true);//place cart order
			        Queue placeCartOrderQueue = RabbitmqUtil.createQueue(environment.getProperty("cart.place.order.queue"));
			        DirectExchange placeCartOrderExchange = RabbitmqUtil.createExchange(environment.getProperty("cart.place.order.exchange"));
			        Binding placeCartOrderBinding = RabbitmqUtil.createBinding(placeCartOrderQueue, placeCartOrderExchange, environment.getProperty("cart.place.order.routing.key"));
			        RabbitmqUtil.createRabbitAdmin(placeCartOrderQueue, placeCartOrderExchange, placeCartOrderBinding, rabbitAdmin);
			
			        //
			
			        return rabbitAdmin;
			
			    }
			}  
			
			@Configuration
			public class TicketOrderRabbitAdminConfig {
			
			    private static final Logger logger = LogManager.getLogger(TicketOrderRabbitAdminConfig.class);
			
			    @Autowired
			    private Environment environment;
			
			    @Bean
			    public RabbitAdmin ticketOrderRabbitAdmin(@Qualifier("orderAdaptorCachingConnectionFactory")CachingConnectionFactory cachingConnectionFactory) {
			
			        RabbitAdmin rabbitAdmin = new RabbitAdmin(cachingConnectionFactory);
			        rabbitAdmin.setAutoStartup(true);
			
			        //place ticket order
			        Queue createCartOrderQueue = RabbitmqUtil.createQueue(environment.getProperty("ticketing.place.order.queue"));
			        DirectExchange createCartOrderExchange = RabbitmqUtil.createExchange(environment.getProperty("ticketing.place.order.exchange"));
			        Binding createCartOrderBinding = RabbitmqUtil.createBinding(createCartOrderQueue, createCartOrderExchange, environment.getProperty("ticketing.place.order.routing.key"));
			        RabbitmqUtil.createRabbitAdmin(createCartOrderQueue, createCartOrderExchange, createCartOrderBinding, rabbitAdmin);
			
			        return rabbitAdmin;
			
			    }
			}
		
			public class RabbitmqUtil {

			    public static DirectExchange createExchange (String exchangeName) {
			        if(StringUtils.isNotBlank(exchangeName)) {
			            return new DirectExchange(exchangeName, true, false);
			        }
			
			        return null;
			
			    }
			
			    public static Queue createQueue(String queueName) {
			        if(StringUtils.isNotBlank(queueName)) {
			            return new Queue(queueName, true);
			        }
			
			        return null;
			    }
			
			    public static Binding createBinding (Queue queueName, DirectExchange exchangeName, String routingKeyName) {
			        if(Objects.nonNull(queueName) && Objects.nonNull(exchangeName) && StringUtils.isNotBlank(routingKeyName)) {
			            return BindingBuilder.bind(queueName).to(exchangeName).with(routingKeyName);
			        }
			        return null;
			    }
			
			    public static void createRabbitAdmin(Queue queue, DirectExchange exchange, Binding binding, RabbitAdmin rabbitAdmin) {
			        rabbitAdmin.declareQueue(queue);
			        rabbitAdmin.declareExchange(exchange);
			        rabbitAdmin.declareBinding(binding);
			    }
			}
		
		SpringBoot RabbitMQ 消息过期:
			
			主要有2种方式：
				指定一条消息的过期时间。
				给队列设置消息过期时间，队列中的所有消息都有同样的过期时间。
			
				1、指定消息的过期时间
				
					@RestController
					public class TTLController {
					    @Autowired
					    private RabbitTemplate rabbitTemplate;
					
					    @PostMapping("/testTTL")
					    public String testTTL() {
					        MessageProperties messageProperties = new MessageProperties();
					        messageProperties.setExpiration("20000"); // 设置过期时间，单位：毫秒
					        byte[] msgBytes = "测试消息自动过期".getBytes();
					        Message message = new Message(msgBytes, messageProperties);
					        rabbitTemplate.convertAndSend("TTL_EXCHANGE", "TTL", message);
					        return "ok";
					    }
					}
					消息推送到队列后，如果指定时间内没有被消费，则会自动过期。
						注意：
							RabbitMQ只会对队列头部的消息进行过期淘汰。如果单独给消息设置TTL，先入队列的消息过期时间如果设置比较长，后入队列的设置时间比较短。会造成消息不会及时地过期淘汰，导致消息的堆积。
				
				2、给队列中的所有消息设置过期时间
					@Configuration
					public class TTLQueueRabbitConfig {
					    @Bean
					    public Queue TTLQueue() {
					        Map<String, Object> map = new HashMap<>();
					        map.put("x-message-ttl", 30000); // 队列中的消息未被消费则30秒后过期
					        return new Queue("TTL_QUEUE", true, false, false, map);
					    }
					
					    @Bean
					    public DirectExchange TTLExchange() {
					        return new DirectExchange("TTL_EXCHANGE", true, false);
					    }
					
					    @Bean
					    public Binding bindingDirect() {
					        return BindingBuilder.bind(TTLQueue()).to(TTLExchange()).with("TTL");
					    }
					}
					
					TTL队列:
						如果同时指定了Message TTL和Queue TTL，则优先较小的那一个。			
			    
		100%投递成功:
		
			消息确认机制：确认消息提供者是否成功发送消息到交换机
			
				spring.rabbitmq.publisher-confirm-type:SIMPLE	#开启消息确认模式
					NONE值是禁用发布确认模式，是默认值
					CORRELATED值是发布消息成功到交换器后会触发回调方法，如1示例
					SIMPLE值经测试有两种效果，
						其一效果和CORRELATED值一样会触发回调方法，
						其二在发布消息成功后使用rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果返回false则会关闭channel，则接下来无法发送消息到broker;
	
			Return机制：确认消息是否成功的从交换机分发到队列
				spring.rabbitmq.publisher-returns: true        ##使用return监听机制
			
			创建confirm和return监听
			
				@Component
				public class MsgConfirmAndReturn implements RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnCallback {
				
				    Logger logger = LoggerFactory.getLogger(MsgConfirmAndReturn.class);
				
				    @Resource
				    private RabbitTemplate rabbitTemplate;
				
				    @PostConstruct
				    public void init(){
				        rabbitTemplate.setConfirmCallback(this);
				        rabbitTemplate.setReturnCallback(this);
				    }
				
				    @Override
				    public void confirm(CorrelationData correlationData, boolean b, String s) {
				        //此方法用于监听消息确认结果（消息是否发送到交换机）
				        if(b){
				            logger.info("-------消息成功发送到交换机");
				        }else{
				            logger.warn("-------消息发送到交换机失败");
				        }
				    }
				
				    @Override
				    public void returnedMessage(Message message, int i, String s, String s1, String s2) {
				        //此方法用于return监听(当交换机分发消息到队列失败时执行)
				        logger.warn("~~~~~~~交换机分发消息到队列失败");
				    }
				}
			
			案例:
				pom.xml:
					<!--mq-->
			        <dependency>
			            <groupId>org.springframework.boot</groupId>
			            <artifactId>spring-boot-starter-amqp</artifactId>
			        </dependency>
			        <!--mail-->
			        <dependency>
			            <groupId>org.springframework.boot</groupId>
			            <artifactId>spring-boot-starter-mail</artifactId>
			        </dependency>
			        
				application.properties:
				
					# rabbitmq
						spring.rabbitmq.host=localhost
						spring.rabbitmq.port=5672
						spring.rabbitmq.username=guest
						spring.rabbitmq.password=guest
						
					# 开启confirms回调 P -> Exchange
						spring.rabbitmq.publisher-confirms=true
						
					# 开启returnedMessage回调 Exchange -> Queue
						spring.rabbitmq.publisher-returns=true
						
					# 设置手动确认(ack) Queue -> C
						spring.rabbitmq.listener.simple.acknowledge-mode=manual
						spring.rabbitmq.listener.simple.prefetch=100
						
					# mail
						spring.mail.host=smtp.163.com
						spring.mail.username=18621142249@163.com
						spring.mail.password=123456wangzai
						spring.mail.from=18621142249@163.com
						spring.mail.properties.mail.smtp.auth=true
						spring.mail.properties.mail.smtp.starttls.enable=true
						spring.mail.properties.mail.smtp.starttls.required=true
						
				sql:
				
					CREATE TABLE `msg_log` (
					  `msg_id` varchar(255) NOT NULL DEFAULT '' COMMENT '消息唯一标识',
					  `msg` text COMMENT '消息体, json格式化',
					  `exchange` varchar(255) NOT NULL DEFAULT '' COMMENT '交换机',
					  `routing_key` varchar(255) NOT NULL DEFAULT '' COMMENT '路由键',
					  `status` int(11) NOT NULL DEFAULT '0' COMMENT '状态: 0投递中 1投递成功 2投递失败 3已消费',
					  `try_count` int(11) NOT NULL DEFAULT '0' COMMENT '重试次数',
					  `next_try_time` datetime DEFAULT NULL COMMENT '下一次重试时间',
					  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
					  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
					  PRIMARY KEY (`msg_id`),
					  UNIQUE KEY `unq_msg_id` (`msg_id`) USING BTREE
					) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='消息投递日志';
					
					说明: exchange routing_key字段是在定时任务重新投递消息时需要用到的
				
			MailUtil.class:
			
				@Component
				@Slf4j
				public class MailUtil {
				
				    @Value("${spring.mail.from}")
				    private String from;
				
				    @Autowired
				    private JavaMailSender mailSender;
				
				    /**
				     * 发送简单邮件
				     *
				     * @param mail
				     */
				    public boolean send(Mail mail) {
				        String to = mail.getTo();// 目标邮箱
				        String title = mail.getTitle();// 邮件标题
				        String content = mail.getContent();// 邮件正文
				        SimpleMailMessage message = new SimpleMailMessage();
				        message.setFrom(from);
				        message.setTo(to);
				        message.setSubject(title);
				        message.setText(content);
				        try {
				            mailSender.send(message);
				            log.info("邮件发送成功");
				            return true;
				        } catch (MailException e) {
				            log.error("邮件发送失败, to: {}, title: {}", to, title, e);
				            return false;
				        }
				    }
				}
					
			
		  RabbitConfig.class:
		  
			  	@Configuration
				@Slf4j
				public class RabbitConfig {
				
				    @Autowired
				    private CachingConnectionFactory connectionFactory;
				
				    @Autowired
				    private MsgLogService msgLogService;
				
				    @Bean
				    public RabbitTemplate rabbitTemplate() {
				        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
				        rabbitTemplate.setMessageConverter(converter());
				        
				        // 消息是否成功发送到Exchange
				        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
				            if (ack) {
				                log.info("消息成功发送到Exchange");
				                String msgId = correlationData.getId();
				                msgLogService.updateStatus(msgId, Constant.MsgLogStatus.DELIVER_SUCCESS);
				            } else {
				                log.info("消息发送到Exchange失败, {}, cause: {}", correlationData, cause);
				            }
				        });
				
				        // 触发setReturnCallback回调必须设置mandatory=true, 否则Exchange没有找到Queue就会丢弃掉消息, 而不会触发回调
				        rabbitTemplate.setMandatory(true);
				
				        // 消息是否从Exchange路由到Queue, 注意: 这是一个失败回调, 只有消息从Exchange路由到Queue失败才会回调这个方法
				        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -> {
				            log.info("消息从Exchange路由到Queue失败: exchange: {}, route: {}, replyCode: {}, replyText: {}, message: {}", exchange, routingKey, replyCode, replyText, message);
				        });
				        
				        return rabbitTemplate;
				    }
					
					//设置JSON序列化机制
				    @Bean
				    public Jackson2JsonMessageConverter converter() {
				        return new Jackson2JsonMessageConverter();
				    }
				
				    // 发送邮件
				
				    public static final String MAIL_QUEUE_NAME = "mail.queue";
				
				    public static final String MAIL_EXCHANGE_NAME = "mail.exchange";
				
				    public static final String MAIL_ROUTING_KEY_NAME = "mail.routing.key";
				
				    @Bean
				    public Queue mailQueue() {
				        return new Queue(MAIL_QUEUE_NAME, true);
				    }
				
				    @Bean
				    public DirectExchange mailExchange() {
				        return new DirectExchange(MAIL_EXCHANGE_NAME, true, false);
				    }
				
				    @Bean
				    public Binding mailBinding() {
				        return BindingBuilder.bind(mailQueue()).to(mailExchange()).with(MAIL_ROUTING_KEY_NAME);
				    }
				}	
				
		TestServiceImpl生产消息
				
				@Service
				public class TestServiceImpl implements TestService {
				
				    @Autowired
				    private MsgLogMapper msgLogMapper;
				
				    @Autowired
				    private RabbitTemplate rabbitTemplate;
				
				    @Override
				    public ServerResponse send(Mail mail) {
				    
				        String msgId = RandomUtil.UUID32();
				        mail.setMsgId(msgId);
				        MsgLog msgLog = new MsgLog(msgId, mail, RabbitConfig.MAIL_EXCHANGE_NAME, RabbitConfig.MAIL_ROUTING_KEY_NAME);
				        msgLogMapper.insert(msgLog);// 消息入库
				        CorrelationData correlationData = new CorrelationData(msgId);
				        rabbitTemplate.convertAndSend(RabbitConfig.MAIL_EXCHANGE_NAME, RabbitConfig.MAIL_ROUTING_KEY_NAME, MessageHelper.objToMsg(mail), correlationData);// 发送消息
				        return ServerResponse.success(ResponseCode.MAIL_SEND_SUCCESS.getMsg());
				        
				    }
				}	
					
					
		MailConsumer消费消息, 发送邮件
		
			@Component
			@Slf4j
			public class MailConsumer {
			
			    @Autowired
			    private MsgLogService msgLogService;
			
			    @Autowired
			    private MailUtil mailUtil;
			
			    @RabbitListener(queues = RabbitConfig.MAIL_QUEUE_NAME)
			    public void consume(Message message, Channel channel) throws IOException {
			
			        Mail mail = MessageHelper.msgToObj(message, Mail.class);
			        log.info("收到消息: {}", mail.toString());
			        String msgId = mail.getMsgId();
			        MsgLog msgLog = msgLogService.selectByMsgId(msgId);
			        if (null == msgLog || msgLog.getStatus().equals(Constant.MsgLogStatus.CONSUMED_SUCCESS)) {// 消费幂等性
			            log.info("重复消费, msgId: {}", msgId);
			            return;
			        }
			
			        MessageProperties properties = message.getMessageProperties();
			        long tag = properties.getDeliveryTag();
			        boolean success = mailUtil.send(mail);
			        if (success) {
			            msgLogService.updateStatus(msgId, Constant.MsgLogStatus.CONSUMED_SUCCESS);
			            channel.basicAck(tag, false);// 消费确认
			        } else {
			            channel.basicNack(tag, false, true);
			        }
			    }
			}
			说明: 其实就完成了3件事: 1.保证消费幂等性, 2.发送邮件, 3.更新消息状态, 手动ack

			
		ResendMsg定时任务重新投递发送失败的消息
		
			@Component
			@Slf4j
			public class ResendMsg {
			
			    @Autowired
			    private MsgLogService msgLogService;
			
			    @Autowired
			    private RabbitTemplate rabbitTemplate;
			
			    // 最大投递次数
			    private static final int MAX_TRY_COUNT = 3;
			
			    /**
			     * 每30s拉取投递失败的消息, 重新投递
			     */
			
			    @Scheduled(cron = "0/30 * * * * ?")
			    public void resend() {
			
			        log.info("开始执行定时任务(重新投递消息)");
			        List<MsgLog> msgLogs = msgLogService.selectTimeoutMsg();
			        msgLogs.forEach(msgLog -> {
			            String msgId = msgLog.getMsgId();
			            if (msgLog.getTryCount() >= MAX_TRY_COUNT) {
			                msgLogService.updateStatus(msgId, Constant.MsgLogStatus.DELIVER_FAIL);
			                log.info("超过最大重试次数, 消息投递失败, msgId: {}", msgId);
			            } else {
			                msgLogService.updateTryCount(msgId, msgLog.getNextTryTime());// 投递次数+1
			                CorrelationData correlationData = new CorrelationData(msgId);
			                rabbitTemplate.convertAndSend(msgLog.getExchange(), msgLog.getRoutingKey(), MessageHelper.objToMsg(msgLog.getMsg()), correlationData);// 重新投递
			                log.info("第 " + (msgLog.getTryCount() + 1) + " 次重新投递消息");
			            }
			        });
			        log.info("定时任务执行结束(重新投递消息)");
			        
			    }
			}
			说明: 每一条消息都和exchange routingKey绑定, 所有消息重投共用这一个定时任务即可
		
		
		RabbitMQ消息的ack模式
		
			pom依赖：
			
				<!-- 添加springboot对amqp的支持 -->
				<dependency>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-amqp</artifactId>
				</dependency>
			
			application配置：
			
				# RabbitMQ 基本配置
					spring.rabbitmq.host=192.168.183.220
					spring.rabbitmq.port=5672
					spring.rabbitmq.username=guest
					spring.rabbitmq.password=guest
				
				## 生产端配置
				# 开启发布确认,就是confirm模式. 消费端ack应答后,才将消息从队列中删除
					spring.rabbitmq.publisher-confirms=true
				# 发布返回
					spring.rabbitmq.publisher-returns=true
				
				## 消费端配置
				# 手动ack
					spring.rabbitmq.listener.simple.acknowledge-mode=manual
				# 消费者最小数量
					spring.rabbitmq.listener.simple.concurrency=1
				# 消费者最大数量
					spring.rabbitmq.listener.simple.max-concurrency=10
				# 在单个请求中处理的消息个数，他应该大于等于事务数量(unack的最大数量)
					spring.rabbitmq.listener.simple.prefetch=1
				
				## 模板配置
				#设置为 true 后 消费者在消息没有被路由到合适队列情况下会被return监听，而不会自动删除
					spring.rabbitmq.template.mandatory=true
		
			RabbitConfig.java
			
				import org.slf4j.Logger;
				import org.slf4j.LoggerFactory;
				import org.springframework.amqp.core.*;
				import org.springframework.amqp.rabbit.connection.ConnectionFactory;
				import org.springframework.amqp.rabbit.core.RabbitTemplate;
				import org.springframework.beans.factory.annotation.Qualifier;
				import org.springframework.context.annotation.Bean;
				import org.springframework.context.annotation.Configuration;
				
				@Configuration
				public class RabbitConfig {
				
				    private static final Logger log= LoggerFactory.getLogger(RabbitConfig.class);
				
				    @Bean
				    public Queue queue() {
				        return new Queue("queue");
				    }
				
				    @Bean(name = "FQ1")
				    public Queue fanoutQueue1() {
				        return new Queue("fanout.queue1");
				    }
				
				    @Bean(name = "FQ2")
				    public Queue fanoutQueue2() {
				        return new Queue("fanout.queue2");
				    }
				
				    @Bean
				    public FanoutExchange fanoutExchange() {
				        return new FanoutExchange("fanout.exchange");
				    }
				
				    @Bean
				    public Binding bindingFQ1(@Qualifier("FQ1") Queue queue, FanoutExchange exchange){
				        return BindingBuilder.bind(queue).to(exchange);
				    }
				
				    @Bean
				    public Binding bindingFQ2(@Qualifier("FQ2") Queue queue, FanoutExchange exchange){
				        return BindingBuilder.bind(queue).to(exchange);
				    }
				
				    /**
				     * 定制化amqp模版
				     *
				     * ConfirmCallback接口用于ack回调   即消息发送到exchange  ack
				     * ReturnCallback接口用于消息发送失败回调  即消息发送不到任何一个队列中  ack
				     */
				    @Bean
				    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
				        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
				
				        // 消息返回, 需要配置 publisher-returns: true
				        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -> {
				            String correlationId = message.getMessageProperties().getCorrelationId();
				            log.debug("消息：{} 发送失败, 应答码：{} 原因：{} 交换机: {}  路由键: {}", correlationId, replyCode, replyText, exchange, routingKey);
				        });
				
				        // 消息确认, 需要配置 publisher-confirms: true
				        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
				            if (ack) {
				//                 log.debug("消息发送到exchange成功,id: {}", correlationData.getId());
				                 log.debug("消息发送到exchange成功");
				            } else {
				                log.debug("消息发送到exchange失败,原因: {}", cause);
				            }
				        });
				        return rabbitTemplate;
				    }
				}
			
			HelloSender.java
			
				import org.springframework.amqp.core.AmqpTemplate;
				import org.springframework.beans.factory.annotation.Autowired;
				import org.springframework.stereotype.Component;
				
				@Component
				public class HelloSender {
				
				    @Autowired
				    private AmqpTemplate template;
				
				    public void sendAck(String msg) {
				        template.convertAndSend("fanout.exchange","",msg);
				    }
					
				}
			
			HelloReceive.java
	
				import com.rabbitmq.client.Channel;
				import org.springframework.amqp.core.Message;
				import org.springframework.amqp.rabbit.annotation.RabbitListener;
				import org.springframework.stereotype.Component;
				import java.io.IOException;
				
				@Component
				public class HelloReceive {
				
				    //手动确认消息
				    @RabbitListener(queues = "fanout.queue1")
				    public void FQ1(Message message, Channel channel) throws IOException {
				        // 采用手动应答模式, 手动确认应答更为安全稳定
				        System.out.println("FQ1:" + new String(message.getBody()));
				        // 第一个参数是消息标识, 第二个是批量确认; false当前消息确认, true此次之前的消息确认
				        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
				    }
				
				    // 不确认消息,消息会重回队列
				    @RabbitListener(queues = "fanout.queue2")
				    public void FQ2(String str) {
				        System.out.println("FQ2:" + str);
				    }
				
				}
	springboot整合Rabbitmq(包含三种消息确认机制以及消费端限流)
		
		maven依赖:
			<dependency>
		        <groupId>org.springframework.boot</groupId>
		        <artifactId>spring-boot-starter-amqp</artifactId>
		        <version>2.1.4.RELEASE</version>
		    </dependency>
		    
		application.properties:
			spring.rabbitmq.host=localhost
			spring.rabbitmq.port=5672
			spring.rabbitmq.username=guest
			spring.rabbitmq.password=guest
			spring.rabbitmq.virtual-host=/
			spring.rabbitmq.connection-timeout=15000
			
			#开启 confirm 确认机制
			spring.rabbitmq.publisher-confirms=true
			#开启 return 确认机制
			spring.rabbitmq.publisher-returns=true
			#设置为 true 后 消费者在消息没有被路由到合适队列情况下会被return监听，而不会自动删除
			spring.rabbitmq.template.mandatory=true
			
			#设置消费端手动 ack
			spring.rabbitmq.listener.simple.acknowledge-mode=manual
			#消费者最小数量
			spring.rabbitmq.listener.simple.concurrency=1
			#消费之最大数量
			spring.rabbitmq.listener.simple.max-concurrency=10
			
			#在单个请求中处理的消息个数，他应该大于等于事务数量(unack的最大数量)
			spring.rabbitmq.listener.simple.prefetch=2
			
		代码:
		
			import org.springframework.amqp.core.Exchange;
			import org.springframework.amqp.core.Queue;
			import org.springframework.amqp.core.TopicExchange;
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;
			
			@Configuration
			public class MQConfig {
			//    @Bean
			//    public ConnectionFactory connectionFactory(){
			//        return new CachingConnectionFactory();
			//    }
			//
			//    @Bean
			//    public RabbitAdmin rabbitAdmin(){
			//        return new RabbitAdmin(connectionFactory());
			//    }
			
			/*
			 	@Bean
			    public ConnectionFactory connectionFactory(){
			        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
			      	if("生产环境"){
			          connectionFactory.set.....
			        } else {
			          ......
			        }
			        connectionFactory.setVirtualHost("/");
			        connectionFactory.setUsername("guest");
			        connectionFactory.setPassword("guest");
			        return connectionFactory;
			    }
			
			    @Bean
			    public RabbitAdmin rabbitAdmin(){
			        RabbitAdmin rabbitAdmin = new RabbitAdmin();
			        rabbitAdmin.setAutoStartup(true);
			        return new RabbitAdmin(connectionFactory());
			    }
			*/
			    
			    @Bean
			    public Exchange bootExchange(){
			        return new TopicExchange("BOOT-EXCHANGE-1", true, false);
			    }
			
			    @Bean
			    public Queue bootQueue(){
			        return new Queue("boot.queue1", true);
			    }
			}
			
		MQSender代码如下，包含发送消息以及添加 confirm 监听、添加 return 监听。
		如果消费端要设置为手工 ACK ，那么生产端发送消息的时候一定发送 correlationData ，
		并且全局唯一，用以唯一标识消息。
		
			import com.anqi.mq.bean.User;
			import org.springframework.amqp.core.Message;
			import org.springframework.amqp.core.MessageProperties;
			import org.springframework.amqp.rabbit.connection.CorrelationData;
			import org.springframework.amqp.rabbit.core.RabbitTemplate;
			import org.springframework.beans.factory.annotation.Autowired;
			import org.springframework.stereotype.Component;
			
			import java.util.Date;
			import java.util.Map;
			
			@Component
			public class MQSender {
			
			    @Autowired
			    private RabbitTemplate rabbitTemplate;
			
			    final RabbitTemplate.ConfirmCallback confirmCallback= new RabbitTemplate.ConfirmCallback() {
			
			        public void confirm(CorrelationData correlationData, boolean ack, String cause) {
			            System.out.println("correlationData: " + correlationData);
			            System.out.println("ack: " + ack);
			            if(!ack){
			                System.out.println("异常处理....");
			            }
			        }
			
			    };
			
			    final RabbitTemplate.ReturnCallback returnCallback = new RabbitTemplate.ReturnCallback() {
			
			        public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
			            System.out.println("return exchange: " + exchange + ", routingKey: "
			                    + routingKey + ", replyCode: " + replyCode + ", replyText: " + replyText);
			        }
			    };
			
			    //发送消息方法调用: 构建Message消息
			    public void send(Object message, Map<String, Object> properties) throws Exception {
			        MessageProperties mp = new MessageProperties();
			        //在生产环境中这里不用Message，而是使用 fastJson 等工具将对象转换为 json 格式发送
			        Message msg = new Message(message.toString().getBytes(),mp);
			        rabbitTemplate.setMandatory(true);
			        rabbitTemplate.setConfirmCallback(confirmCallback);
			        rabbitTemplate.setReturnCallback(returnCallback);
			        //id + 时间戳 全局唯一
			        CorrelationData correlationData = new CorrelationData("1234567890"+new Date());
			        rabbitTemplate.convertAndSend("BOOT-EXCHANGE-1", "boot.save", msg, correlationData);
			    }
			    //发送消息方法调用: 构建Message消息
			    public void sendUser(User user) throws Exception {
			        rabbitTemplate.setMandatory(true);
			        rabbitTemplate.setConfirmCallback(confirmCallback);
			        rabbitTemplate.setReturnCallback(returnCallback);
			        //id + 时间戳 全局唯一
			        CorrelationData correlationData = new CorrelationData("1234567890"+new Date());
			        rabbitTemplate.convertAndSend("BOOT-EXCHANGE-1", "boot.save", user, correlationData);
			    }
			}
		
		自定义类型的消息需要标注@Payload，类要实现序列化接口
		
			import com.anqi.mq.bean.User;
			import com.rabbitmq.client.Channel;
			import org.springframework.amqp.core.Message;
			import org.springframework.amqp.rabbit.annotation.*;
			import org.springframework.amqp.support.AmqpHeaders;
			import org.springframework.messaging.handler.annotation.Headers;
			import org.springframework.messaging.handler.annotation.Payload;
			import org.springframework.stereotype.Component;
			
			import java.io.IOException;
			import java.util.Map;
			
			
			@RabbitListener(
			        bindings = @QueueBinding(
			                value = @Queue(value = "boot.queue1", durable = "true"),
			                exchange = @Exchange(value = "BOOT-EXCHANGE-1", type = "topic", durable = "true", ignoreDeclarationExceptions = "true"),
			                key = "boot.*"
			        )
			)
			@Component
			public class MQReceiver {
			
			    @RabbitHandler
			    public void onMessage(Message message, Channel channel) throws IOException {
			
			        try {
			            Thread.sleep(5000);
			        } catch (InterruptedException e) {
			            e.printStackTrace();
			        }
			        long deliveryTag = message.getMessageProperties().getDeliveryTag();
			        //手工ack
			        channel.basicAck(deliveryTag,true);
			        System.out.println("receive--1: " + new String(message.getBody()));
			    }
			
			   @RabbitHandler
			    public void onUserMessage(@Payload User user, Channel channel, @Headers Map<String,Object> headers) throws IOException {
			
			        try {
			            Thread.sleep(5000);
			        } catch (InterruptedException e) {
			            e.printStackTrace();
			        }
			
			        long deliveryTag = (Long)headers.get(AmqpHeaders.DELIVERY_TAG);
			        //手工ack
			        channel.basicAck(deliveryTag,true);
			        System.out.println("receive--11: " + user.toString());
			    }
			}
			
		采用其他类型的消息转换器，我们可以对其进行设置SimpleMessageListenerContainer
		
			 @Bean
		    public SimpleMessageListenerContainer simpleMessageListenerContainer(){
		        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory());
		        container.setMessageConverter(new Jackson2JsonMessageConverter());
		        // 默认采用下面的这种转换器
		        // container.setMessageConverter(new SimpleMessageConverter());
		        return container;
		    }
    
    
	springboot集成rabbitmq商品秒杀业务实战（流量削峰）
	
			加入amqp的依赖: 
			 	<dependency>
		            <groupId>org.springframework.amqp</groupId>
		            <artifactId>spring-rabbit</artifactId>
		        </dependency>
		        
		    配置application.yml配置文件:
		    
		 		spring:
				  datasource:
				    driver-class-name: com.mysql.cj.jdbc.Driver
				    url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
				    username: root
				    password: 1234
				
				  rabbitmq:
				    host: 101.201.101.206
				    username: guest
				    password: guest
				    publisher-confirms: true  # 开启Rabbitmq发送消息确认机制，发送消息到队列并触发回调方法
				    publisher-returns: true
				    listener:
				      simple:
				        concurrency: 10 #消费者数量
				        max-concurrency: 10 #最大消费者数量
				        prefetch: 1 #限流（消费者每次从队列获取的消息数量）
				        auto-startup: true  #启动时自动启动容器
				        acknowledge-mode: manual #开启ACK手动确认模式
	 		
		RabbitConfig配置类
			
			被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。
			如果想在生成对象时完成某些初始化操作，而偏偏这些初始化操作又依赖于依赖注入，那么久无法在构造函数中实现。
			为此，可以使用@PostConstruct注解一个方法来完成初始化，@PostConstruct注解的方法将会在依赖注入完成后被自动调用。
			
			
			package com.aaa.springredis.controller;

			import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
			import org.springframework.amqp.rabbit.transaction.RabbitTransactionManager;
			import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
			import org.springframework.amqp.support.converter.MessageConverter;
			import org.springframework.context.annotation.Bean;
			import org.springframework.stereotype.Component;
			
			@Component
			public class RabbitConfig {
			
			    /**
			     * 定义消息转换实例 ，转化成 JSON传输
			     *
			     * @return Jackson2JsonMessageConverter
			     */
			    @Bean
			    public MessageConverter integrationEventMessageConverter() {
			        return new Jackson2JsonMessageConverter();
			    }
			
			    /**
			     * 配置启用rabbitmq事务
			     *
			     * @param connectionFactory connectionFactory
			     * @return RabbitTransactionManager
			     */
			    @Bean
			    public RabbitTransactionManager rabbitTransactionManager(CachingConnectionFactory connectionFactory) {
			        return new RabbitTransactionManager(connectionFactory);
			    }
			    
			    @Autowired
			    RabbitTemplate rabbitTemplate;
			
			    private static final Logger LOGGER = LoggerFactory.getLogger(RabbitController.class);
			
			
			    @PostConstruct
			    private void init(){
			    
			        /**
			         * 消息发送到交换器Exchange后触发回调。
			         * 使用该功能需要开启确认，spring-boot中配置如下：
			         * spring.rabbitmq.publisher-confirms = true
			         */
			         
				    rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
				        @Override
				        public void confirm(CorrelationData correlationData, boolean b, String s) {
				            if (b) {
				                System.out.println("消息已确认 cause:{"+s+"} - {"+correlationData+"}");
				            } else {
				                System.out.println("消息未确认 cause:{"+s+"} - {"+correlationData+"}");
				            }
				        }
				    });
				    
			        /**
			         * 通过实现ReturnCallback接口，
			         * 如果消息从交换器发送到对应队列失败时触发
			         * 比如根据发送消息时指定的routingKey找不到队列时会触发
			         * 使用该功能需要开启确认，spring-boot中配置如下：
			         * spring.rabbitmq.publisher-returns = true
			         */
			         
			        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {
			            @Override
			            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
			                LOGGER.error("消息被退回:{}", message);
			                LOGGER.error("消息使用的交换机:{}", exchange);
			                LOGGER.error("消息使用的路由键:{}", routingKey);
			                LOGGER.error("描述:{}", replyText);
			            }
			        });
			    }
			}
			
		发送消息到RabbitMQ中:
		
				@RequestMapping("/send")
		        @ResponseBody
		        public String send(Integer messge){
		                //第一个参数：交换机名字  第二个参数：Routing Key的值  第三个参数：传递的消息对象
		                rabbitTemplate.convertAndSend("test.direct","test",messge);
		                return "发送消息成功";
		        }
						
		从RabbitMQ中接收消息:
		
			 	@Autowired
			    RabbitController controller;
			
			    /**
			     * @RabbitListener 可以标注在类上面，需配合 @RabbitHandler 注解一起使用
			     * @RabbitListener 标注在类上面表示当有收到消息的时候，就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，
			     * 根据 MessageConverter 转换后的参数类型
			     *
			     * 使用 @Payload 和 @Headers 注解可以消息中的 body 与 headers 信息
			     *
			     * 通过 ACK 确认是否被正确接收，每个 Message 都要被确认（acknowledged），可以手动去 ACK 或自动 ACK
			     */
			     
			    @RabbitListener(queues = "test") //指定监听的队列名
			    public void receiver(@Payload Integer userId, @Headers Channel channel, Message message) throws IOException {
			        LOGGER.info("用户{}开始抢单", userId);
			        try {
			            //处理消息
			            controller.robbingProduct(userId);
						//确认消息已经消费成功
			            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
			        } catch (Exception e) {
			            LOGGER.error("消费处理异常:{} - {}", userId, e);
						//拒绝当前消息，并把消息返回原队列
			            channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);
			        }
			    }
					
				 public void robbingProduct(Integer userId){
	                Product product = testDao.selectProductByNo("No123321");
	                if (product != null && product.getTotal() > 0) {
	                    //更新库存表，库存量减少1。返回1说明更新成功。返回0说明库存已经为0
	                    int i = testDao.updateProduct("No123321");
	                    if(i>0){
	                        //插入记录
	                        testDao.insertProductRecord(new ProductRecord("No123321", userId));
	                        //发送短信
	                        LOGGER.info("用户{}抢单成功", userId);
	                    }else {
	                        LOGGER.error("用户{}抢单失败", userId);
	                    }
	                } else {
	                    LOGGER.error("用户{}抢单失败", userId);
	                }
		        }
								   
			
		
	
	Spring Boot + RabbitMQ 配置参数解释	
	
		★RabbitMQ
		★Version: 1.5.13.RELEASE
		
		★属性文件：org.springframework.boot.autoconfigure.amqp.RabbitProperties
		
		★Config:
		# base
		spring.rabbitmq.host: 服务Host
		spring.rabbitmq.port: 服务端口
		spring.rabbitmq.username: 登陆用户名
		spring.rabbitmq.password: 登陆密码
		spring.rabbitmq.virtual-host: 连接到rabbitMQ的vhost
		spring.rabbitmq.addresses: 指定client连接到的server的地址，多个以逗号分隔(优先取addresses，然后再取host)
		spring.rabbitmq.requested-heartbeat: 指定心跳超时，单位秒，0为不指定；默认60s
		spring.rabbitmq.publisher-confirms: 是否启用【发布确认】
		spring.rabbitmq.publisher-returns: 是否启用【发布返回】
		spring.rabbitmq.connection-timeout: 连接超时，单位毫秒，0表示无穷大，不超时
		spring.rabbitmq.parsed-addresses:
		
		
		# ssl
		spring.rabbitmq.ssl.enabled: 是否支持ssl
		spring.rabbitmq.ssl.key-store: 指定持有SSL certificate的key store的路径
		spring.rabbitmq.ssl.key-store-password: 指定访问key store的密码
		spring.rabbitmq.ssl.trust-store: 指定持有SSL certificates的Trust store
		spring.rabbitmq.ssl.trust-store-password: 指定访问trust store的密码
		spring.rabbitmq.ssl.algorithm: ssl使用的算法，例如，TLSv1.1
		
		
		# cache
		spring.rabbitmq.cache.channel.size: 缓存中保持的channel数量
		spring.rabbitmq.cache.channel.checkout-timeout: 当缓存数量被设置时，从缓存中获取一个channel的超时时间，单位毫秒；如果为0，则总是创建一个新channel
		spring.rabbitmq.cache.connection.size: 缓存的连接数，只有是CONNECTION模式时生效
		spring.rabbitmq.cache.connection.mode: 连接工厂缓存模式：CHANNEL 和 CONNECTION
		
		
		# listener
		spring.rabbitmq.listener.simple.auto-startup: 是否启动时自动启动容器
		spring.rabbitmq.listener.simple.acknowledge-mode: 表示消息确认方式，其有三种配置方式，分别是none、manual和auto；默认auto
		spring.rabbitmq.listener.simple.concurrency: 最小的消费者数量
		spring.rabbitmq.listener.simple.max-concurrency: 最大的消费者数量
		spring.rabbitmq.listener.simple.prefetch: 指定一个请求能处理多少个消息，如果有事务的话，必须大于等于transaction数量.
		spring.rabbitmq.listener.simple.transaction-size: 指定一个事务处理的消息数量，最好是小于等于prefetch的数量.
		spring.rabbitmq.listener.simple.default-requeue-rejected: 决定被拒绝的消息是否重新入队；默认是true（与参数acknowledge-mode有关系）
		spring.rabbitmq.listener.simple.idle-event-interval: 多少长时间发布空闲容器时间，单位毫秒
		
		spring.rabbitmq.listener.simple.retry.enabled: 监听重试是否可用
		spring.rabbitmq.listener.simple.retry.max-attempts: 最大重试次数
		spring.rabbitmq.listener.simple.retry.initial-interval: 第一次和第二次尝试发布或传递消息之间的间隔
		spring.rabbitmq.listener.simple.retry.multiplier: 应用于上一重试间隔的乘数
		spring.rabbitmq.listener.simple.retry.max-interval: 最大重试时间间隔
		spring.rabbitmq.listener.simple.retry.stateless: 重试是有状态or无状态
		
		
		# template
		spring.rabbitmq.template.mandatory: 启用强制信息；默认false
		spring.rabbitmq.template.receive-timeout: receive() 操作的超时时间
		spring.rabbitmq.template.reply-timeout: sendAndReceive() 操作的超时时间
		spring.rabbitmq.template.retry.enabled: 发送重试是否可用
		spring.rabbitmq.template.retry.max-attempts: 最大重试次数
		spring.rabbitmq.template.retry.initial-interval: 第一次和第二次尝试发布或传递消息之间的间隔
		spring.rabbitmq.template.retry.multiplier: 应用于上一重试间隔的乘数
		spring.rabbitmq.template.retry.max-interval: 最大重试时间间隔
		
	hutool工具类:	
			
		<dependency>
		    <groupId>cn.hutool</groupId>
		    <artifactId>hutool-all</artifactId>
		    <version>5.8.0.M3</version>
		</dependency>
		
		JSON处理:
		
			Animal animal1 = new Animal("black","big","cat");
			JSONObject jsonObject1 = JSONUtil.parseObj(animal1);
			
			Animal animal = JSONUtil.toBean( msg, Animal.class );
			
		日期时间处理:
		
			// 获取年份
			int year = DateUtil.year(new Date());
			
			// 获取今天日期 yyyy-MM-dd格式
			String today = DateUtil.today();
			
			// 获取生肖
			String chineseZodiac = DateUtil.getChineseZodiac(1990);
			
			// 将毫秒转成方便阅读的时间，如3小时25分23秒232毫秒
			String readableTime = DateUtil.formatBetween(12323232);
			
			// 转为农历日期
			ChineseDate chineseDate = new ChineseDate(new Date());
			// 农历年份，如2021
			final int chineseYear = chineseDate.getChineseYear();
			// 农历月份，如腊月
			final String chineseMonthName = chineseDate.getChineseMonthName();
			// 农历日期，如初三
			final String chineseDay = chineseDate.getChineseDay();
			
			// 方便地将Date转换为LocalDateTime
			final LocalDateTime localDateTime = LocalDateTimeUtil.of(new Date());
			
			// 获取一天开始时间
			LocalDateTimeUtil.beginOfDay(localDateTime);
			// 获取一天结束时间
			LocalDateTimeUtil.endOfDay(localDateTime);
			
		I/O流:
		
			// 从文件中获取缓冲流
			BufferedInputStream in = FileUtil.getInputStream("d:/test.txt");
			BufferedOutputStream out = FileUtil.getOutputStream("d:/test2.txt");
			
			// 拷贝文件
			IoUtil.copy(in, out);
			
		字符串处理:
		
			// 判断字符串是否为null或空串
			boolean isEmpty = StrUtil.isEmpty(str);
			
			// 判断字符串是否为null或空串或空白字符
			boolean isBlank = StrUtil.isBlank(str);
			
			// 将字符串用指定字符填充到指定长度
			String filled = StrUtil.fillAfter(str, '*', 10);
			
			// 填充字符串模板
			String format = StrUtil.format("a的值为{a}, b的值为{b}", Map.of("a", "aValue", "b", "bValue"));
			
			// 判断字符串是否为中文字符串
			boolean match = ReUtil.isMatch(ReUtil.RE_CHINESES, "中国人");
				
		集合框架:
		
			// 新建一个HashSet
			Set<Integer> hashSet = CollUtil.newHashSet(1, 2, 3);
			Set<Integer> linkedHashSet = CollUtil.newLinkedHashSet(4, 2, 3);
			
			// 两个集合取交集
			Collection<Integer> intersection = CollUtil.intersection(hashSet, linkedHashSet);
			
			// 两个集合取并集
			Collection<Integer> union = CollUtil.union(hashSet, linkedHashSet);
			
			// 两个集合取差集
			Collection<Integer> disjunction = CollUtil.disjunction(hashSet, linkedHashSet);
			
			// 判断一个集合是否为null或空集
			boolean empty = CollUtil.isEmpty(hashSet);
			
			// 创建一个ArrayList
			List<Integer> arrayList = ListUtil.toList(1, 2, 3);
			
			// 创建一个LinkedList
			List<Integer> linkedList = ListUtil.toLinkedList(1, 2, 3);
			
			// 创建一个map
			Map<String, Object> map = MapUtil.<String, Object>builder().put("a", 1).put("b", 2).build();		
				
		常见业务:
			身份证、社会信用代码、拼音操作、生成二维码、生成唯一ID等一些常见业务场景api。
			
			// 根据身份证号获取出生日期
			String birth = IdcardUtil.getBirthByIdCard(idCard);
			
			// 根据身份证号获取省份
			String province = IdcardUtil.getProvinceByIdCard(idCard);
			
			// 判断身份证号是否合法
			boolean valid = IdcardUtil.isValidCard18(idCard);
			
			// 获取一个随机的社会信用代码
			String creditCode = CreditCodeUtil.randomCreditCode();
			
			// 判断社会信用代码是否合法
			boolean isCreditCode = CreditCodeUtil.isCreditCode(creditCode);
			
			// 将汉字转为拼音，需要引入TinyPinyin、JPinyin或Pinyin4j的jar包
			String china = PinyinUtil.getPinyin("中国");
			
			// 将字符串生成为二维码，需要引入com.google.zxing.core的jar包
			BufferedImage qrCodeImage = QrCodeUtil.generate("www.baidu.com", QrConfig.create());
			ImageIO.write(qrCodeImage, "png", new File("a.png"));
			
			// 生成uuid
			String uuid = IdUtil.fastSimpleUUID();
			
			// 创建基于Twitter SnowFlake算法的唯一ID，适用于分布式系统
			final Snowflake snowflake = IdUtil.createSnowflake(1, 1);
			final long id = snowflake.nextId();		
			
		定时任务:
		
			// 添加新的定时任务
			final String scheduleId = CronUtil.schedule("*/2 * * * * *", (Task) () -> System.out.println("执行定时任务"));
			
			// 设置是否支持秒级别定时任务
			CronUtil.setMatchSecond(true);
			
			// 开启定时任务
			CronUtil.start();
			
		验证码:
		
			// 生成线段干扰的验证码
			LineCaptcha lineCaptcha = CaptchaUtil.createLineCaptcha(200, 100, 5, 3);
			lineCaptcha.write("/your/path/b.png");
			
			// 生成圆圈干扰的验证码
			CircleCaptcha captcha = CaptchaUtil.createCircleCaptcha(200, 100, 4, 20);
			captcha.write("/your/path/c.png");
			
			// 生成扭曲干扰的验证码
			ShearCaptcha shearCaptcha = CaptchaUtil.createShearCaptcha(200, 100, 4, 4);
			shearCaptcha.write("/your/path/d.png");	
			
		缓存:
		
			// 创建先进先出的缓存，并设置过期时间
			FIFOCache<String, Object> cache = CacheUtil.newFIFOCache(1000, 3600 * 1000);
			
			// 向缓存中添加元素
			cache.put("a", 1);
			
			// 从缓存中读取元素
			cache.get("a");
			
		Excel操作:
		
			// 将文件转换为ExcelReader
			ExcelReader reader = ExcelUtil.getReader("d:/aaa.xlsx");
			
			// 读取所有行和列的数据
			List<List<Object>> data = reader.read();
			
			// 读取为Map列表，默认excel第一行为标题行，Map中的key为标题，value为标题对应的单元格值。
			List<Map<String,Object>> dataMap = reader.readAll();
			
			//创建writer
			ExcelWriter writer = ExcelUtil.getWriter("d:/bbb.xlsx");
			
			// 数据量特别大时，使用BigExcelWriter对象，可以避免内存溢出
			ExcelWriter bigWriter = ExcelUtil.getBigWriter("d:/bbb.xlsx");
			
			// 构造数据
			List<String> row1 = CollUtil.newArrayList("aa", "bb", "cc", "dd");
			List<String> row2 = CollUtil.newArrayList("aa1", "bb1", "cc1", "dd1");
			List<String> row3 = CollUtil.newArrayList("aa2", "bb2", "cc2", "dd2");
			List<String> row4 = CollUtil.newArrayList("aa3", "bb3", "cc3", "dd3");
			List<String> row5 = CollUtil.newArrayList("aa4", "bb4", "cc4", "dd4");
			List<List<String>> rows = CollUtil.newArrayList(row1, row2, row3, row4, row5);
			
			// 一次性将数据写入excel中
			writer.write(rows, true);
			
		Http请求:
		
			Map<String, Object> params = MapUtil.<String, Object>builder().put("a", 1).build();
			// 发送get请求
			String getResult = HttpUtil.get("https://www.baidu.com", params);
			
			// 发送post请求
			String postResult = HttpUtil.post("https://www.baidu.com", params);
			
			// 以application/json方式发送post请求
			String jsonPostResult = HttpUtil.post("https://www.baidu.com", JSON.toJSONString(params));
			
			// 下载文件，提供生命周期钩子
			HttpUtil.downloadFile(fileUrl, FileUtil.file("e:/"), new StreamProgress() {
			    @Override
			    public void start() {
			        System.out.println("开始下载");
			    }
			
			    @Override
			    public void progress(long progressSize) {
			        System.out.println("下载中，已下载" + FileUtil.readableFileSize(progressSize));
			    }
			
			    @Override
			    public void finish() {
			        System.out.println("下载完成");
			    }
			});	
			
		加密:
		
			// md5摘要加密
			String md5 = SecureUtil.md5("abc");
			
			// sha1摘要加密
			String sha1 = SecureUtil.sha1("abc");
			
			// 生成非对称密钥对
			KeyPair keyPair = SecureUtil.generateKeyPair("RSA");
			String publicKey = Base64Encoder.encode(keyPair.getPublic().getEncoded());
			String privateKey = Base64Encoder.encode(keyPair.getPrivate().getEncoded());
			
			// 利用公钥加密
			String encryptBase64 = SecureUtil.rsa(privateKey, publicKey).encryptBase64("abc", KeyType.PublicKey);
			
			// 利用私钥解密
			String decrypt = new String(SecureUtil.rsa(privateKey, publicKey).decrypt(encryptBase64, KeyType.PrivateKey));
			
			// 创建签名对象
			Sign sign = SecureUtil.sign(SignAlgorithm.MD5withRSA);
			
			// 生成签名
			final byte[] bytes = "abc".getBytes();
			byte[] signed = sign.sign(bytes);
			
			// 验证签名
			boolean verify = sign.verify(bytes, signed);
			System.out.println(verify);	
			
						
	JPA:
		
	SpringBoot依赖循环如何解决
		方法五：最简单的方法：懒加载
			懒加载，在冲突的类注入时，加入@Lazy
			比如：UserService需要依赖OfficeService，OfficeService需要依赖UserService。直接在其一的依赖注入后面新增@Lazy注解。
			
			@Autowired
			@Lazy
			private UserService userService;
			
		也可以开启全局懒加载
		
			spring:
			  main:
			    lazy-initialization: true

	
	SpringBoot整合 JPA:
		pom.xml:
		
			<!-- springBoot的启动器 -->
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-data-jpa</artifactId>
			</dependency>
			
		application.properties:
		
			spring.jpa.hibernate.ddl-auto=update
			spring.jpa.show-sql=true
			
			
		Mapper:
			
			public interface UsersRepository extends JpaRepository<Users,Integer>{

			}
			
			@Service
			public class UsersServiceImpl implements UsersService {
			
				@Autowired
				private UsersRepository usersRepository;
				
				@Override
				public List<Users> findUserAll() {
					return this.usersRepository.findAll();
				}
			
				@Override
				//@Cacheable:对当前查询的对象做缓存处理
				@Cacheable(value="users")
				public Users findUserById(Integer id) {
					return this.usersRepository.findOne(id);
				}
			
				@Override
				public Page<Users> findUserByPage(Pageable pageable) {
					return this.usersRepository.findAll(pageable);
				}
			
				@Override
				public void saveUsers(Users users) {
					this.usersRepository.save(users);
				}
			}
				
Echarts中国地图三级钻取


	<!DOCTYPE html>
	<html>
	  <head>
	    <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width,initial-scale=1.0">
	    <title>Echarts 地图钻取</title>
	    <link rel="shortcut icon" href=./favicon.ico>
	    <link rel="stylesheet" href="./css/index.css" type="text/css">
	    <script type="text/javascript" src="./js/echarts.min.js"></script>
	    <script src="https://code.jquery.com/jquery-3.0.0.min.js"></script>
	    <script type="text/javascript" src="./js/index.js"></script>
	    <script type="text/javascript" src="./js/china-main-city-map.js"></script>
	    <script type="text/javascript" src="./js/rem.js"></script>
	  </head>
	  <body>
	
	    <div class='title'>Echarts中国地图三级钻取</div>
	    <div class="box">
	      <button class= "backBtn" onclick="back()">返回上级</button>
	      <div id="mapChart" class="chart"></div>
	    </div>
	
	  </body>
	  
	</html>




body{
    background-image: url('../asset/images/beijingtupian.png');
}

.title{

    width: 100%;
    height: 10vh;
    text-align: center;
    color:#fff;
    font-size: 2em;
    line-height: 10vh;
}
.box {

    position: absolute;
    width: 90%;
    height: 80vh;
    left:5%;
    top:10%;
    background-color:rgba(24,27,52,0.62);
}

.chart{
    position: relative;
    height: 90%;
    top:10%;
}
.backBtn{
    position: absolute;
    top:0;
    background-color: #00C298;
    border: 0;
    color:#fff;
    height: 27px;
    font-family: Microsoft Yahei;
    font-size: 1em;
    cursor: pointer;
}



$(function() {//dom加载后执行
    mapChart('mapChart')
})



/**
 * 根据Json里的数据构造Echarts地图所需要的数据
 * @param {} mapJson 
 */
function initMapData(mapJson){
    var mapData = [];
    for( var i=0;i<mapJson.features.length;i++ ){
        mapData.push({
            name:mapJson.features[i].properties.name,
            //id:mapJson.features[i].id
        })
    }
    return mapData;    
}

/**
 * 返回上一级地图
 */
function back(){
    if(mapStack.length!=0){//如果有上级目录则执行
        var map = mapStack.pop();
        $.get('./asset/json/map/'+map.mapId+'.json', function (mapJson,status) {
                
            registerAndsetOption(myChart,map.mapId,map.mapName,mapJson,false)

            //返回上一级后，父级的ID、Name随之改变
            parentId = map.mapId;
            parentName = map.mapName;
            
        })

    }
    
}
/**
 * Echarts地图
 */

//中国地图（第一级地图）的ID、Name、Json数据
 var chinaId = 100000;
 var chinaName = 'china'
 var chinaJson = null;
 
 //记录父级ID、Name
 var mapStack = [];
 var parentId = null;
 var parentName = null;

 //Echarts地图全局变量，主要是在返回上级地图的方法中会用到
 var myChart = null;
 function mapChart(divid){
   
    $.get('./asset/json/map/'+chinaId+'.json', function (mapJson) {
        chinaJson = mapJson;
        myChart = echarts.init(document.getElementById(divid));
        registerAndsetOption(myChart,chinaId,chinaName,mapJson,false)
        parentId = chinaId;
        parentName = 'china'
        myChart.on('click', function(param,t) {

            var cityId = cityMap[param.name]
            if(cityId){//代表有下级地图
                $.get('./asset/json/map/'+cityId+'.json', function (mapJson,status) {
                    registerAndsetOption(myChart,cityId,param.name,mapJson,true)
                })
            }else{
                //没有下级地图，回到一级中国地图，并将mapStack清空
                registerAndsetOption(myChart,chinaId,chinaName,chinaJson,false)
                mapStack=[]
                parentId = chinaId;
                parentName = chinaName;
                

            }
            // $.get('./asset/json/map/'+param.data.id+'.json', function (mapJson,status) {
               
            //     registerAndsetOption(myChart,param.data.id,param.name,mapJson,true)
        
            // }).fail(function () {
            //     registerAndsetOption(myChart,chinaId,'china',chinaJson,false)
            // });

        });
    
    
    })
}

/**
 * 
 * @param {*} myChart 
 * @param {*} id        省市县Id
 * @param {*} name      省市县名称
 * @param {*} mapJson   地图Json数据
 * @param {*} flag      是否往mapStack里添加parentId，parentName
 */
function registerAndsetOption(myChart,id,name,mapJson,flag)
{
    
    echarts.registerMap(name, mapJson);
    myChart.setOption({
        series: [{
            type: 'map',
            map: name,
            itemStyle: {
                normal: {
                    areaColor: 'rgba(23, 27, 57,0)',
                    borderColor: '#1dc199',
                    borderWidth: 1,
                },
            },
            data:initMapData(mapJson)
        }]
    });

    if(flag){//往mapStack里添加parentId，parentName,返回上一级使用
        mapStack.push({
            mapId: parentId,
            mapName: parentName
        }); 
        parentId = id;
        parentName = name;
    }
}








		Whose handbag is it?
			是谁的手提包？
		Excuse me?
			请问
		Whose handbag is it?
			是谁的手提包？
		Is this you handbag?
			是你的手提包？
		Yes it is
			是的
		pardon
			请再说一遍
		Thank you very much.
			非常感谢
		This is my handbag
			这是我的手提包
		
		Does the man get his umbrella back?
			那个男的拿到了他的雨伞吗？
		My coat and my umbrella please
			我的大衣和雨伞
		cloakroom
			衣帽间
		Here is my ticket
			这是我的票
		Tickets please
			请出示你的票
		A cup of coffee please
			请来一杯咖啡
		Here's you umbrella and you coat
			这是你的雨伞和大衣
		Number five
			5号
		Class Two
			二班
		Room 103
			103房间
		This isn't(is not) my umbrella
			这不是我的雨伞
		Is this it?
			这是你的?
		No, it isn't
			这不是
		suit
		男士西装
		
		Is 谢思宁 Chinese?
			谢思宁是中国人？
		Good	morning
			早上好
		谢思宁 is a new student
			谢思宁是新同学
		谢思宁 is French
			谢思宁是法国人
		Nice to meet you/Glad to meet you/Pleased to meet you
			很高兴见到你
		Good afternoon
			上午好
		Good evening
			晚上好
		Good night
			晚安
		This is 谢思宁
			这是谢思宁
		He/She/It is a ...
			他/她/它是
		
		What make is it?
			它是什么牌子的？
		Is it a French car?
			这是法国车？
		
		What's 谢思宁's job?
			谢思宁的工作是什么？
		Are you a teacher/French?
			你是老师/法国人？
		I am a new student
			我是新同学
		My name is 谢思宁
			我的名字是谢思宁
		What's your name？
			你的名字是？
		What nationality are you?/What's you nationality?/Where are you from?
			你是哪国人?
		I'm French
			我是法国人
		What nationality is he?
			他是哪国人？
		
		How are you today?/How are you doing/What's new
			你今天怎么样？
		How is 谢思宁?
			谢思宁身体怎么样?
		Goodbye/See you / Bye
			再见
		Nice to see you
			见到你真好
		I'm very	well
			我非常好
		Look at that man
			看那个男人
		Is he fat?
			他是胖的
		Is that mechanic clean or dirty?
			机械修理师是干净还是脏的？
		That milkman is old
			送牛奶的人是个老人
		
		Whose shirt is white?
			谁的衬衫是白色的？
		Is	this you shirt?
			这是你的衬衫
		Here you are./Here it is
			给你
		Whose shirt is that?/Whose is that shirt?
			那个男士衬衫是谁的?
		Perhaps it is
			也许是我的
		Whose is this ...？
		It's...
		This is my/your/his/her
		Is this blouse your	mother's?
			这个女士衬衫是你妈的?
		
		What colour's Anna's hat？
			Anna的帽子是什么颜色的？
		A new dress
			新的连衣裙
		Come upstairs and see it
			上楼看看
		Come and help me
			来帮帮我
		Come and clean the table
			来搽桌子
		It's the same colour
			统一颜色
		That is a lovely hat!
			可爱的的帽子
		What colour's your ...?
			你的...什么颜色?
		It's ...
			它是...
		
		Is there a problem with the Customs officer?
			海关官员有什么疑问?
		Are you tourists?
			你是旅游者?




can you do me a favour?
can i ask a favour?





自增自减运算符:
	++:	变量值+1
	--: 变量值-1

 	++/--在变量前面,先做++/--,再进行操作;
 	++/--在变量后面,先做操作,再进行++/--;
 	
 参与操作使用:
 	(1):
	 	int i = 10;
	 	int j = i++;
	 	j = 10,i=11;
 	(2):
 		int i = 10;
	 	int j = ++i;
	 	j = 11,i=11;
 	 
关系运行符:
	==	:等于
		a == b
		
	!=	:不等于
		a != b
		
	>	:大于
		a > b
		
	>=	:大于等于
		a >= b
		
	<	:小于
		a < b
		
	<=	:小于等于
		a <= b
	

逻辑运算符:

	&:
		逻辑与
		
	|：
		逻辑或
		
	^:
		逻辑异或

	!:
		逻辑非
		
		
一、基础配置

<project xmlns="http://maven.apache.org/POM/4.0.0"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/xsd/maven-4.0.0.xsd">
<!-- 模型版本。maven2.0必须是这样写，现在是maven2唯一支持的版本 -->
<modelVersion>4.0.0</modelVersion>

<!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如 cn.edu.ouc，maven 
	会将该项目打成的 jar 包放本地路径：/cn/edu/ouc -->
<groupId>cn.edu.ouc</groupId>
<!-- 本项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 -->
<artifactId>pom-learning</artifactId>
<!-- 本项目目前所处的版本号 -->
<version>1.0.0-SNAPSHOT</version>
<!-- 打包的机制，如 pom、jar、maven-plugin、ejb、war、ear、rar和par，默认为jar -->
<packaging>jar</packaging>

<!-- < parent> 用于引用父工程，统一管理默认配置以及 jar 包的版本，其依赖需要在子工程中定义才有效。 -->
<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactId>
	<version>2.4.3</version>
</parent>

<!-- 帮助定义构件输出的一些附属构件,附属构件与主构件对应，有时候需要加上classifier才能唯一的确定该构件 
	不能直接定义项目的classifer,因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成的 -->
<classifier>...</classifier>

<!-- 为 pom 定义一些常量，在 pom 中的其它地方可以直接引用这些变量。使用方式如下：${file.encoding} -->
<properties>
	<file.encoding>UTF-8</file.encoding>
	<java.source.version>1.5</java.source.version>
	<java.target.version>1.5</java.target.version>
</properties>

<!-- 定义本项目的依赖关系 -->
<dependencies>
	<!-- 每个dependency都对应这一个jar包 -->
	<dependency>
		<!--一般情况下，maven是通过groupId、artifactId、version这三个元素值（俗称坐标）来检索该构件， 
			然后引入你的工程。如果别人想引用你现在开发的这个项目（前提是已开发完毕并发布到了远程仓库）， -->
		<!--就需要在他的pom文件中新建一个dependency节点，将本项目的groupId、artifactId、version写入， 
			maven就会把你上传的jar包下载到他的本地 -->
		<groupId>org.springframework</groupId>
		<artifactId>spring-webmvc</artifactId>
		<version>5.1.5.RELEASE</version>
		<!-- maven认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化，所以maven中的依赖关系有作用域(scope)的限制。 -->
		<!--scope包含如下的取值：compile（编译范围）、provided（已提供范围）、runtime（运行时范围）、test（测试范围）、system（系统范围） -->
		<scope>test</scope>
		<!-- 设置子项目是否默认继承该依赖：默认为 false，即子项目默认都继承，子项目不需要显示的引入；若为 
			true 则子项目必需显示的引入，与dependencyManagement里定义的依赖类似 -->
		<optional>false</optional>
		<!-- 屏蔽依赖关系，使其不起作用。比如项目中使用的libA依赖某个库的1.0版，libB依赖某个库的2.0版，现在想统一使用2.0版，就应该屏蔽掉对1.0版的依赖 -->
			<exclusions>
				<exclusion>
					<groupId>org.slf4j</groupId>
					<artifactId>slf4j-api</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
	</dependencies>
	...
</project>



● 编码格式，在pom.xml中加入如下配置：

<properties>
	<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
</properties>


● Java版本的配置很简单，添加一个plugin即可：

<plugin>
	<groupId>org.apache.maven.plugins</groupId>
	<artifactId>maven-compiler-plugin</artifactId>
	<version>3.8.1</version>
	<configuration>
		<source>1.8</source>
		<target>1.8</target>
	</configuration>
</plugin>


2）使用自定义 parent


对于依赖版本，我们可以定义
<dependencyManagement>
	节点，
	然后在里面定义好版本号，接下来引用依赖时也就不用写版本号了，像下面这样：

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-parent</artifactId>
				<version>2.3.1.RELEASE</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>



	二、构建配置:
	<build>

		<!-- 产生的构建的文件名，默认值是 ${artifactId}-${version} -->
	<finalName>myPorjectName</finalName>

	<!-- 构建产生的所有文件存放的目录，默认为 ${basedir}/target，即项目根目录下的 
		target -->
	<directory>${basedir}/target</directory>

	<!--当项目没有规定目标（Maven2叫做阶段（phase））时的默认值 -->
	<!--必须跟命令行上的参数相同例如jar:jar，或者与某个阶段（phase）相同例如install、compile等 -->
	<defaultGoal>install</defaultGoal>

	<!--当 filtering 开关打开时，使用到的过滤器属性文件列表。 -->
	<!--项目配置信息中诸如 ${spring.version} 之类的占位符会被属性文件中的实际值替换掉 -->
	<filters>
		<filter>../filter.properties</filter>
	</filters>

	<!--项目相关的所有资源路径列表，例如和项目相关的配置文件、属性文件，这些资源被包含在最终的打包文件里。 -->
	<resources>

		<resource>
			<!--描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。 -->
			<!--举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。 -->
			<!--然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 -->
			<targetPath>resources</targetPath>
			<!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 -->
			<filtering>true</filtering>
			<!--描述存放资源的目录，该路径相对POM路径 -->
			<directory>src/main/resources</directory>

			<!--要被打包的资源列表 -->
			<includes>
				<include>
					**/*.properties
				</include>
				<include>
					**/*.xml
				</include>
			</includes>

			<!--排除的资源列表，这些资源不会被打包。如果<include>与<exclude>划定的范围存在冲突，以<exclude>为准 -->
			<excludes>
				<exclude>jdbc.properties</exclude>
			</excludes>

		</resource>
	</resources>

	<!--单元测试需要用到的的所有资源路径，配置方法与resources类似 -->
	<testResources>
		<testResource>
			<targetPath />
			<filtering />
			<directory />
			<includes />
			<excludes />
		</testResource>
	</testResources>

	<!--项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 -->
	<sourceDirectory>${basedir}\src\main\java</sourceDirectory>

	<!--项目脚本源码目录，该目录和源码目录不同，绝大多数情况下，该目录下的内容会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 -->
	<scriptSourceDirectory>${basedir}\src\main\scripts
	</scriptSourceDirectory>

	<!--项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 -->
	<testSourceDirectory>${basedir}\src\test\java</testSourceDirectory>

	<!--被编译过的应用程序class文件存放的目录。 -->
	<outputDirectory>${basedir}\target\classes</outputDirectory>

	<!--被编译过的测试class文件存放的目录。 -->
	<testOutputDirectory>${basedir}\target\test-classes</testOutputDirectory>

	<!--项目的一系列构建扩展，它们是一系列build过程中要使用的产品，会包含在running bulid's 
		classpath里面。 -->
	<!--他们可以开启extensions，也可以通过提供条件来激活plugins。 -->
	<!--简单来讲，extensions是在build过程被激活的产品 -->
	<extensions>

		<!--例如，通常情况下，程序开发完成后部署到线上Linux服务器，可能需要经历打包、将包文件传到服务器、SSH连上服务器、敲命令启动程序等一系列繁琐的步骤。 -->
		<!--实际上这些步骤都可以通过Maven的一个插件 wagon-maven-plugin 来自动完成 -->
		<!--下面的扩展插件wagon-ssh用于通过SSH的方式连接远程服务器， -->
		<!--类似的还有支持ftp方式的wagon-ftp插件 -->
		<extension>
			<groupId>org.apache.maven.wagon</groupId>
			<artifactId>wagon-ssh</artifactId>
			<version>2.8</version>
		</extension>

	</extensions>

	<!--使用的插件列表 。 -->
	<plugins>
		<plugin>
			<groupId></groupId>
			<artifactId>maven-assembly-plugin</artifactId>
			<version>2.5.5</version>

			<!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 -->
			<executions>
				<execution>

					<!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 -->
					<id>assembly</id>

					<!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 -->
					<phase>package</phase>

					<!--配置的执行目标 -->
					<goals>
						<goal>single</goal>
					</goals>

					<!--配置是否被传播到子POM -->
					<inherited>false</inherited>

				</execution>
			</executions>

			<!--作为DOM对象的配置,配置项因插件而异 -->
			<configuration>
				<finalName>${finalName}</finalName>
				<appendAssemblyId>false</appendAssemblyId>
				<descriptor>assembly.xml</descriptor>
			</configuration>

			<!--是否从该插件下载Maven扩展（例如打包和类型处理器）， -->
			<!--由于性能原因，只有在真需要下载时，该元素才被设置成true。 -->
			<extensions>false</extensions>

			<!--项目引入插件所需要的额外依赖 -->
			<dependencies>
				<dependency>...</dependency>
			</dependencies>

			<!--任何配置是否被传播到子项目 -->
			<inherited>true</inherited>

		</plugin>
	</plugins>

	<!--主要定义插件的共同元素、扩展元素集合，类似于dependencyManagement， -->
	<!--所有继承于此项目的子项目都能使用。该插件配置项直到被引用时才会被解析或绑定到生命周期。 -->
	<!--给定插件的任何本地配置都会覆盖这里的配置 -->
	<pluginManagement>
		<plugins>...</plugins>
	</pluginManagement>
</build>



Spring SLF4J
	<dependencies>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-core</artifactId>
			<version>4.0.1.RELEASE</version>
			<exclusions>
				<exclusion>
					<groupId>commons-logging</groupId>
					<artifactId>commons-logging</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>jcl-over-slf4j</artifactId>
			<version>1.5.8</version>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
			<version>1.5.8</version>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-log4j12</artifactId>
			<version>1.5.8</version>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
			<version>1.2.14</version>
		</dependency>
	</dependencies>

Spring Log4j
	<dependencies>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-core</artifactId>
			<version>4.0.1.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
			<version>1.2.14</version>
		</dependency>
	</dependencies>

	log4j.properties
	log4j.rootCategory=INFO, stdout
	log4j.appender.stdout=org.apache.log4j.ConsoleAppender
	log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
	log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE}
	%5p %t %c{2}:%L - %m%n
	log4j.category.org.springframework.beans.factory=DEBUG



SpringSecurity使用权限编码控制权限
	
	@Component
	public class CustomPermissionEvaluator implements PermissionEvaluator {
		@Override
		public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {
			User user= (User) authentication.getPrincipal();
			PathMatcher pathMatcher = new AntPathMatcher();
			List<Permission> permissions = user.getPermissions();
			for(Permission permission1:permissions){
				if(pathMatcher.match(targetDomainObject.toString(),permission1.getUrl()) && !"".equals(permission1.getPmod())){
					List<String> pmods = Arrays.asList(permission1.getPmod().trim().split(","));
					List<String> perPmods = Arrays.asList(permission.toString().trim().split(","));
					for(String perPmod:perPmods){
						if(pmods.contains(perPmod)){
							return true;
						}
					}
				}
			}
			return false;
		}
		@Override
		public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) {
			return true;
		}
	}
	
	@Bean
	public DefaultWebSecurityExpressionHandler defaultWebSecurityExpressionHandler(){
		DefaultWebSecurityExpressionHandler handler=new DefaultWebSecurityExpressionHandler();
		handler.setPermissionEvaluator(customPermissionEvaluator);
		return handler;
	}



SpringSecurity授权过程:
	FilterSecurityInterceptor
        doFilter()->invoke()
           ->AbstractSecurityInterceptor
                  beforeInvocation()
                       ->SecurityMetadataSource(FilterInvocationSecurityMetadataSource ) 获取ConfigAttribute属性信息（从数据库或者其他数据源地方）
                             getAttributes()
                             ->AccessDecisionManager()(AccessDecisionManager )  基于AccessDecisionVoter实现授权访问
                                   Decide()
                                   ->AccessDecisionVoter  受AccessDecisionManager委托实现授权访问
                                               vote()

基于JDBC的动态角色判断:
 @Component
 public class MyFilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter {
     
     private FilterInvocationSecurityMetadataSource securityMetadataSource;
 
 
     @Override
     public void init(FilterConfig filterConfig) throws ServletException {
 
     }
 
     @Override
     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
         FilterInvocation fi = new FilterInvocation(request, response, chain);
         invoke(fi);
     }
 
     private void invoke(FilterInvocation fi) throws IOException, ServletException {
         //fi里面有一个被拦截的url
         //里面调用MyInvocationSecurityMetadataSource的getAttributes(Object object)这个方法获取fi对应的所有权限
         //再调用MyAccessDecisionManager的decide方法来校验用户的权限是否足够
         InterceptorStatusToken token = super.beforeInvocation(fi);
         try {
             //执行下一个拦截器
             fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
         } finally {
             super.afterInvocation(token, null);
         }
     }
 
     @Override
     public void destroy() {
 
     }
 
     @Override
     public Class<?> getSecureObjectClass() {
         return null;
     }
 
     @Override
     public SecurityMetadataSource obtainSecurityMetadataSource() {
         return this.securityMetadataSource;
     }
 
     public FilterInvocationSecurityMetadataSource getSecurityMetadataSource() {
         return this.securityMetadataSource;
     }
 
     //设置自定义的FilterInvocationSecurityMetadataSource
     @Autowired
     public void setSecurityMetadataSource(MyFilterInvocationSecurityMetadataSource messageSource) {
         this.securityMetadataSource = messageSource;
     }
 
     //设置自定义的AccessDecisionManager
     @Override
     @Autowired
     public void setAccessDecisionManager(AccessDecisionManager accessDecisionManager) {
         super.setAccessDecisionManager(accessDecisionManager);
     }
  }

@Component
public class MyFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {
	
	@Autowired
	private SysResourceDao sysResourceDao;

	private Map<String, Collection<ConfigAttribute>> configAttubuteMap = null;
	

	/*	
	 * insert into sys_resource values(1,"ROLE_ADMIN","user","res/query",null);
     *加载表中所有权限
     */
	private void loadResourceDefine() {
	    //todo 加载数据库的所有权限
		configAttubuteMap	= new HashMap();
	    Collection<ConfigAttribute> attributes;
		ConfigAttribute cfg;
		List<Map<String,String>>res = sysResourceDao.findAll();
		for(Map<String,String> re:res){
			array = new ArrayList<>();
			cfg = new ConfigAttribute(re.get("name"));
			array.add(cfg);
			map.put(re.get("url"),array);
		}
	}

	@Override
	public Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException {
	    AntPathRequestMatcher matcher;
	    String resUrl;
	    HttpServletRequest request = ((FilterInvocation) object).getRequest();
	    //1.加载权限资源数据
	    if (configAttubuteMap == null) {
	        loadResourceDefine();
	    }
	    Iterator<String> iterator = configAttubuteMap.keySet().iterator();
	    while (iterator.hasNext()) {
	        resUrl = iterator.next();
	        matcher = new AntPathRequestMatcher(resUrl);
	        if (matcher.matches(request)) {
	            return configAttubuteMap.get(resUrl);
	        }
	    }
	    return null;
	}

	@Override
	public Collection<ConfigAttribute> getAllConfigAttributes() {
	        return null;
	}

	@Override
	public boolean supports(Class<?> clazz) {
        return FilterInvocation.class.isAssignableFrom(clazz);
    }
}


 @Component
 public class MyAccessDecisionManager implements AccessDecisionManager {
    @Override
    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {
        ConfigAttribute c;
        String needRole;
        if(null== configAttributes || configAttributes.size() <=0) {
            return;
        }
        //1.获取已定义的好资源权限配置
        Iterator<ConfigAttribute> iterable=configAttributes.iterator();
        while (iterable.hasNext()){
            c=iterable.next();
            needRole=c.getAttribute();
            //2.依次比对用户角色对应的资源权限
            for (GrantedAuthority grantedAuthority:authentication.getAuthorities()){
                if(needRole.trim().equals(grantedAuthority.getAuthority())){
                    return;
                }
            }
        }
		throw new AccessDeniedException("无权限访问");
    }

    @Override
    public boolean supports(ConfigAttribute attribute) {
        return true;
    }

    @Override
    public boolean supports(Class<?> clazz) {
        return true;
    } 
}

    protected void configure(HttpSecurity http) throws Exception {
       http.headers().frameOptions().disable().and()
           //表单登录
           .formLogin()
           .loginPage(SecurityConstants.APP_FORM_LOGIN_PAGE)
           .loginProcessingUrl(SecurityConstants.APP_FORM_LOGIN_URL)
           .successHandler(authenticationSuccessHandler())
           .failureHandler(authenticationFailureHandler())
           .and()
           //应用sms认证配置
           .apply(smsAuthenticationSecurityConfig)
           .and()
           //允许通过
           .authorizeRequests()
           .antMatchers(SecurityConstants.APP_MOBILE_VERIFY_CODE_URL,
                        SecurityConstants.APP_USER_REGISTER_URL,
                       SecurityConstants.APP_FORM_LOGIN_INDEX_URL)
           .permitAll()//以上的请求都不需要认证
           .and()
           //“记住我”配置
           .rememberMe()
           .tokenRepository(jdbcTokenRepository())//token入库处理类
           .tokenValiditySeconds(SecurityConstants.REMEMBER_ME_VERIFY_TIME)//remember-me有效时间设置
           .rememberMeParameter(SecurityConstants.REMEMBER_ME_PARAM_NAME)//请求参数名设置
           .and()
           .csrf().disable();
        //增加自定义权限授权拦截器
        http.addFilterBefore(myFilterSecurityInterceptor,FilterSecurityInterceptor.class);
  }



基于JDBC的动态权限控制:

	(1):
		FilterSecurityInterceptor拦截器拦截请求，

	(2):
		FilterInvocationSecurityMetadataSource:
		获取当前请求url对应的权限

	(3):
		AccessDecisionManager:
		校验用户的权限是否足够

	(4):
		AccessDecisionVoter:

sql:
		
		SET NAMES utf8mb4;
		SET FOREIGN_KEY_CHECKS = 0;

		-- ----------------------------
		-- Table structure for sys_permission 权限表
		-- ----------------------------
		DROP TABLE IF EXISTS `sys_permission`;
		
		CREATE TABLE `sys_permission` (
			`id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键id',
			`permission_code` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限code',
			`permission_name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限名',
			 PRIMARY KEY (`id`) USING BTREE
		) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET
		= utf8 COLLATE = utf8_general_ci COMMENT = '权限表'
		ROW_FORMAT = Dynamic;

		-- ----------------------------
		-- Records of sys_permission 权限表数据
		-- ----------------------------
		INSERT INTO `sys_permission` VALUES (1, 'create_user','创建用户');
		INSERT INTO `sys_permission` VALUES (2, 'query_user','查看用户');
		INSERT INTO `sys_permission` VALUES (3, 'delete_user','删除用户');
		INSERT INTO `sys_permission` VALUES (4, 'modify_user','修改用户');

		-- ----------------------------
		-- Table structure for sys_request_path 路径表
		-- ----------------------------
		DROP TABLE IF EXISTS `sys_request_path`;
		
		CREATE TABLE `sys_request_path` (
			`id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键id',
			`url` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '请求路径',
			`description` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '路径描述',
			PRIMARY KEY (`id`) USING BTREE
		) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '请求路径' ROW_FORMAT = Dynamic;

		-- ----------------------------
		-- Records of sys_request_path 路径表数据
		-- ----------------------------
		
		INSERT INTO `sys_request_path` VALUES (1, '/getUser','查询用户');

		-- ----------------------------
		-- Table structure for
		sys_request_path_permission_relation 权限路径中间表
		-- ----------------------------
		
		DROP TABLE IF EXISTS `sys_request_path_permission_relation`;
		
		CREATE TABLE `sys_request_path_permission_relation` (
			`id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键id',
			`url_id` int(0) NULL DEFAULT NULL COMMENT '请求路径id',
			`permission_id` int(0) NULL DEFAULT NULL COMMENT '权限id',
			 PRIMARY KEY (`id`) USING BTREE
		) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT ='路径权限关联表' ROW_FORMAT = Dynamic;

		-- ----------------------------
		-- Records of sys_request_path_permission_relation
		权限路径中间表数据
		-- ----------------------------
		
		INSERT INTO `sys_request_path_permission_relation` VALUES (1, 1, 2);

		-- ----------------------------
		-- Table structure for sys_role 角色表
		-- ----------------------------
		DROP TABLE IF EXISTS `sys_role`;
		
		CREATE TABLE `sys_role` (
			`id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键id',
			`role_code` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
			`role_name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '角色名',
			`role_description` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '角色说明',
			PRIMARY KEY (`id`) USING BTREE
		) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户角色表' ROW_FORMAT = Dynamic;

		-- ----------------------------
		-- Records of sys_role 角色表数据
		-- ----------------------------
		
		INSERT INTO `sys_role` VALUES (1, 'admin', '管理员','管理员，拥有所有权限');
		INSERT INTO `sys_role` VALUES (2, 'user', '普通用户','普通用户，拥有部分权限');

		-- ----------------------------
		-- Table structure for sys_role_permission_relation
		角色权限中间表
		-- ----------------------------
		
		DROP TABLE IF EXISTS `sys_role_permission_relation`;
		
		CREATE TABLE `sys_role_permission_relation` (
			`id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键id',
			`role_id` int(0) NULL DEFAULT NULL COMMENT '角色id',
			`permission_id` int(0) NULL DEFAULT NULL COMMENT '权限id',
			PRIMARY KEY (`id`) USING BTREE
		) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT ='角色-权限关联关系表' ROW_FORMAT = Dynamic;

		-- ----------------------------
		-- Records of sys_role_permission_relation 角色权限中间表数据
		-- ----------------------------
		
		INSERT INTO `sys_role_permission_relation` VALUES (1, 1,1);
		INSERT INTO `sys_role_permission_relation` VALUES (2, 1,2);
		INSERT INTO `sys_role_permission_relation` VALUES (3, 1,3);
		INSERT INTO `sys_role_permission_relation` VALUES (4, 1,4);
		INSERT INTO `sys_role_permission_relation` VALUES (5, 2,1);
		INSERT INTO `sys_role_permission_relation` VALUES (6, 2,2);

		-- ----------------------------
		-- Table structure for sys_user 用户表
		-- ----------------------------
		DROP TABLE IF EXISTS `sys_user`;
		CREATE TABLE `sys_user` (
			`id` int(0) NOT NULL AUTO_INCREMENT,
			`account` varchar(32) CHARACTER SET utf8 COLLATE
			utf8_general_ci NOT NULL COMMENT '账号',
			`user_name` varchar(32) CHARACTER SET utf8 COLLATE
			utf8_general_ci NOT NULL COMMENT '用户名',
			`password` varchar(64) CHARACTER SET utf8 COLLATE
			utf8_general_ci NULL DEFAULT NULL COMMENT '用户密码',
			`last_login_time` datetime(0) NULL DEFAULT NULL
			COMMENT '上一次登录时间',
			`enabled` tinyint(1) NULL DEFAULT 1 COMMENT
			'账号是否可用。默认为1（可用）',
			`account_non_expired` tinyint(1) NULL DEFAULT 1 COMMENT
			'是否过期。默认为1（没有过期）',
			`account_non_locked` tinyint(1) NULL DEFAULT 1 COMMENT
			'账号是否锁定。默认为1（没有锁定）',
			`credentials_non_expired` tinyint(1) NULL DEFAULT 1 COMMENT
			'证书（密码）是否过期。默认为1（没有过期）',
			`create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
			`update_time` datetime(0) NULL DEFAULT NULL
			COMMENT '修改时间',
			`create_user` int(0) NULL DEFAULT NULL COMMENT '创建人',
			`update_user` int(0) NULL DEFAULT NULL COMMENT
			'修改人',
			PRIMARY KEY (`id`) USING BTREE
		) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET
		= utf8 COLLATE = utf8_general_ci COMMENT = '用户表'
		ROW_FORMAT = Dynamic;

		-- ----------------------------
		-- Records of sys_user 用户表数据
		-- ----------------------------
		
		INSERT INTO `sys_user` VALUES (1, 'user1', '用户1','$2a$10$47lsFAUlWixWG17Ca3M/r.EPJVIb7Tv26ZaxhzqN65nXVcAhHQM4i','2019-09-04 20:25:36', 1, 1, 1, 1, '2019-08-29 06:28:36', '2019-09-04 20:25:36', 1, 1);
		INSERT INTO `sys_user` VALUES (2, 'user2', '用户2',
		'$2a$10$uSLAeON6HWrPbPCtyqPRj.hvZfeM.tiVDZm24/gRqm4opVze1cVvC','2019-09-05 00:07:12', 1, 1, 1, 1, '2019-08-29 06:29:24', '2019-09-05 00:07:12', 1, 2);

		-- ----------------------------
		-- Table structure for sys_user_role_relation
		用户角色中间表
		-- ----------------------------
		
		DROP TABLE IF EXISTS `sys_user_role_relation`;
		
		CREATE TABLE `sys_user_role_relation` (
			`id` int(0) NOT NULL AUTO_INCREMENT COMMENT '主键id',
			`user_id` int(0) NULL DEFAULT NULL COMMENT '用户id',
			`role_id` int(0) NULL DEFAULT NULL COMMENT '角色id',
			PRIMARY KEY (`id`) USING BTREE
		) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET
		= utf8 COLLATE = utf8_general_ci COMMENT =
		'用户角色关联关系表' ROW_FORMAT = Dynamic;

		-- ----------------------------
		-- Records of sys_user_role_relation 用户角色中间表数据
		-- ----------------------------
		
		INSERT INTO `sys_user_role_relation` VALUES (1, 1, 1);
		INSERT INTO `sys_user_role_relation` VALUES (2, 2,2);

		SET FOREIGN_KEY_CHECKS = 1;


		/**
		* 用户表
		*/
		@Data
		public class SysUser {

			private String id;
	
			private String account; //账号
	
			private String userName; //用户名
	
			private String password; //密码
	
			private String lastLoginTime;//上一次登录时间
	
			private boolean enabled;//账号是否可用。默认为1（可用）
	
			private boolean accountNonExpired;//是否过期。默认为1（没有过期）
	
			private boolean
			accountNonLocked;//账号是否锁定。默认为1（没有锁定）
	
			private boolean
			credentialsNonExpired;//证书（密码）是否过期。默认为1（没有过期）
	
			private String createTime;//创建时间
	
			private String updateTime;//修改时间
	
			private String createUser;//创建人
	
			private String updateUser;//修改人

		}

		/**
		* 角色表
		*/
		@Data
		public class SysRole {

			private long id;
	
			private String roleCode;
	
			private String roleName;//角色名
	
			private String roleDescription;//角色说明

		}

		/**
		* 权限表
		*/
		@Data
		public class SysPermission {

			private long id;
	
			private String permissionCode; //权限code
	
			private String permissionName; // 权限名
			
		}

	@Component
	public class CustomizeAbstractSecurityInterceptor extends AbstractSecurityInterceptor implements Filter {

		@Autowired
		private FilterInvocationSecurityMetadataSource securityMetadataSource;

		@Autowired
		public void setMyAccessDecisionManager(CustomizeAccessDecisionManager accessDecisionManager) {
			super.setAccessDecisionManager(accessDecisionManager);
		}

		@Override
		public Class<?> getSecureObjectClass() {
        	return FilterInvocation.class;
    	}

    	@Override
    	public SecurityMetadataSource obtainSecurityMetadataSource() {
        	return this.securityMetadataSource;
    	}

    	@Override
    	public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        	FilterInvocation fi = new FilterInvocation(servletRequest, servletResponse, filterChain);
        	invoke(fi);
    	}

   		public void invoke(FilterInvocation fi) throws IOException, ServletException {
        	//fi里面有一个被拦截的url
        	//里面调用MyInvocationSecurityMetadataSource的getAttributes(Object object)这个方法获取fi对应的所有权限
        	//再调用MyAccessDecisionManager的decide方法来校验用户的权限是否足够
        	InterceptorStatusToken token = super.beforeInvocation(fi);
        	try {
        		//执行下一个拦截器
            	fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
        	} finally {
            	super.afterInvocation(token, null);
        	}
    	}
	}	


@Component
public class CustomizeFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {
    
	AntPathMatcher antPathMatcher = new AntPathMatcher();
    @Autowired
    SysPermissionService sysPermissionService;
    
	@Override
    public Collection<ConfigAttribute> getAttributes(Object o) throws IllegalArgumentException {

        //获取请求地址
        String requestUrl = ((FilterInvocation) o).getRequestUrl();

        //查询具体某个接口的权限
        List<SysPermission> permissionList =  sysPermissionService.selectListByPath(requestUrl);

        log.info("接口权限为：" + permissionList);

        if(permissionList == null || permissionList.size() == 0){
            //请求路径没有配置权限，表明该请求接口可以任意访问
            return null;
        }

        String[] attributes = new String[permissionList.size()];

        for(int i = 0;i<permissionList.size();i++){

            attributes[i] = permissionList.get(i).getPermissionCode();

        }
        return SecurityConfig.createList(attributes);
    }

    @Override
    public Collection<ConfigAttribute> getAllConfigAttributes() {
        return null;
    }

    @Override
    public boolean supports(Class<?> aClass) {
					return true;
	}
}

	@Component
	public class CustomizeAccessDecisionManager implements AccessDecisionManager {
		@Override
		public void decide(Authentication authentication, Object o, Collection <ConfigAttribute> collection) throws AccessDeniedException,InsufficientAuthenticationException {
			Iterator <ConfigAttribute> iterator = collection.iterator();
			while (iterator.hasNext()) {
				ConfigAttribute ca = iterator.next();
				//当前请求需要的权限
				String needRole = ca.getAttribute();
				//当前用户所具有的权限
				Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
            	for (GrantedAuthority authority : authorities) {
                	if (authority.getAuthority().equals(needRole)) {
                    	return;
                	}
            	}
        	}
        	throw new AccessDeniedException("权限不足!");
    	}

    @Override
    public boolean supports(ConfigAttribute configAttribute) {
        return true;
    }

    @Override
    public boolean supports(Class<?> aClass) {
		return true;
	}
}

@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	//登录成功
	@Autowired
	private CustomizeAuthenticationSuccessHandler authenticationSuccessHandler;
	
	//登录失败
	@Autowired
	private CustomizeAuthenticationFailureHandler authenticationFailureHandler;
	
	//登出
	@Autowired
	private CustomizeLogoutSuccessHandler logoutSuccessHandler;
	
	//会话失效(账号被挤下线)处理逻辑
	@Autowired
	private CustomizeSessionInformationExpiredStrategy sessionInformationExpiredStrategy;
	
	//匿名用户访问无权限资源时的异常
	@Autowired
	private CustomizeAuthenticationEntryPoint authenticationEntryPoint;

	//访问决策管理器
	@Autowired
	private CustomizeAccessDecisionManager accessDecisionManager;
	
	//安全元数据源
	@Autowired
	private CustomizeFilterInvocationSecurityMetadataSource securityMetadataSource;
	
	//权限拦截器
	@Autowired
	private CustomizeAbstractSecurityInterceptor securityInterceptor;
	
	@Bean
	public BCryptPasswordEncoder passwordEncoder() {
		// 设置默认的加密方式（强hash方式加密）
		return new BCryptPasswordEncoder();
	}
	
	@Bean
	public UserDetailsService userDetailsService() {
		//获取用户账号密码及权限信息
		return new UserDetailsServiceImpl();
	}
	
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		//配置认证方式等
		auth.userDetailsService(userDetailsService());
	}
	
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		//http相关的配置，包括登入登出、异常处理、会话管理等
		http
				.csrf()
				.disable()//关闭打开的csrf保护,允许跨域
				.authorizeRequests() //请求授权
				.withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
					@Override
					public <O extends FilterSecurityInterceptor> O postProcess(O o) {
						o.setAccessDecisionManager(accessDecisionManager);//决策管理器
						o.setSecurityMetadataSource(securityMetadataSource);//安全元数据源
						return o;
					}
				})
			.and()
				//登录
				.formLogin()
				.loginProcessingUrl("/dologin")
				.permitAll()//允许所有用户
				.successHandler(authenticationSuccessHandler)//登录成功处理逻辑
				.failureHandler(authenticationFailureHandler)//登录失败处理逻辑
			.and()
				//登出
				.logout()
				.permitAll()
				.logoutSuccessHandler(logoutSuccessHandler)
				.deleteCookies("JSESSIONID")
				//异常处理(权限拒绝、登录失效等)
			.and()
				.exceptionHandling()
				.authenticationEntryPoint(authenticationEntryPoint)//匿名用户访问无权限资源时的异常处理
			.and()
				.sessionManagement()
				.maximumSessions(1)//限制同一账号只能一个用户使用
				.expiredSessionStrategy(sessionInformationExpiredStrategy);//会话信息过期策略会话信息过期策略(账号被挤下线)
				//在FilterSecurityInterceptor之前添加 权限拦截器
		http
			.addFilterBefore(securityInterceptor,FilterSecurityInterceptor.class);
		}
	}


基于数据库的 URL 权限规则配置：

		<!-- MyBatis依赖 -->
		<dependency>
		    <groupId>org.mybatis.spring.boot</groupId>
		    <artifactId>mybatis-spring-boot-starter</artifactId>
		    <version>1.3.2</version>
		</dependency>
		 
		<!-- 数据库驱动依赖 -->
		<dependency>
		    <groupId>mysql</groupId>
		    <artifactId>mysql-connector-java</artifactId>
		</dependency>
		 
		<!-- 数据库连接池 -->
		<dependency>
		    <groupId>com.alibaba</groupId>
		    <artifactId>druid</artifactId>
		    <version>1.1.9</version>
		</dependency>


		spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
		spring.datasource.url=jdbc:mysql://localhost:3306/hangge?serverTimezone=Asia/Shanghai
		spring.datasource.username=root
		spring.datasource.password=hangge1234
		
		
		
		-- 用户表
		CREATE TABLE `user` (
		  `id` int AUTO_INCREMENT COMMENT '用户ID',
		  `username` varchar(8) DEFAULT NULL COMMENT '用户名',
		  `password` tinyint(3) unsigned DEFAULT NULL COMMENT '密码',
		  `enabled` tinyint(3) unsigned DEFAULT '1' COMMENT '是否有效：0无效，1有效',
		  `locked` tinyint(3) unsigned DEFAULT '0' COMMENT '是否锁住：0否，1是',
		  PRIMARY KEY (`id`)
		) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
		
		-- 角色表
		CREATE TABLE `role` (
		  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '角色ID',
		  `name` varchar(32) DEFAULT NULL COMMENT '角色编码',
		  `nameZh` varchar(32) DEFAULT NULL COMMENT '角色名称',
		  PRIMARY KEY (`id`)
		) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
		
		-- 用户角色表
		CREATE TABLE `user_role` (
		  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
		  `uid` varchar(32) DEFAULT NULL COMMENT '用户ID',
		  `rid` varchar(32) DEFAULT NULL COMMENT '角色ID',
		  PRIMARY KEY (`id`)
		) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

		-- 插入角色表数据
			INSERT INTO `role` (`id`, `name`, `nameZh`) VALUES (1, 'ROLE_dba', '数据库管理员'),(2, 'ROLE_admin', '系统管理员'),(3, 'ROLE_user', '用户');
		
		-- 插入用户表数据
			INSERT INTO `user` (`id`, `username`, `password`, `enabled`, `locked`) VALUES (1, 'root', 123, 1, 0),(2, 'admin', 123, 1, 0),(3, 'piao', 123, 1, 0);
		
		-- 插入用户角色表数据
			INSERT INTO `user_role` (`id`, `uid`, `rid`) VALUES(1, '1', '1'),(2, '1', '2'),(3, '2', '2'),(4, '3', '3');


		@Setter
		@Getter
		@NoArgsConstructor
		public class Role {
		    private Integer id;
		    private String name;
		    private String nameZh;
		}
		
@NoArgsConstructor
public class User implements UserDetails {
    private Integer id;
    private String username;
    private String password;
    private Boolean enabled;
    private Boolean locked;
    private List<Role> roles;
 
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        List<SimpleGrantedAuthority> authorities = new ArrayList<>();
        for (Role role : roles) {
            authorities.add(new SimpleGrantedAuthority(role.getName()));
        }
        return authorities;
    }
 
    @Override
    public String getPassword() {
        return password;
    }
 
    @Override
    public String getUsername() {
        return username;
    }
 
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
 
    @Override
    public boolean isAccountNonLocked() {
        return !locked;
    }
 
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
 
    @Override
    public boolean isEnabled() {
        return enabled;
    }
 
    /** get、set 方法 **/
 
    public Integer getId() {
        return id;
    }
 
    public void setId(Integer id) {
        this.id = id;
    }
 
    public void setUsername(String username) {
        this.username = username;
    }
 
    public void setPassword(String password) {
        this.password = password;
    }
 
    public void setEnabled(Boolean enabled) {
        this.enabled = enabled;
    }
 
    public Boolean getLocked() {
        return locked;
    }
 
    public void setLocked(Boolean locked) {
        this.locked = locked;
    }
 
    public List<Role> getRoles() {
        return roles;
    }
 
    public void setRoles(List<Role> roles) {
        this.roles = roles;
    }
}


@Mapper
public interface UserMapper {
    User loadUserByUsername(String username);
    List<Role> getUserRolesByUid(Integer id);
}

<mapper namespace="com.example.demo.mapper.UserMapper">
    <select id="loadUserByUsername" resultType="com.example.demo.bean.User">
        select * from user where username=#{username}
    </select>
    <select id="getUserRolesByUid" resultType="com.example.demo.bean.Role">
        select * from role r,user_role ur where r.id=ur.rid and ur.uid=#{id}
    </select>
</mapper>


@Service
public class UserService implements UserDetailsService {
    @Autowired
    UserMapper userMapper;
 
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userMapper.loadUserByUsername(username);
        if (user == null) {
            throw new UsernameNotFoundException("账户不存在!");
        }
        user.setRoles(userMapper.getUserRolesByUid(user.getId()));
        return user;
    }
}

		-- 菜单表
		CREATE TABLE `menu` (
		  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
		  `pattern` varchar(32) DEFAULT NULL COMMENT '菜单路径',
		  PRIMARY KEY (`id`)
		) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
		
		-- 菜单角色表
		CREATE TABLE `menu_role` (
		  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
		  `mid` varchar(32) DEFAULT NULL COMMENT '菜单ID',
		  `rid` varchar(32) DEFAULT NULL COMMENT '角色ID',
		  PRIMARY KEY (`id`)
		) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;


		-- 插入菜单表数据
			INSERT INTO `menu` (`id`, `pattern`)VALUES(1, '/db/**'),(2, '/admin/**'),(3, '/user/**');

		-- 插入菜单角色表数据

			INSERT INTO `menu_role` (`id`, `mid`, `rid`)VALUES(1, '1', '1'),(2, '2', '2'),(3, '3', '3');


		@Setter
		@Getter
		public class Menu {
		    private Integer id;
		    private String pattern;
		    private List<Role> roles;
		}


		@Mapper
		public interface MenuMapper {
		    List<Menu> getAllMenus();
		}


		<mapper namespace="com.example.demo.mapper.MenuMapper">
		    <resultMap id="BaseResultMap" type="com.example.demo.bean.Menu">
		        <id property="id" column="id"/>
		        <result property="pattern" column="pattern"/>
		        <collection property="roles" ofType="com.example.demo.bean.Role">
		            <id property="id" column="rid"/>
		            <result property="name" column="rname"/>
		            <result property="nameZh" column="rnameZh"/>
		        </collection>
		    </resultMap>
		    <select id="getAllMenus" resultMap="BaseResultMap">
		        SELECT m.*,r.id AS rid,r.name AS rname,r.nameZh AS rnameZh FROM menu m LEFT JOIN menu_role mr ON m.`id`=mr.`mid` LEFT JOIN role r ON mr.`rid`=r.`id`
		    </select>
		</mapper>

	@Component
	public class CustomFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {
	 
	    // 创建一个AnipathMatcher，主要用来实现ant风格的URL匹配。
	    AntPathMatcher antPathMatcher = new AntPathMatcher();
	 
	    @Autowired
	    MenuMapper menuMapper;
	 
	    @Override
	    public Collection<ConfigAttribute> getAttributes(Object object)
	            throws IllegalArgumentException {
	        // 从参数中提取出当前请求的URL
	        String requestUrl = ((FilterInvocation) object).getRequestUrl();
	 
	        // 从数据库中获取所有的资源信息，即本案例中的menu表以及menu所对应的role
	        // 在真实项目环境中，开发者可以将资源信息缓存在Redis或者其他缓存数据库中。
	        List<Menu> allMenus = menuMapper.getAllMenus();
	 
	        // 遍历资源信息，遍历过程中获取当前请求的URL所需要的角色信息并返回。
	        for (Menu menu : allMenus) {
	            if (antPathMatcher.match(menu.getPattern(), requestUrl)) {
	                List<Role> roles = menu.getRoles();
	                String[] roleArr = new String[roles.size()];
	                for (int i = 0; i < roleArr.length; i++) {
	                    roleArr[i] = roles.get(i).getName();
	                }
	                return SecurityConfig.createList(roleArr);
	            }
	        }
	 
	        // 如果当前请求的URL在资源表中不存在相应的模式，就假设该请求登录后即可访问，即直接返回 ROLE_LOGIN.
	        return SecurityConfig.createList("ROLE_LOGIN");
	    }
	 
	    // 该方法用来返回所有定义好的权限资源，Spring Security在启动时会校验相关配置是否正确。
	    @Override
	    public Collection<ConfigAttribute> getAllConfigAttributes() {
	        // 如果不需要校验，那么该方法直接返回null即可。
	        return null;
	    }
	 
	    // supports方法返回类对象是否支持校验。
	    @Override
	    public boolean supports(Class<?> clazz) {
        	return FilterInvocation.class.isAssignableFrom(clazz);
    	}
	}

@Component
public class CustomAccessDecisionManager implements AccessDecisionManager {
 
    // 该方法判断当前登录的用户是否具备当前请求URL所需要的角色信息
    @Override
    public void decide(Authentication auth,Object object,Collection<ConfigAttribute> ca){
        Collection<? extends GrantedAuthority> auths = auth.getAuthorities();
 
        // 如果具备权限，则不做任何事情即可
        for (ConfigAttribute configAttribute : ca) {
            // 如果需要的角色是ROLE_LOGIN，说明当前请求的URL用户登录后即可访问
            // 如果auth是UsernamePasswordAuthenticationToken的实例，说明当前用户已登录，该方法到此结束
            if ("ROLE_LOGIN".equals(configAttribute.getAttribute())
                    && auth instanceof UsernamePasswordAuthenticationToken) {
                return;
            }
 
            // 否则进入正常的判断流程
            for (GrantedAuthority authority : auths) {
                // 如果当前用户具备当前请求需要的角色，那么方法结束。
                if (configAttribute.getAttribute().equals(authority.getAuthority())) {
                    return;
                }
            }
        }
 
        // 如果不具备权限，就抛出AccessDeniedException异常
        throw new AccessDeniedException("权限不足");
    }
 
    @Override
    public boolean supports(ConfigAttribute attribute) {
        return true;
    }
 
    @Override
    public boolean supports(Class<?> clazz) {
		return true;
	}
}

@Configuration
public class MyWebSecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    UserService userService;
 
    // 指定密码的加密方式
    @SuppressWarnings("deprecation")
    @Bean
    PasswordEncoder passwordEncoder(){
        // 不对密码进行加密
        return NoOpPasswordEncoder.getInstance();
    }
 
    // 配置用户及其对应的角色
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userService);
    }
 
    // 配置 URL 访问权限
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
                    @Override
                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {
                        object.setSecurityMetadataSource(cfisms());
                        object.setAccessDecisionManager(cadm());
                        return object;
                    }
                })
                .and().formLogin().loginProcessingUrl("/login").permitAll()//开启表单登录并配置登录接口
                .and().csrf().disable(); // 关闭csrf
    }
 
    @Bean
    CustomFilterInvocationSecurityMetadataSource cfisms() {
        return new CustomFilterInvocationSecurityMetadataSource();
    }
 
    @Bean
    CustomAccessDecisionManager cadm() {
        return new CustomAccessDecisionManager();
    }
}



过滤器：用于属性甄别，对象收集（不可改变过滤对象的属性和行为）

拦截器：用于对象拦截，行为干预（可以改变拦截对象的属性和行为

Linux查看MySql安装信息:
	
	ps -ef | grep mysql
	
	which mysql
	
	
mysql:	
	查看Mysql安装目录:
		
		select @@basedir as basePath from dual ;
		
		show variables like '%basedir%';
		
	查看数据库版本:
		
		 SELECT VERSION(); 
		 
	查看指定数据库是否开启慢日志:
		show databases;
		use 数据库;
		
		show variables like 'slow_query%';
		show variables like 'long_query_time';
		  	
	查看Mysql数据目录:
		
		select @@datadir as dataPath from dual ;
		
		show variables Like '%datadir%';
			
	Mysql的慢查询日志开启:
		(方法一):
			set global show_query_log='ON';
			
			设置慢查询日志存放的位置:
				set global slow_query_log_file ='usr/local/mysql/data/shlow.log';//linux
				set global slow_query_log_file ='D:\\mysql\data\slow.log';//windows
				
				设置查询超过1秒就记录（如果有时候用命令不起作用，那么可以关闭再打开）
					set global long_query_time=1;
				
		(方法二):
			mysql.inf主配置文件
				[mysqld]
				slow_query_log=ON
				set global slow_query_log_file ='usr/local/mysql/data/shlow.log';//linux
				long_query_time=1
				
		重启mysql服务:
			service mysqld restart
			
	Mysql的binlog开启(数据恢复主从复制)
			my.inf主配置文件:
			
				(方法一):
				
					log_bin=ON  
					log_bin_basename=/var/lib/mysql/mysql-bin  
					log_bin_index=/var/lib/mysql/mysql-bin.index 
					第一个参数是打开binlog日志
					第二个参数是binlog日志的基本文件名，后面会追加标识来表示每一个文件
					第三个参数指定的是binlog文件的索引文件，这个文件管理了所有的binlog文件的目录
					
				(方法二):
					log-bin=/var/lib/mysql/mysql-bin
				mysql版本>5.7时,需要配置
					server-id=123454 //随机指定一个不能和其他集群中机器重名的字符串  
				
				重启服务:
					service mysqld restart
					
				查看配置是否有效:	
					show variables like '%log_bin%'
					
			查看当前mysql的binlog的情况:
				show master status;
			新建binlog文件:
				flush logs;
			清空binlog:
				reset master;
			查看binlog:
				mysqlbinlog binlog日志名;
			
			查看指定数据库表创建时间:
				USE  information_schema;
				SELECT CREATE_TIME FROM TABLES WHERE TABLE_SCHEMA='数据库名称' AND TABLE_NAME='数据库表';

			查看创建表的语句，是查看怎么创建表的，不是查看表的内容。
				show create table emp;



CREATE  TABLE [StudentScores]
(
   [UserName]         NVARCHAR(20),        --学生姓名
    [Subject]          NVARCHAR(30),        --科目
    [Score]            FLOAT,               --成绩
)
sql行转列:https://www.cnblogs.com/kerrycode/archive/2010/07/28/1786547.html
	一行数据:
		代表一科成绩
	转成:
	一行数据:
		代表一个人所有科成绩
		
		SELECT * FROM student PIVOT (SUM(score) FOR subject IN (语文, 数学, 英语))
		
			或者:

			SELECT 
			      UserName, 
			      MAX(CASE Subject WHEN '语文' THEN Score ELSE 0 END) AS '语文',
			      MAX(CASE Subject WHEN '数学' THEN Score ELSE 0 END) AS '数学',
			      MAX(CASE Subject WHEN '英语' THEN Score ELSE 0 END) AS '英语',
			      MAX(CASE Subject WHEN '生物' THEN Score ELSE 0 END) AS '生物'
			FROM dbo.[StudentScores]
			GROUP BY UserName
	
sql列转行:

	一行数据:
		代表一个人所有科成绩
		转成:
	一行数据:
		代表一科成绩	
		
		SELECT * FROM student1 UNPIVOT (score FOR subject IN ("语文","数学","英语"))

			或者:
			
			SELECT
			    NAME,
			    '语文' AS subject ,
			    MAX("语文") AS score
			FROM student1 GROUP BY NAME
			UNION
			SELECT
			    NAME,
			    '数学' AS subject ,
			    MAX("数学") AS score
			FROM student1 GROUP BY NAME
			UNION
			SELECT
			    NAME,
			    '英语' AS subject ,
			    MAX("英语") AS score
			FROM student1 GROUP BY NAME

redis启动服务: https://www.cnblogs.com/sinnerG/p/15033951.html

	redis安装目录下:
	 redis>src
	 	执行 ./redis-server ../redis.conf
	 	
redis查询:

	redis安装目录下:
	 redis>src
	 	执行 ./redis-cli
	
Redis安装:
	1.1安装 gcc
		 Yum install gcc-c++ 
	
	1.2解压 redis.3.0.0.tar.gz 压缩包
		 tar -zxvf redis-3.0.0.tar.gz
		 
    1.3进入解压后的目录进行编译 
    	cd redis-3.0.0
    	make 
    
    1.4将 Redis 安装到指定目录
    	 make PREFIX=/usr/local/redis install 
    	 
    1.5启动 Redis
    	 ./redis-server	redis.conf
	
	 	
linux redhot：
	关闭防火墙:
		systemctl stop firewalld
	关闭防火墙自启动:
		systemctl disable firewalld
	查看防火墙状态:
		systemctl status firewalld
	查看防火墙端口开放:
		firewall-cmd --zone=public --list-ports
	添加端口到防火墙中：
		1、添加（--permanent永久生效，没有此参数重启后失效）
			firewall-cmd --zone=public --add-port=1521/tcp --permanent
		2、重新载入
			firewall-cmd --reload
		3、查看确认添加状态
			firewall-cmd --zone=public --query-port=1521/tcp
		4、删除防火墙端口
			firewall-cmd --zone=public --remove-port=1521/tcp --permanent	
		

		
CREATE TABLE `role` (
  `id` bigint(20) NOT NULL,
  `role_name` varchar(255) DEFAULT NULL,
  `user_id` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FK61g3ambult7v7nh59xirgd9nf` (`user_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8

CREATE TABLE `user` (
  `id` bigint(20) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_gj2fy3dcix7ph7k8684gka40c` (`name`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8

CREATE TABLE `permission` (
  `id` bigint(20) NOT NULL,
  `permission` varchar(255) DEFAULT NULL,
  `role_id` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FKrvhjnns4bvlh4m1n97vb7vbar` (`role_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8	
	
CREATE TABLE `hibernate_sequence` (
  `next_val` bigint(20) DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8


泛型:
	泛型类定义:
	
		//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
		//在实例化泛型类时，必须指定T的具体类型
		public class Generic<T>{ 
		    //key这个成员变量的类型为T,T的类型由外部指定  
		    private T key;
		
		    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定
		        this.key = key;
		    }
		
		    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定
		        return key;
		    }
		}
		
		class Box<T> {

		    private T data;
		
		    public Box() {
		
		    }
		
		    public Box(T data) {
		        this.data = data;
		    }
		
		    public T getData() {
		        return data;
		    }
		}

	泛型接口:
		
		//定义一个泛型接口
		public interface Generator<T> {
		    public T next();
		}

	泛型方法:
	
		/**
		 * 泛型方法的基本介绍
		 * @param tClass 传入的泛型实参
		 * @return T 返回值为T类型
		 * 说明：
		 *     1）public 与 返回值中间<T>非常重要，可以理解为声明此方法为泛型方法。
		 *     2）只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
		 *     3）<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。
		 *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
		 */
		public <T> T genericMethod(Class<T> tClass)throws InstantiationException ,
		  IllegalAccessException{
		        T instance = tClass.newInstance();
		        return instance;
		}	



		public class GenericTest {
		   //这个类是个泛型类，在上面已经介绍过
		   public class Generic<T>{     
		        private T key;
		
		        public Generic(T key) {
		            this.key = key;
		        }
		
		        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。
		        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
		        //所以在这个方法中才可以继续使用 T 这个泛型。
		        public T getKey(){
		            return key;
		        }
		
		        /**
		         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"
		         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。
		        public E setKey(E key){
		             this.key = keu
		        }
		        */
		    }
		
		    /** 
		     * 这才是一个真正的泛型方法。
		     * 首先在public与返回值之间的<T>必不可少，这表明这是一个泛型方法，并且声明了一个泛型T
		     * 这个T可以出现在这个泛型方法的任意位置.
		     * 泛型的数量也可以为任意多个 
		     *    如：public <T,K> K showKeyName(Generic<T> container){
		     *        ...
		     *        }
		     */
		    public <T> T showKeyName(Generic<T> container){
		        System.out.println("container key :" + container.getKey());
		        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。
		        T test = container.getKey();
		        return test;
		    }
		
		    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic<Number>这个泛型类做形参而已。
		    public void showKeyValue1(Generic<Number> obj){
		        Log.d("泛型测试","key value is " + obj.getKey());
		    }
		
		    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?
		    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类
		    public void showKeyValue2(Generic<?> obj){
		        Log.d("泛型测试","key value is " + obj.getKey());
    		}

     	   /**
     		* 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "
     		* 虽然我们声明了<T>,也表明了这是一个可以处理泛型的类型的泛型方法。
     		* 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。
    		public <T> T showKeyName(Generic<E> container){
        		...
    		}  
    		*/

    	   /**
     		* 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "
     		* 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。
     		* 所以这也不是一个正确的泛型方法声明。
    		public void showkey(T genericObj){

    		}
    		*/

			}



		class GenerateTest<T>{
        	public void show_1(T t){
            	System.out.println(t.toString());
        	}

        	//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。
        	//由于泛型方法在声明的时候会声明泛型<E>，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。
        	public <E> void show_3(E t){
            	System.out.println(t.toString());
        	}

        	//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。
        	public <T> void show_2(T t){
            	System.out.println(t.toString());
        	}
    	}

		泛型方法与可变参数:
			public <T> void printMsg( T... args){
    			for(T t : args){
        			Log.d("泛型测试","t is " + t);
    			}
			}

		静态方法泛型:

			public class StaticGenerator<T> {

    			/**
     			 * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）
     			 * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。
     			 * 如：public static void show(T t){..},此时编译器会提示错误信息：
          			"StaticGenerator cannot be refrenced from static context"
     			 */
    			public static <T> void show(T t){

    			}
			}


		泛型上边界,即传入的类型实参必须是指定类型的子类型:
			public void showKeyValue1(Generic<? extends Number> obj){
    				Log.d("泛型测试","key value is " + obj.getKey());
			}

枚举:

	public enum ErrorCodeEn {
    	OK(0, "成功"),
    	ERROR_A(100, "错误A"),
    	ERROR_B(200, "错误B");

    	ErrorCodeEn(int number, String description) {
        	this.code = number;
        	this.description = description;
    	}
    	private int code;
    	private String description;
    	public int getCode() {
        	return code;
    	}
    	public String getDescription() {
        	return description;
    	}
    	public static void main(String args[]) { // 静态方法
        	for (ErrorCodeEn s : ErrorCodeEn.values()) {
            	System.out.println("code: " + s.getCode() + ", description: " + s.getDescription());
        	}
    	}
	}

枚举实现接口:

public interface INumberEnum {
    int getCode();
    String getDescription();
}

public enum ErrorCodeEn2 implements INumberEnum {
    OK(0, "成功"),
    ERROR_A(100, "错误A"),
    ERROR_B(200, "错误B");

    ErrorCodeEn2(int number, String description) {
        this.code = number;
        this.description = description;
    }

    private int code;
    private String description;

    @Override
    public int getCode() {
        return code;
    }

    @Override
    public String getDescription() {
        return description;
    }
}

Spring+WebSocket：
		<!-- 使用spring websocket依赖的jar包 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-websocket</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-messaging</artifactId>
            <version>${spring.version}</version>
        </dependency>
        
        import org.springframework.context.annotation.Bean;
		import org.springframework.context.annotation.Configuration;
		import org.springframework.web.servlet.config.annotation.EnableWebMvc;
		import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
		import org.springframework.web.socket.config.annotation.EnableWebSocket;
		import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
		import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
		import org.springframework.web.socket.handler.TextWebSocketHandler;
		
		
		@Configuration
		@EnableWebMvc
		@EnableWebSocket
		public class SpringWebSocketConfig extends WebMvcConfigurerAdapter implements WebSocketConfigurer {
		    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		        registry.addHandler(webSocketHandler(),"/websocket/socketServer.do").addInterceptors(new SpringWebSocketHandlerInterceptor());
		        registry.addHandler(webSocketHandler(), "/sockjs/socketServer.do").addInterceptors(new SpringWebSocketHandlerInterceptor()).withSockJS();
		    }
		 
		    @Bean
		    public TextWebSocketHandler webSocketHandler(){
		        return new SpringWebSocketHandler();
		    }
		}
		
/*
 *该对象提供了客户端连接,关闭,错误,发送等方法,重写这几个方法即可实现自定义业务逻辑
 *
 *
 */		
import java.io.IOException;
import java.util.ArrayList;
import org.apache.log4j.Logger;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;


public class SpringWebSocketHandler extends TextWebSocketHandler {
    private static final ArrayList<WebSocketSession> users;//这个会出现性能问题，最好用Map来存储，key用userid
    private static Logger logger = Logger.getLogger(SpringWebSocketHandler.class);
    static {
        users = new ArrayList<WebSocketSession>();
    }
    
    public SpringWebSocketHandler() {
        // TODO Auto-generated constructor stub
    }

    /**
     * 连接成功时候，会触发页面上onopen方法
     */
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        // TODO Auto-generated method stub
        System.out.println("connect to the websocket success......当前数量:"+users.size());
        users.add(session);
        //这块会实现自己业务，比如，当用户登录后，会把离线消息推送给用户
        //TextMessage returnMessage = new TextMessage("你将收到的离线");
        //session.sendMessage(returnMessage);
    }
    
    /**
     * 关闭连接时触发
     */
    public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {
        logger.debug("websocket connection closed......");
        String username= (String) session.getAttributes().get("WEBSOCKET_USERNAME");
        System.out.println("用户"+username+"已退出！");
        users.remove(session);
        System.out.println("剩余在线用户"+users.size());
    }

    /**
     * js调用websocket.send时候，会调用该方法
     */
    @Override    
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        super.handleTextMessage(session, message);
    }

    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        if(session.isOpen()){session.close();}
        logger.debug("websocket connection closed......");
        users.remove(session);
    }

    public boolean supportsPartialMessages() {
        return false;
    }
    
    
    /**
     * 给某个用户发送消息
     *
     * @param userName
     * @param message
     */
    public void sendMessageToUser(String userName, TextMessage message) {
        for (WebSocketSession user : users) {
            if (user.getAttributes().get("WEBSOCKET_USERNAME").equals(userName)) {
                try {
                    if (user.isOpen()) {
                        user.sendMessage(message);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
                break;
            }
        }
    }
    
    /**
     * 给所有在线用户发送消息
     *
     * @param message
     */
    public void sendMessageToUsers(TextMessage message) {
        for (WebSocketSession user : users) {
            try {
                if (user.isOpen()) {
                    user.sendMessage(message);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}


/**
 * WebSocket拦截器
 * @author WANG
 *
 */
public class SpringWebSocketHandlerInterceptor extends HttpSessionHandshakeInterceptor {
    @Override
    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,
            Map<String, Object> attributes) throws Exception {
        // TODO Auto-generated method stub
        System.out.println("Before Handshake");
        if (request instanceof ServletServerHttpRequest) {
            ServletServerHttpRequest servletRequest = (ServletServerHttpRequest) request;
            HttpSession session = servletRequest.getServletRequest().getSession(false);
            if (session != null) {
                //使用userName区分WebSocketHandler，以便定向发送消息
                String userName = (String) session.getAttribute("SESSION_USERNAME");
                if (userName==null) {
                    userName="default-system";
                }
                attributes.put("WEBSOCKET_USERNAME",userName);
            }
        }
        return super.beforeHandshake(request, response, wsHandler, attributes);
        
    }
    
    @Override
    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,
            Exception ex) {
        // TODO Auto-generated method stub
        super.afterHandshake(request, response, wsHandler, ex);
    }
}


<!-- websocket相关扫描，主要扫描：WebSocketConfig  如果前面配置能扫描到此类则可以不加 -->
<context:component-scan base-package="com.quicksand.push"/>


import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.socket.TextMessage;

import com.quicksand.push.SpringWebSocketHandler;

@Controller
public class WebsocketController {
    @Bean//这个注解会从Spring容器拿出Bean
    public SpringWebSocketHandler infoHandler() {
        return new SpringWebSocketHandler();
    }

    @RequestMapping("/websocket/login")
    public ModelAndView login(HttpServletRequest request, HttpServletResponse response) throws Exception {
        String username = request.getParameter("username");
        System.out.println(username+"登录");
        HttpSession session = request.getSession(false);
        session.setAttribute("SESSION_USERNAME", username);
        //response.sendRedirect("/quicksand/jsp/websocket.jsp");
        return new ModelAndView("websocket");
    }

    @RequestMapping("/websocket/send")
    @ResponseBody
    public String send(HttpServletRequest request) {
        String username = request.getParameter("username");
        infoHandler().sendMessageToUser(username, new TextMessage("你好，测试！！！！"));
        return null;
    }
}


登录页面:

<%@ page language="java" contentType="text/html; charset=utf-8"
    pageEncoding="utf-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Insert title here</title>
</head>
	<body>
		<script type="text/javascript" src="http://cdn.bootcss.com/jquery/3.1.0/jquery.min.js"></script>
		<script type="text/javascript" src="http://cdn.bootcss.com/sockjs-client/1.1.1/sockjs.js"></script>
		<script type="text/javascript">
		    var websocket = null;
		    if ('WebSocket' in window) {
		        websocket = new WebSocket("ws://localhost:8080/quicksand/websocket/socketServer.do");
		    } 
		    else if ('MozWebSocket' in window) {
		        websocket = new MozWebSocket("ws://localhost:8080/quicksand/websocket/socketServer.do");
		    } 
		    else {
		        websocket = new SockJS("http://localhost:8080/quicksand/sockjs/socketServer.do");
		    }
		    websocket.onopen = onOpen;
		    websocket.onmessage = onMessage;
		    websocket.onerror = onError;
		    websocket.onclose = onClose;
		              
		    function onOpen(openEvt) {
		        //alert(openEvt.Data);
		    }
		    
		    function onMessage(evt) {
		        alert(evt.data);
		    }
		    function onError() {}
		    function onClose() {}
		    
		    function doSend() {
		        if (websocket.readyState == websocket.OPEN) {          
		            var msg = document.getElementById("inputMsg").value;  
		            websocket.send(msg);//调用后台handleTextMessage方法
		            alert("发送成功!");  
		        } else {  
		            alert("连接失败!");  
		        }  
		    }
		　　　window.close=function()	　　　{		　　　　　websocket.onclose();	　　　}
		</script>
		请输入：<textarea rows="5" cols="10" id="inputMsg" name="inputMsg"></textarea>
		<button onclick="doSend();">发送</button>
	</body>
</html>


4.WebSocket和Socket的区别

　　1.WebSocket:

        	websocket通讯的建立阶段是依赖于http协议的。最初的握手阶段是http协议，握手完成后就切换到websocket协议，并完全与http协议脱离了。

		        建立通讯时，也是由客户端主动发起连接请求，服务端被动监听。
		
		        通讯一旦建立连接后，通讯就是“全双工”模式了。也就是说服务端和客户端都能在任何时间自由得发送数据，非常适合服务端要主动推送实时数据的业务场景。
		
		        交互模式不再是“请求-应答”模式，完全由开发者自行设计通讯协议。
		
		        通信的数据是基于“帧(frame)”的，可以传输文本数据，也可以直接传输二进制数据，效率高。当然，开发者也就要考虑封包、拆包、编号等技术细节。

　　2.Socket:

		        服务端监听通讯，被动提供服务；客户端主动向服务端发起连接请求，建立起通讯。
		
		        每一次交互都是：客户端主动发起请求（request），服务端被动应答（response）。
		
		        服务端不能主动向客户端推送数据。
		
		        通信的数据是基于文本格式的。二进制数据（比如图片等）要利用base64等手段转换为文本后才能传输。


webSocket实现多人聊天功能:

	聊天页面代码,前端的主要逻辑都在这里 chating/index.vue
	
		<template>
		  <div class="chating">
		    <div class="chating-wrap">
		      <div class="title">聊天页面</div>
		      <div class="chating-content">
		        <div class="chating-body">
		          <div class="chating-list">
		            <ul class="chating-records">
		              <div :key="index" v-for="(item, index) in chatingRecords">
		                <li class="other" v-show="item.nickName != myNickName">
		                  <img alt="用户头像" src="../../assets/logo.png" />
		                  <div class="record-text-wrap">
		                    <div class="nick-name">{{item.nickName}}</div>
		                    <div class="record-text">{{item.message}}</div>
		                  </div>
		                </li>
		                <li class="my" v-show="item.nickName == myNickName">
		                  <div class="record-text-wrap">
		                    <!-- <div class="nick-name">迷离</div> -->
		                    <div class="record-text">{{item.message}}</div>
		                  </div>
		                  <img alt="用户头像" src="../../assets/logo.png" />
		                </li>
		              </div>
		            </ul>
		          </div>
		          <div class="chating-btns">
		            <input class="input-text" placeholder="请输入聊天内容" type="text" v-model="text" />
		            <button @click="sendData" class="send">发送</button>
		          </div>
		        </div>
		        <div class="chating-online-number">
		          <div class="online-num">在线用户{{userList.length}}</div>
		          <ul v-if="userList.length > 0">
		            <li :key="index" class="user" v-for="(item, index) in userList">
		              <img alt="用户头像" src="../../assets/logo.png" />
		              <span>{{item.userName}}</span>
		            </li>
		          </ul>
		          <button @click="loginOutHandler">退出群聊</button>
		        </div>
		      </div>
		    </div>
		
		    <div class="login" v-if="showLogin">
		      <div class="opacity-wrap">
		        <div>
		          用户名：
		          <input class="user-name" v-model="userName" />
		        </div>
		        <button @click="loginHandler" class="login-btn">登录</button>
		      </div>
		    </div>
		  </div>
		</template>
		
		<script>
			export default {
			  data () {
			    return {
			      text: '',
			      socketUrl: 'ws://localhost:8888?userName=', // socket服务地址
			      client: null, // webSocket实例
			      chatingRecords: [], // 聊天记录
			      myNickName: '', // 是否是自己
			      userName: '',
			      showLogin: false,
			      userList: []
			    }
			  },
			  created () {
			    console.log('created')
			    // this.initChaing()
			  },
			  mounted () {
			    console.log('mounted')
			  },
			  methods: {
			    /* 初始化聊天，连接socket */
			    initChaing () {
			      let that = this
			      if (window.WebSocket) {
			        /* webSocket 连接服务器 */
			        this.client = new WebSocket(this.socketUrl + this.myNickName)
			
			        /* 监听客户端连接 */
			        this.client.onopen = function (ev) {
			          if (ev.type === 'open') {
			            console.log('客户端连接socket服务')
			          }
			        }
			
			        /* 监听服务端发送的消息 */
			        this.client.onmessage = function (ev) {
			          let data = JSON.parse(ev.data)
			          /* 用户在线信息接收的是一个jsony数组 */
			          if (data instanceof Array === true) {
			            that.userList = data // 在线用户数量变化
			          } else {
			            /* 聊天信息接收的是一个json对象 */
			            that.chatingRecords.push(data) // 在线用户聊天
			          }
			        }
			
			        /* 监听服务端关闭 */
			        this.client.onclose = function (ev) {
			          console.log('socket服务已关闭')
			          that.client = null // 客户端或者是服务端断开后，将webSocket实例清除
			        }
			
			        /* 监听服务端异常 */
			        this.client.onerror = function () {
			          if (!that.client) {
			            console.log('socket服务连接失败')
			          }
			          that.loginOutHandler()
			        }
			      } else {
			        alert('该浏览器不支持webSocket，请使用主流浏览器，如chrome')
			      }
			    },
			    loginHandler () {
			      this.myNickName = this.userName
			      this.showLogin = false
			      /* 登录成功后再连接服务，是为了连接服务的时候把用户信息发过去 */
			      this.initChaing()
			    },
			    loginOutHandler () {
			      this.client.close()
			      this.client = null // 客户端或者是服务端断开后，将webSocket实例清除
			      this.$router.push('/')
			    },
			    sendData () {
			      if (!this.myNickName) {
			        alert('请登录')
			        this.showLogin = true
			        return
			      }
			
			      let data = {
			        nickName: this.myNickName,
			        uid: new Date().getTime(),
			        message: this.text,
			        date: new Date()
			      }
			      if (this.client) {
			        this.client.send(JSON.stringify(data))
			        this.text = ''
			      } else {
			        console.log('socket服务连接失败,正在重新连接服务..')
			        this.initChaing()
			      }
			    }
			  },
			  beforeDestroy () {
			    this.client.close()
			  }
			}
		</script>
		
		<style lang="">
			.login {
			  width: 100vw;
			  height: 100vh;
			  position: fixed;
			  top: 0;
			  left: 0;
			  background: rgba(0, 0, 0, 0.6);
			  display: flex;
			  justify-content: center;
			  align-items: center;
			}
			.opacity-wrap {
			  width: 500px;
			  height: 300px;
			  background: #fff;
			  display: flex;
			  justify-content: center;
			  align-items: center;
			  flex-direction: column;
			}
			.user-name {
			  font-size: 16px;
			  padding: 5px;
			  text-indent: 10px;
			}
			.login-btn {
			  font-size: 20px;
			  background: cornflowerblue;
			  color: 20px;
			  margin-top: 30px;
			  color: #fff;
			  border: none;
			  outline: none;
			  padding: 10px 20px;
			  border-radius: 10px;
			}
			ul {
			  list-style: none;
			  margin: 0;
			  padding: 0;
			}
			.chating {
			  max-width: 800px;
			  border: 20px solid lightcyan;
			  border-radius: 20px;
			  margin: 0 auto 0;
			}
			.title {
			  background: cornflowerblue;
			  color: #fff;
			  padding: 5px 0 5px;
			}
			.chating-content {
			  width: 100%;
			  display: flex;
			  justify-content: space-between;
			}
			.chating-body {
			  flex: 1;
			  display: flex;
			  flex-direction: column;
			  justify-content: space-between;
			  background: #f3f3f3;
			}
			.chating-list {
			  flex: 1;
			  border: 1px solid cornflowerblue;
			}
			.chating-records {
			  padding: 10px;
			  min-height: 300px;
			  max-height: 600px;
			  overflow-y: auto;
			}
			.chating-records li {
			  margin-bottom: 20px;
			}
			.chating-records .other {
			  display: flex;
			  justify-content: start;
			  align-items: flex-start;
			}
			.chating-records .my {
			  display: flex;
			  justify-content: flex-end;
			  align-items: center;
			}
			
			.chating-records img {
			  width: 36px;
			  height: 36px;
			  /* border-radius: 50%; */
			  margin-right: 15px;
			  background: purple;
			}
			.chating-records .my img {
			  margin-right: 0;
			  margin-left: 15px;
			}
			.chating-records .other .record-text-wrap {
			  display: flex;
			  flex-direction: column;
			  align-items: flex-start;
			}
			.chating-records .my .record-text-wrap {
			  display: flex;
			  flex-direction: column;
			  align-items: flex-end;
			}
			.nick-name {
			  font-size: 14px;
			  margin-bottom: 5px;
			  color: #666;
			}
			.record-text {
			  max-width: 260px;
			  text-align: left;
			  font-size: 14px;
			  padding: 5px;
			  background: #fff;
			  border-radius: 5px;
			}
			
			.chating-btns {
			  background: burlywood;
			  padding: 10px;
			  display: flex;
			  align-items: center;
			  justify-content: center;
			}
			.input-text {
			  font-size: 16px;
			  border: none;
			  outline: none;
			  padding: 5px 0 5px 5px;
			}
			.send {
			  font-size: 16px;
			  border: none;
			  outline: none;
			  padding: 4px 15px;
			  margin-left: 20px;
			}
			
			.online-num {
			  font-size: 12px;
			  padding-bottom: 15px;
			}
			.chating-online-number {
			  padding: 15px;
			  height: 100%;
			}
			.chating-online-number ul {
			  list-style: none;
			  margin: 0;
			  padding: 0;
			  min-width: 120px;
			  max-height: 580px;
			  overflow-y: auto;
			}
			.user {
			  display: flex;
			  justify-content: space-between;
			  align-content: center;
			  line-height: 20px;
			  font-size: 12px;
			  border-bottom: 1px solid aqua;
			  padding: 10px;
			  margin-bottom: 5px;
			}
			.user img {
			  width: 20px;
			  height: 20px;
			  border-radius: 50%;
			  margin-right: 5px;
			  background: palevioletred;
			}
		</style>

websocket实现多房间多人在线聊天室
	import org.springframework.stereotype.Controller;
	import org.springframework.ui.Model;
	import org.springframework.ui.ModelMap;
	import org.springframework.web.bind.annotation.RequestMapping;
	import org.springframework.web.bind.annotation.SessionAttributes;
	 
	@Controller
	@RequestMapping("/home")
	@SessionAttributes("uname")
	public class ViewController {
	     
	    @RequestMapping("/list")
	    public String cc(ModelMap model){
	        return "index";
	      }
	     
	    @RequestMapping("/room")
	    public String h(ModelMap model,String uname,String roomid){
	        model.put("uname",uname);
	        model.put("roomid", roomid);
	        return "room";
	    }
	}
	
	
	import java.io.IOException;
	import java.text.SimpleDateFormat;
	import java.util.ArrayList;
	import java.util.Date;
	import java.util.List;
	import java.util.Map;
	import java.util.Set;
	import java.util.concurrent.ConcurrentHashMap;
	 
	import javax.websocket.OnClose;
	import javax.websocket.OnError;
	import javax.websocket.OnMessage;
	import javax.websocket.OnOpen;
	import javax.websocket.Session;
	import javax.websocket.server.PathParam;
	import javax.websocket.server.ServerEndpoint;
	 
	 
	import net.sf.json.JSONObject;
	 
	 
	@ServerEndpoint("/websocket/{info}")
	public class WebSocketService {
	 
	    private static SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss");//创建时间格式对象
	    //concurrent包的线程安全Set，用来存放每个客户端对应的WebSocketService对象。
	    //创建一个房间的集合，用来存放房间
	    private static ConcurrentHashMap<String,ConcurrentHashMap<String, WebSocketService>> roomList = new  ConcurrentHashMap<String,ConcurrentHashMap<String, WebSocketService>>();
	    //与某个客户端的连接会话，需要通过它来给客户端发送数据
	    private Session session;
	  //重新加入房间的标示；
	  private int rejoin = 0;
	     
	   /*static {
	        roomList.put("room1", new ConcurrentHashMap<String, WebSocketService>());
	        roomList.put("room2", new ConcurrentHashMap<String, WebSocketService>());
	    }*/
	 
	  /**
	   * 用户接入
	   * @param param  连接websocket服务器时穿的参数
	   * @param session 会话
	   */
	    @OnOpen
	    public void onOpen(@PathParam(value = "info") String param,Session session){
	        System.err.println("登录时候穿的参数"+param.toString());
	        this.session = session;
	        String flag = param.split("[|]")[0];        //标识
	        String member = param.split("[|]")[1];      //成员名
	        if(roomList.get(member)==null){//判断房间列表中是否有此次的房间名称
	            roomList.put(member, new ConcurrentHashMap<String, WebSocketService>());//如果没有将房间添加到房间列表中
	        }
	        //判断标志位是不是加入房间
	        if(flag.equals("join")){
	            String user = param.split("[|]")[2]; //截取用户名
	            //调用加入房间的方法，传入房间名称和用户名称
	            joinRoom(member,user);     
	        }
	    }
	     
	    /**
	     * 加入房间
	     * @param member 房间号
	     * @param user 用户名
	     */
	    public void joinRoom(String member,String user){
	        //从房间列表中获取房间
	        ConcurrentHashMap<String, WebSocketService> r =  roomList.get(member);
	        System.out.println(r.get(user));
	        if(r.get(user) != null){        //该用户有没有在房间中
	            this.rejoin = 1;//重新加入房间标志位1（一旦重新加入房间，以前的页面用户将看不到消息）
	        }
	        r.put(user, this);//将此用户加入房间中
	    }
	     
	    /**
	     * 发送消息的方法
	     * @param message  需要发送的消息
	     * @throws IOException
	     */
	    public void sendMessage(String message) throws IOException {
	        this.session.getBasicRemote().sendText(message);
	    }
	    /**
	     * 接收到来自用户的消息
	     * @param message 接受的消息
	     * @param session 回话
	     * @throws IOException
	     */
	    @OnMessage
	    public void onMessage(String message,Session session) throws IOException{
	         
	        //把用户发来的消息解析为JSON对象
	        JSONObject obj = JSONObject.fromObject(message);
	        System.out.println(obj.toString());
	        //判断接受到的消息的标志位是什么（退出房间和发消息）
	        if(obj.get("flag").toString().equals("exitroom")){      //退出房间操作
	            String roomid = obj.get("roomid").toString();//取得房间编号
	            System.out.println("roomid-"+roomid);
	            //将用户从聊天室中移除
	            int f2 = 1;
	            roomList.get(roomid).remove(obj.get("nickname").toString());//将用户直接移除
	            if(roomList.get(roomid).size() == 0){//判断房间该房间是否还有用户，如果没有，则将此房间也移除
	                f2 = 2;
	            }
	            if(f2 == 1){        //证明该房间还有其它成员，则通知其它成员更新列表
	                obj.put("flag","exitroom");
	                String m = obj.get("nickname").toString()+" 退出了房间";
	                obj.put("message", m);
	                ConcurrentHashMap<String, WebSocketService> r =roomList.get(roomid);
	                List<String> uname = new ArrayList<String>();
	                for(String u:r.keySet()){
	                    uname.add(u);
	                }
	                obj.put("uname", uname.toArray());
	                for(String i:r.keySet()){  //遍历该房间
	                    r.get(i).sendMessage(obj.toString());//调用方法 将消息推送
	                }
	            }
	        }else if(obj.get("flag").toString().equals("chatroom")){        //聊天室的消息 加入房间/发送消息
	            //向JSON对象中添加发送时间
	            obj.put("date", df.format(new Date()));
	            //获取客户端发送的数据中的内容---房间�? 用于区别该消息是来自于哪个房间
	            String roomid = obj.get("target").toString();
	            //获取客户端发送的数据中的内容---用户
	            String username = obj.get("nickname").toString();
	            //从房间列表中定位到该房间
	            ConcurrentHashMap<String, WebSocketService> r =roomList.get(roomid);
	            List<String> uname = new ArrayList<String>();
	            for(String u:r.keySet()){
	                uname.add(u);
	            }
	            obj.put("uname", uname.toArray());
	            if(r.get(username).rejoin == 0){            //证明不是退出重连
	                for(String i:r.keySet()){  //遍历该房间
	                    obj.put("isSelf", username.equals(i));//设置消息是否为自己的
	                    r.get(i).sendMessage(obj.toString());//调用方法 将消息推送
	                }
	            }else{
	                obj.put("isSelf", true);
	                r.get(username).sendMessage(obj.toString());
	            }
	            r.get(username).rejoin = 0;
	        }
	         
	    }
	     
	    /**
	     * 用户断开
	     * @param session
	     */
	    @OnClose
	    public void onClose(Session session){
	   System.out.println("退出聊天室");
	    }
	     
	    /**
	     * 用户连接异常
	     * @param t
	     */
	    @OnError
	    public void onError(Throwable t){
	         
	    }
	}
	
applicationContext.xml:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
	    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	    xmlns:mvc="http://www.springframework.org/schema/mvc"
	    xmlns:websocket="http://www.springframework.org/schema/websocket"
	    xsi:schemaLocation="http://www.springframework.org/schema/beans
	    http://www.springframework.org/schema/beans/spring-beans.xsd
	    http://www.springframework.org/schema/context
	    http://www.springframework.org/schema/context/spring-context-4.0.xsd
	    http://www.springframework.org/schema/mvc
	    http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
	    http://www.springframework.org/schema/websocket
	    http://www.springframework.org/schema/websocket/spring-websocket.xsd">
	</beans>


springmvc.xml：

	<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
		    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
		    xmlns:mvc="http://www.springframework.org/schema/mvc"
		    xmlns:websocket="http://www.springframework.org/schema/websocket"
		    xsi:schemaLocation="http://www.springframework.org/schema/beans
		    http://www.springframework.org/schema/beans/spring-beans.xsd
		    http://www.springframework.org/schema/context
		    http://www.springframework.org/schema/context/spring-context-4.0.xsd
		    http://www.springframework.org/schema/mvc
		    http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
		    http://www.springframework.org/schema/websocket
		    http://www.springframework.org/schema/websocket/spring-websocket.xsd">
		    <!-- 开启注解模式驱动 -->
		    <mvc:annotation-driven></mvc:annotation-driven>
		    <!-- 扫包 -->
		    <context:component-scan base-package="com.*"></context:component-scan>
		     
		    <!-- 静态资源过滤   -->
		    <!-- <mvc:resources location="/resources/" mapping="/resources/**"></mvc:resources> -->
		     
		    <!-- 视图渲染 -->
		    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		        <!-- 制定页面存放路径 -->
		        <property name="prefix" value="/WEB-INF/pages/"></property>
		        <!-- 文件的后缀 -->
		        <property name="suffix" value=".jsp"></property>
		    </bean>
		</beans>
		
index.jsp	
	
	<%@ page language="java" contentType="text/html; charset=UTF-8"
	    pageEncoding="UTF-8"%>
	<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
	<html>
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<script type="text/javascript" src="../js/jquery-3.2.1.min.js"></script>
	<title>Insert title here</title>
	</head>
	<script type="text/javascript">
	    $(function() {
	        $("span").click(function(){
	            var uname = $("input").val();
	            if(uname == ""){
	                alert("请先输入用户名");
	            }else {
	                var roomid = $(this).html()
	                console.log("roomid"+roomid);
	                location.href="/Chatroom/home/room.do?uname="+uname+"&roomid="+roomid;
	            }
	        })
	    })
	</script>
	<style>
	    span:HOVER{
	        color: red;
	    }
	    span{
	        cursor:pointer;
	    }
	</style>
	<body>
	    用户名:<input type="text">   /*注：请先输入用户名，且保证用户名唯一，再点击下面的房间加入房间
	    <h1><span>room1</span></h1>
	    <h1><span>room2</span></h1>
	</body>
	</html>	

room.jsp:

		<%@ page language="java" contentType="text/html; charset=UTF-8"
		    pageEncoding="UTF-8"%>
		<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
		<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
		<html>
		<head>
		<%
		String path = request.getContextPath();
		String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
		%>
		<base href="<%=basePath%>" />
		<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<script type="text/javascript" src="js/jquery-3.2.1.min.js"></script>
		<link rel="stylesheet" type="text/css" href="css/chat.css" />
		<title>聊天室</title>
		</head>
		<script type="text/javascript">
		$(function(){
		    var roomid=$(".roomid").html();//房间名
		    var nickname = $(".uname").html();//自己的昵称
		    var flag = "join";//标志位
		    var info = flag + "|" +roomid + "|" +nickname;//拼装websocket传递的参数
		    //建立一条与服务器之间的连接
		    var socket = new WebSocket("ws://${pageContext.request.getServerName()}:${pageContext.request.getServerPort()}${pageContext.request.contextPath}/websocket/"+info);
		    var text = "";
		    //console.log(${pageContext.request.getServerName()}+${pageContext.request.getServerPort()}${pageContext.request.contextPath});
		    console.log(socket);
		    /*定义加入房间时发送的消息内容*/
		    var welcome = JSON.stringify({          //加入房间时的欢迎消息
		                        nickname:nickname,    //用户名
		                        content:text,       //消息内容
		                        target:roomid,      //推送到目标房间
		                        flag:"chatroom"});  //推送标识
		                         
		    /*定义退出房间发送的消息内容*/                  
		    var exitroom = JSON.stringify({     //退出房间
		        nickname:nickname,
		        flag:"exitroom",
		        roomid:roomid
		    });
		                         
		    /*接收服务器的消息*/
		    socket.onmessage=function(ev){
		        var obj = eval(   '('+ev.data+')' );
		        addMessage(obj)
		    };
		     
		    /*当服务端执行onopen后触发此方法*/
		    socket.onopen = function(){
		        socket.send(welcome);
		    };
		 
		     
		 
		    /*发送按钮被点击触发点击事件*/
		    $(".ensure button").click(function(){
		        ensure();
		    });
		     
		    /*监听回车事件，按回车点击发送按钮*/
		    $("body").keyup(function (event) {//监听回车键
		        if (event.keyCode == "13") {//keyCode=13是回车键
		            $(".ensure button").trigger("click");
		        }
		    });
		     
		    /*发送消息的方法*/
		    function ensure(){
		        //获取输入框的内容
		        var txt = $(".center-input").val()
		        if(txt==''){
		              alert("不能发送空内容")
		        }else{
		            //构建一个标准格式的JSON对象
		            var obj = JSON.stringify({
		                    nickname:nickname,    //用户名
		                    content:txt,        //消息内容
		                    flag:'chatroom',            //标识--chatroom代表是聊天室的消息
		                    target:roomid   //消息推送的目的地
		                });
		            // 向服务器发送消息
		            socket.send(obj);
		            // 清空消息输入框
		            $(".center-input").val("")
		            // 消息输入框获取焦点
		            $(".center-input").focus();
		        }
		    }
		    /*向消息显示区域添加消息*/
		    function addMessage(msg){
		        if(msg.isSelf&&msg.content==""){ //该消息是自己发送的，并且内容为空
		            $(".center-info").append("<div class='welcome'>欢迎你加入群聊</div>");
		            refreshMember(msg.uname);  //刷新成员
		        }
		        if(!msg.isSelf&&msg.content==""){//该消息是别人发送的，并且内容为空
		            $(".center-info").append("<div class='welcome'>欢迎"+msg.nickname+"加入群聊</div>");
		            //刷新成员列表
		            refreshMember(msg.uname)
		        }
		        if(!msg.content==""){           //内容不为空时
		            var align;
		            if(msg.isSelf){
		                align = "right";
		            }else{
		                align = "left";
		            }
		            $(".center-info").append(
		                    "<div class='basicInfo' style=float:"+align+">"+
		                    "<div class='basicInfo-left' style=float:"+align+">"+
		                        "<img src='img/touxiang.jpg'>"+
		                    "</div>"+
		                    "<div class='basicInfo-right' style=float:"+align+">"+
		                        "<div class='username' style=text-align:"+align+">"+
		                            "<span>"+msg.nickname+"</span> "+
		                            "<span>"+msg.date+"</span>"+
		                        "</div>"+
		                        "<div class='context'>"+
		                            "<span>"+
		                                msg.content+
		                            "</span>"+
		                        "</div>"+
		                    "</div>"+
		                "</div>"
		            );
		        }
		        if(msg.flag == "exitroom"){     //退出房间
		            $(".center-info").append("<div class='welcome'>"+msg.message+"</div>");
		            //刷新成员列表
		            refreshMember(msg.uname)
		        }
		        $(".center-info").scrollTop(999999); //让滚动条始终保持在最下
		    }
		     
		     
		    /*退出聊天室点击事件*/
		    $(".exitroom").click(function(){            //退出房间
		        socket.send(exitroom); //向服务器发送退出房间的信号
		        location.href="/Chatroom/home/list.do"; //跳转到前一个页面
		    })
		     
		     
		    /*页面关闭时触发的事件*/
		    window.onbeforeunload = function(){
		        socket.send(exitroom); //向服务器发送退出房间的信号(该用户下线)
		    }
		     
		    /*刷新在线成员的方法*/
		    function refreshMember(data){
		        $(".member").html("");
		        for(var i=0;i<data.length;i++){
		            $(".member").append(
		                "<div class='memberInfo'>"+
		                    "<div class='userpic'>"+
		                        "<img src='img/touxiang.jpg'>"+
		                    "</div>"+
		                    "<span class='username'>"+data[i]+"</span>"+
		                "</div>"
		            )
		        }
		    }
		     
		})
		</script>
		 
		<body>
		    <div class="body-left">
		        <div class="left-info">
		            <div class="exitroom">
		                <--退出房间
		            </div>
		            <div class="roomname">
		                欢迎来到：<h1 style="display: inline-block;" class="roomid">${roomid }</h1>
		            </div>
		            <div class="member">
		                <c:forEach items="${requestScope.memberlist }" var="member">
		                    <div class="memberInfo">
		                        <div class="userpic">
		                            <img src="img/touxiang.jpg">
		                        </div>
		                        <span class="username">${member.username }</span>
		                        <span style = "display:none">${member.userid }</span>
		                    </div>
		                </c:forEach>
		            </div>
		        </div>
		    </div>
		    <div class="body-center">
		        <div class="center-info">
		 
		        </div>
		        <textarea class="center-input"></textarea>
		        <div class="ensure">
		            <button>发送</button>
		        </div>
		    </div>
		     
		    <div class="body-right">
		    </div>
		     
		    <span class="uname" style="display:none">${sessionScope.uname }</span>
		     
		</body>
		 
		</html>
		
Web.xml:

	<?xml version="1.0" encoding="UTF-8"?>
	<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1">
	  <display-name>springMVC</display-name>
	  <welcome-file-list>
	    <welcome-file>index.html</welcome-file>
	    <welcome-file>index.htm</welcome-file>
	    <welcome-file>index.jsp</welcome-file>
	    <welcome-file>default.html</welcome-file>
	    <welcome-file>default.htm</welcome-file>
	    <welcome-file>default.jsp</welcome-file>
	  </welcome-file-list>
	   
	  <!-- 配置监听器 -->
	  <listener>
	     <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	  </listener>
	  <context-param>
	    <param-name>contextConfigLocation</param-name>
	    <param-value>classpath:applicationContext.xml</param-value>
	  </context-param>
	   
	  <listener>
	    <listener-class>org.springframework.web.util.IntrospectorCleanupListener</listener-class>
	  </listener>
	   
	  <!-- 配置过滤器，解决post请求乱码问题 -->
	  <filter>
	        <filter-name>encoding</filter-name>
	        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
	        <init-param>
	            <param-name>encoding</param-name>
	            <param-value>UTF-8</param-value>
	        </init-param>
	  </filter>
	  <filter-mapping>
	        <filter-name>encoding</filter-name>
	        <url-pattern>/*</url-pattern>
	  </filter-mapping>
	   
	  <!-- 配置springmvc分发器，拦截请求 -->
	  <servlet>
	        <servlet-name>springmvc</servlet-name>
	        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	        <init-param>
	            <param-name>contextConfigLocation</param-name>
	            <param-value>classpath:springmvc.xml</param-value>
	        </init-param>
	  </servlet>
	  <servlet-mapping>
	        <servlet-name>springmvc</servlet-name>
	        <!-- <url-pattern>/</url-pattern> -->
	        <url-pattern>*.do</url-pattern>
	  </servlet-mapping>
	   
	  <!-- <servlet>
	        <servlet-name>default</servlet-name>
	        <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
	        <init-param>
	            <param-name>debug</param-name>
	            <param-value>0</param-value>
	        </init-param>
	        <init-param>
	            <param-name>listings</param-name>
	            <param-value>false</param-value>
	        </init-param>
	        <load-on-startup>1</load-on-startup>
	  </servlet>
	    
	  <servlet-mapping>
	    <servlet-name>default</servlet-name>
	    <url-pattern>*.png</url-pattern>
	  </servlet-mapping> -->
	</web-app>
	
Spring事件:

	ApplicationListener：事件监听者，观察者；
	ApplicationEvent：Spring 事件，记录事件源、时间和数据；
	ApplicationEventPublisher：发布事件；
	
	Spring 框架提供了四种容器事件，我们可以直接观察，包括：

		ContextStartedEvent：ApplicationContext 启动事件；
		ContextRefreshedEvent：ApplicationContext 更新事件；
		ContextStoppedEvent：ApplicationContext 停止事件；
		ContextClosedEvent：ApplicationContext 关闭事件。
		
		public class MyEvent extends ApplicationEvent{
			private String message;
			
			public EventDemo(Object source,String message){
				super(source);
				this.message = message;
			}
			public String getMessage(){
			
			}
		}
		
		@Component
		public class MyEventListener implements ApplicationListener<MyEvent>{
			public void onAplicationEvent(MyEvent event){
			
			}
		}
		
		@Component
		public class MyEventListener{
			@EventListener
			public void onApplicationEvent(Event event){
			
			}
		}
SpringBoot整合WebSocket：

	pom.xml:
		<!-- Spring Boot 启动父依赖 -->
	    <parent>
	        <groupId>org.springframework.boot</groupId>
	        <artifactId>spring-boot-starter-parent</artifactId>
	        <version>1.5.1.RELEASE</version>
	    </parent>
	    <properties>
	        <!-- 项目设置 : 编码格式 UTF-8 及 springboot 相关版本 -->
	        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	        <java.version>1.8</java.version>
	        <mybatis-spring-boot>1.2.0</mybatis-spring-boot>
	        <mysql-connector>5.1.39</mysql-connector>
	        <druid>1.0.18</druid>
	    </properties>
	
	    <dependencies>
	        
	        <dependency>
	            <groupId>org.springframework.boot</groupId>
	            <artifactId>spring-boot-starter</artifactId>
	        </dependency>
	        
	        <dependency>
	            <groupId>org.springframework.boot</groupId>
	            <artifactId>spring-boot-starter-websocket</artifactId>
	        </dependency>
	        
	        <!-- Spring Boot Test 依赖 -->
	        <dependency>
	            <groupId>org.springframework.boot</groupId>
	            <artifactId>spring-boot-starter-test</artifactId>
	            <scope>test</scope>
	        </dependency>
	    </dependencies>
	  <build>
	    <finalName>liaotianshi</finalName>
	  </build>
	  
	  
		import java.io.IOException;
		import java.util.ArrayList;
		import java.util.List;
		
		import org.springframework.stereotype.Component;
		import org.springframework.web.socket.CloseStatus;
		import org.springframework.web.socket.TextMessage;
		import org.springframework.web.socket.WebSocketHandler;
		import org.springframework.web.socket.WebSocketMessage;
		import org.springframework.web.socket.WebSocketSession;
		
		@Component
		public class SpringBootWebSocketHandler implements WebSocketHandler {
		
		    // 存储所有客户端的会话 WebSocketSession,key 使用客户端的唯一标识方便存取
		
		//    private static Map<String, WebSocketSession> allWebSocketSession = new HashMap<String, WebSocketSession>();
		    private static List<WebSocketSession> sessionList = new ArrayList<>();
		    /**
		     * 与服务器成功建立连接
		     */
		    @Override
		    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		        // TODO Auto-generated method stub
		        System.out.println("客户端成功建立连接=>" + session.getId());
		        sessionList.add(session);
		    }
		
		    /**
		     * 接受客户端的消息
		     */
		    @Override
		    public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {
        // 获取客户端的消息
        String msg = message.getPayload().toString();
//        System.out.println("接受到的客户端消息：" + msg);
        // 将数据存入会话 回传给客户端
//        session.sendMessage(new TextMessage("服务器接收到的消息：" + msg));
        sendMsg(msg);
    }

    //给所有客户端发信息的方法
    private void sendMsg(String msg) throws IOException {
        for (WebSocketSession session : sessionList) {
            if(session.isOpen()) {
                session.sendMessage(new TextMessage(msg));
            }
        }
    }
    
    /**
     * 通讯异常时
     */
    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        // TODO Auto-generated method stub
        System.out.println("通讯出现异常");
    }

    /**
     * 当连接关闭时
     */
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {
        // TODO Auto-generated method stub
        System.out.println("连接已关闭");
    }

    /**
     * 是否允许分段发送
     */
    @Override
    public boolean supportsPartialMessages() {
        // 一次性发送
        return false;
    }
}



import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.format.FormatterRegistry;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.validation.MessageCodesResolver;
import org.springframework.validation.Validator;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.HandlerMethodReturnValueHandler;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.config.annotation.AsyncSupportConfigurer;
import org.springframework.web.servlet.config.annotation.ContentNegotiationConfigurer;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.PathMatchConfigurer;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.ViewResolverRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration // 单例模式 bean
@EnableWebSocket // 启动 WebSocket 服务器
public class SpringBootWebSocketConfigurer implements WebMvcConfigurer, WebSocketConfigurer {
    @Autowired
    private SpringBootWebSocketHandler handler;

//    @Autowired
//    private SpringBootHandshakeInterceptor handshakeInterceptor;
    
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        // -------------------- 允许跨域访问 WebSocket ------------------------
        String[] allowsOrigins = { "*" };// 允许连接的域 , 只能以 http 或 https 开头
       
        // 7. 设置 websocket 服务器地址 ws://localhost:8080/SpringBootWebSocket
        registry.addHandler(handler, "/SpringBootWebSocket").setAllowedOrigins(allowsOrigins);
    }
    
    /**
     * 这下面的代码是没有什么用的 
     * 主要是第一个方法
     */
    	@Override
    	public void configurePathMatch(PathMatchConfigurer configurer) {
        	// TODO Auto-generated method stub
        
    	}

    	@Override
    	public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
        	// TODO Auto-generated method stub
        
    	}

    	@Override
    	public void configureAsyncSupport(AsyncSupportConfigurer configurer) {
        	// TODO Auto-generated method stub
        
    	}

    	@Override
    	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        	// TODO Auto-generated method stub
        
    	}

    	@Override
   		public void addFormatters(FormatterRegistry registry) {
        	// TODO Auto-generated method stub
        
    	}

    	@Override
    	public void addInterceptors(InterceptorRegistry registry) {
        	// TODO Auto-generated method stub
        
    	}

    	@Override
    	public void addResourceHandlers(ResourceHandlerRegistry registry) {
        	// TODO Auto-generated method stub
        
    	}

    	@Override
    	public void addCorsMappings(CorsRegistry registry) {
        	// TODO Auto-generated method stub
        
    	}

    	@Override
    	public void addViewControllers(ViewControllerRegistry registry) {
        	// TODO Auto-generated method stub
        
    	}

   	 	@Override
    	public void configureViewResolvers(ViewResolverRegistry registry) {
        	// TODO Auto-generated method stub
        
    	}

    	@Override
    	public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
        	// TODO Auto-generated method stub
        
    	}

    	@Override
    	public void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> returnValueHandlers) {
        	// TODO Auto-generated method stub
        
    	}

    	@Override
    	public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
	        // TODO Auto-generated method stub
	        
	    }
	
	    @Override
	    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
	        // TODO Auto-generated method stub
	        
	    }
	
	    @Override
	    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {
	        // TODO Auto-generated method stub
	        
	    }
	
	    @Override
	    public void extendHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {
	        // TODO Auto-generated method stub
	        
	    }
	
	    @Override
	    public Validator getValidator() {
	        // TODO Auto-generated method stub
	        return null;
	    }
	
	    @Override
	    public MessageCodesResolver getMessageCodesResolver() {
	        // TODO Auto-generated method stub
	        return null;
	    }
	}	
	
	
前端页面:
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>聊天室</title>
<link rel="stylesheet" href="layui/css/layui.css" media="all">
<script src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js"></script>
<script>
    $(document).ready(
            function() {
                var urlPrefix = "ws://localhost:8080/SpringBootWebSocket";
                var ws = null;
                // 加入聊天室  
                $('#bt_join').click(function() {
                    if(ws != null){
                        alert("用户【"+$('#username').val()+"】已加入连接");
                        return;
                    }
                    //建立连接
                    
                     //判断当前浏览器是否支持WebSocket
                      if ('WebSocket' in window) {
                          ws = new WebSocket(urlPrefix);
                      }
                      else {
                        alert('当前浏览器 Not support websocket');
                      }
                    
                    ws.onopen = function(event) {
                        console.log("与服务器建立连接");
                        ws.send("您的好友【"+$('#username').val()+"】上线了");
                    };
                    
                    // 接收服务端返回给前端的消息 
                    ws.onmessage = function(event) {
                        $('#text_chat_content').append(
                                event.data + "\n");
                    };
                    ws.onclose = function() {
                        console.log("与服务器断开连接");
                        $('#text_chat_content').append(
                                "用户【" + $('#username').val() + "】离开聊天室！" + "\n");
                        $("#username").val("");
                    };
                });
                // 发送消息  
                $('#bt_send').click(function() {
                    if (ws == null) {
                        alert("该用户不在线");
                        return;
                    }
                    var msg = $('#in_msg').val();
                    ws.send("用户【" + $('#username').val() + "】：" + msg);
                });
                // 离开聊天室  
                $('#bt_left').click(function() {
                    ws.send("用户【" + $('#username').val() + "】离开聊天室！");
                    $('#in_msg').val("");
                    ws.close();
                });
            })
</script>
</head>
<body>
    聊天消息内容：
    <br />
    <textarea id="text_chat_content" readonly="readonly" class="layui-textarea" style="height: 400px; width: 600px;"></textarea>
    <br /> 输入框：
    <br />
    <div class="layui-input-inline">
        <textarea id="in_msg" placeholder="请输入内容" class="layui-textarea" style="height: 100px; width: 500px;">
        </textarea>
    </div>
    <button type="button" id="bt_send" class="layui-btn layui-btn-radius">发送信息</button>
    <br /> <br />
    <label class="layui-form-mid">用户：</label>
    <div class="layui-input-inline">
        <input type="text" id="username" placeholder="请输入姓名" class="layui-input">
    </div>
    <button type="button" id="bt_join" class="layui-btn layui-btn-radius layui-btn-normal">加入聊天室</button>
    <button type="button" id="bt_left" class="layui-btn layui-btn-radius layui-btn-normal">离开聊天室</button>
</body>
</html>



SpringBoot整合Spring Data JPA:

	pom.xml:
	

		    <properties>
		        <java.version>1.8</java.version>
		    </properties>
		
		    <dependencies>
		        <!-- web -->
		        <dependency>
		                <groupId>org.springframework.boot</groupId>
		                <artifactId>spring-boot-starter-web</artifactId>
		         </dependency>
		        <!-- swagger -->
		        <dependency>
		            <groupId>io.springfox</groupId>
		            <artifactId>springfox-swagger2</artifactId>
		            <version>2.9.2</version>
		        </dependency>
		        <dependency>
		            <groupId>io.springfox</groupId>
		            <artifactId>springfox-swagger-ui</artifactId>
		            <version>2.9.2</version>
		        </dependency>
		        <!-- jpa -->
		        <dependency>
		            <groupId>org.springframework.boot</groupId>
		            <artifactId>spring-boot-starter-data-jpa</artifactId>
		        </dependency>
		        <!-- mysql -->
		        <dependency>
		            <groupId>mysql</groupId>
		            <artifactId>mysql-connector-java</artifactId>
		        </dependency>
		    </dependencies>
		
		    <build>
		        <plugins>
		            <plugin>
		                <groupId>org.springframework.boot</groupId>
		                <artifactId>spring-boot-maven-plugin</artifactId>
		            </plugin>
		        </plugins>
		        <!-- 打包时拷贝MyBatis的映射文件 -->
		        <resources>
		            <resource>
		                <directory>src/main/java</directory>
		                <includes>
		                    <include>**/sqlmap/*.xml</include>
		                </includes>
		                <filtering>false</filtering>
		            </resource>
		            <resource>  
		                <directory>src/main/resources</directory>  
		                    <includes> 
		                        <include>**/*.*</include>  
		                    </includes> 
		                    <filtering>true</filtering>  
		            </resource> 
		        </resources>
		    </build>
		
		
	application.yml:

		server:
		  port: 8080
		spring:
		  datasource:
		    driverClassName: com.mysql.cj.jdbc.Driver
		    url: jdbc:mysql://localhost:3306/springboot?useUnicode=true&zeroDateTimeBehavior=convertToNull&autoReconnect=true&characterEncoding=utf-8
		    username: root
		    password: 123456
		  jpa:
		    show-sql: true # 默认false，在日志里显示执行的sql语句
		    database: mysql
		    hibernate.ddl-auto: update #指定为update，每次启动项目检测表结构有变化的时候会新增字段，表不存在时会新建，如果指定create，则每次启动项目都会清空数据并删除表，再新建
		    properties.hibernate.dialect: org.hibernate.dialect.MySQL5Dialect
		    database-platform: org.hibernate.dialect.MySQL5Dialect
		    hibernate:
		      naming:
		        implicit-strategy: org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl #指定jpa的自动表生成策略，驼峰自动映射为下划线格式
		        #physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
	
	
	配置Swagger2:
	
		import org.springframework.context.annotation.Bean;
		import org.springframework.context.annotation.Configuration;
		import springfox.documentation.builders.ApiInfoBuilder;
		import springfox.documentation.builders.PathSelectors;
		import springfox.documentation.builders.RequestHandlerSelectors;
		import springfox.documentation.service.ApiInfo;
		import springfox.documentation.spi.DocumentationType;
		import springfox.documentation.spring.web.plugins.Docket;
		import springfox.documentation.swagger2.annotations.EnableSwagger2;
		
		@Configuration
		@EnableSwagger2
		public class SwaggerConfig {
		
		    @Bean
		    public Docket createRestApi(){
		        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())
		                .select()
		                .apis(RequestHandlerSelectors.any())
		                .paths(PathSelectors.any()).build();
		    }
		
		    private ApiInfo apiInfo(){
		        return new ApiInfoBuilder()
		                .title("SpringBoot API Doc")
		                .description("This is a restful api document of Spring Boot.")
		                .version("1.0")
		                .build();
		    }
		}
		
	entity:
	
		import javax.persistence.Column;
		import javax.persistence.Entity;
		import javax.persistence.GeneratedValue;
		import javax.persistence.GenerationType;
		import javax.persistence.Id;
		import javax.persistence.Index;
		import javax.persistence.Table;
		
		@Entity    // @Entity: 实体类, 必须
		// @Table: 对应数据库中的表, 必须, name=表名, Indexes是声明表里的索引, columnList是索引的列, 同时声明此索引列是否唯一, 默认false
		@Table(name = "sys_user", indexes = {@Index(name = "id", columnList = "id", unique = true), @Index(name = "name", columnList = "name", unique = true)})
		public class SysUser {
		    
		    @Id // @Id: 指明id列, 必须
		    @GeneratedValue(strategy = GenerationType.IDENTITY) // @GeneratedValue： 表明是否自动生成, 必须, strategy也是必写, 指明主键生成策略, 默认是Oracle
		    private Long id;
		  
		    @Column(name = "name", nullable = false) // @Column： 对应数据库列名,可选, nullable 是否可以为空, 默认true
		    private String name; 
		
		    private String password;
		
		    private String email;
		
		    public Long getId() {
		        return id;
		    }
		
		    public void setId(Long id) {
		        this.id = id;
		    }
		
		    public String getName() {
		        return name;
		    }
		
		    public void setName(String name) {
		        this.name = name;
		    }
		
		    public String getPassword() {
		        return password;
		    }
		
		    public void setPassword(String password) {
		        this.password = password;
		    }
		
		    public String getEmail() {
		        return email;
		    }
		
		    public void setEmail(String email) {
		        this.email = email;
		    }
		}	
		
	Dao:
	
		import java.io.Serializable;
		
		import org.springframework.data.jpa.repository.JpaRepository;
		
		import com.louis.springboot.demo.model.SysUser;
		
		public interface SysUserDao extends JpaRepository<SysUser, Long>, Serializable {
		    
		}
		
	Service:
	
		import java.util.List;
		import com.louis.springboot.demo.model.SysUser;
		import com.louis.springboot.demo.util.PageQuery;
		
		public interface SysUserService {
		
		    /**
		     * 保存用户
		     * @param user
		     */
		    public void save(SysUser user);
		    
		    /**
		     * 删除用户
		     * @param id
		     */
		    public void delete(SysUser user);
		    
		    /**
		     * 查询全部用户
		     * @return
		     */
		    public List<SysUser> findAll();
		    
		    /**
		     * 查询分页数据
		     * @return
		     */
		    public Object findPage(PageQuery pageQuery);
		
		}
		
		
		import java.util.List;
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.data.domain.PageRequest;
		import org.springframework.stereotype.Service;
		import com.louis.springboot.demo.dao.SysUserDao;
		import com.louis.springboot.demo.model.SysUser;
		import com.louis.springboot.demo.service.SysUserService;
		import com.louis.springboot.demo.util.PageQuery;
		
		@Service
		public class SysUserServiceImpl implements SysUserService {
		    
		    @Autowired
		    private SysUserDao sysUserDao;
		
		    @Override
		    public void save(SysUser user) {
		        sysUserDao.save(user);
		    }
		
		    @Override
		    public void delete(SysUser user) {
		        sysUserDao.delete(user);
		    }
		
		    @Override
		    public List<SysUser> findAll() {
		        return sysUserDao.findAll();
		    }
		
		    @Override
		    public Object findPage(PageQuery pageQuery) {
		        return sysUserDao.findAll(PageRequest.of(pageQuery.getPage(), pageQuery.getSize()));
		    }
		}
		
		
		
	Controller:
	
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.web.bind.annotation.GetMapping;
		import org.springframework.web.bind.annotation.PostMapping;
		import org.springframework.web.bind.annotation.RequestBody;
		import org.springframework.web.bind.annotation.RequestMapping;
		import org.springframework.web.bind.annotation.RestController;
		
		import com.louis.springboot.demo.model.SysUser;
		import com.louis.springboot.demo.service.SysUserService;
		import com.louis.springboot.demo.util.PageQuery;
		
		@RestController
		@RequestMapping("user")
		public class SysUserController {
		
		    @Autowired
		    private SysUserService sysUserService;
		    
		    @PostMapping(value="/save")
		    public Object save(@RequestBody SysUser user) {
		        sysUserService.save(user);
		        return 1;
		    }
		    
		    @PostMapping(value="/delete")
		    public Object delete(@RequestBody SysUser user) {
		        sysUserService.delete(user);
		        return 1;
		    }
		    
		    @GetMapping(value="/findAll")
		    public Object findAll() {
		        return sysUserService.findAll();
		    }
		    
		    @PostMapping(value="/findPage")
		    public Object findPage(@RequestBody PageQuery pageQuery) {
		        return sysUserService.findPage(pageQuery);
		    }
		}
		
		public class PageQuery {
		
		    private int page;
		    private int size;
		    
		    public int getPage() {
		        return page;
		    }
		    public void setPage(int page) {
		        this.page = page;
		    }
		    public int getSize() {
		        return size;
		    }
		    public void setSize(int size) {
		        this.size = size;
		    }
		}
	
		

		
He enjoys walking in the hills.
	他喜欢在山里散步
To say it is one thing;to do it is another
	说是一回事;做是另一回事
What we can't get seems better than what we have
	我们得不到的似乎比我们拥有的更好
stand up,please
	请站起来
Don't cry
	不要哭
well done
	做得很好
The room can hold twenty people
	这房子可容纳20个人
My legs gave out after the long trip
	长途跋涉后我的腿精疲力竭
He likes playing basketball
	他喜欢打篮球
They like playing basketball
	他们喜欢打篮球
he is a light eater but a heavy sleeper
	他这个人吃得少却能睡
her work is to look after the children
	她的工作是照看孩子们
his hobby is collecting stamps
	他的爱好是集邮
that's where i was born
	那就是我出生的地方
he promised to come as soon as possible
	他答应尽快过来
I remember giving her money back last week
	我记得上星期已经还她钱了
mother bought me a shirt yesterday
	母亲昨天给我买了一件衬衫
she taught us english then
	她当时教我们英语
i sent my mother two letters yesterday
	我昨天给母亲寄了两封信
	

使用 Netty 远程传输文件





	
	

</mapper>